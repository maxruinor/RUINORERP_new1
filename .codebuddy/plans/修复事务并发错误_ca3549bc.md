---
name: 修复事务并发错误
overview: 修复SQL Server事务并发错误'不允许启动新事务，因为有其他线程正在该会话中运行'，优化UnitOfWorkManage事务管理机制
todos:
  - id: explore-transaction-code
    content: 使用[subagent:code-explorer]搜索并分析UnitOfWorkManage、tb_FM_PaymentRecordController和所有AOP拦截器的完整实现
    status: completed
  - id: analyze-connection-sharing
    content: 分析当前连接管理机制，识别共享连接导致事务冲突的具体场景
    status: completed
    dependencies:
      - explore-transaction-code
  - id: design-transaction-context
    content: 设计TransactionContext类和增强的事务状态管理架构
    status: completed
    dependencies:
      - analyze-connection-sharing
  - id: enhance-unitofwork
    content: 修改UnitOfWorkManage，实现专用连接隔离和双重检测机制
    status: completed
    dependencies:
      - design-transaction-context
  - id: optimize-controller
    content: 优化tb_FM_PaymentRecordController的BaseSaveOrUpdateWithChild方法，修复事务嵌套调用逻辑
    status: completed
    dependencies:
      - enhance-unitofwork
  - id: refactor-aop-interceptor
    content: 重构AOP拦截器，确保只读事务状态不修改上下文
    status: completed
    dependencies:
      - enhance-unitofwork
  - id: implement-diagnostics
    content: 创建TransactionDiagnostics工具类，实现事务监控和僵尸事务自动清理
    status: completed
    dependencies:
      - refactor-aop-interceptor
  - id: add-logging
    content: 在关键节点添加详细的事务生命周期日志，包含TransactionId和调用堆栈
    status: completed
    dependencies:
      - implement-diagnostics
  - id: test-transaction-fix
    content: 使用[skill:skill-creator]创建事务并发测试用例，验证修复效果
    status: completed
    dependencies:
      - add-logging
---

## 问题概述

在收款单保存操作时出现SQL Server事务并发错误："不允许启动新事务，因为有其他线程正在该会话中运行"。该错误发生在`RUINORERP.Repository.UnitOfWorks.UnitOfWorkManage.BeginTran()`方法中，涉及`tb_FM_PaymentRecordController`的`BaseSaveOrUpdateWithChild`方法。

## 核心问题

- **事务状态检测不足**：现有僵尸事务检测机制清理不彻底，导致事务残留
- **连接共享问题**：可能存在多个操作共享同一数据库连接导致的事务冲突
- **事务嵌套风险**：`BaseSaveOrUpdateWithChild`方法中事务控制依赖`UseTran`参数，存在嵌套调用时的状态管理问题
- **AOP拦截器干扰**：AOP拦截器在事务调用链中可能影响事务上下文，导致状态不一致

## 解决方案目标

- 增强事务状态检测与自动清理机制
- 修复连接共享导致的事务并发问题
- 优化AOP拦截器逻辑，确保事务上下文完整性
- 提供详细的事务执行日志以便问题追踪

## 技术栈分析

- **框架**：基于.NET Framework的WinForms应用
- **ORM**：SqlSugar（从文件名和错误模式推断）
- **架构**：Repository模式 + UnitOfWork模式
- **AOP**：自定义拦截器实现
- **数据访问**：`RUINORERP.Repository`命名空间下的UnitOfWorkManage

## 实现方案

### 架构设计

采用分层事务状态管理架构：

1. **连接层**：确保每个事务拥有独立的数据库连接
2. **状态管理层**：增强AsyncLocal的事务状态追踪，添加完整生命周期监控
3. **检测清理层**：实现定期检测和即时清理双重机制
4. **拦截器优化层**：AOP拦截器与事务管理器解耦，避免状态污染

### 核心实现策略

1. **连接隔离**：修改UnitOfWorkManage，确保事务启动时获取专用连接
2. **状态增强**：扩展AsyncLocal存储，增加事务ID、创建时间、调用堆栈等信息
3. **双重检测**：

- 即时检测：BeginTran前检查是否存在活跃事务
- 后台检测：定时任务清理超时僵尸事务

4. **拦截器优化**：AOP拦截器只读事务状态，不修改事务上下文

### 性能与可靠性

- **连接池影响**：专用连接会短暂增加连接池压力，通过缩短事务时间和及时释放缓解
- **状态追踪开销**：AsyncLocal状态信息增加内存占用，但可忽略不计
- **检测频率**：后台检测设置为5分钟一次，避免频繁扫描
- **超时设置**：事务超时默认30秒，防止长时间占用

## 实现细节

### 目录结构

```
e:/CodeRepository/SynologyDrive/RUINORERP/
├── RUINORERP.Repository/
│   └── UnitOfWorks/
│       ├── UnitOfWorkManage.cs          # [MODIFY] 增强事务管理逻辑
│       ├── UnitOfWorkStatus.cs          # [NEW] 事务状态枚举
│       └── TransactionContext.cs        # [NEW] 事务上下文信息类
├── RUINORERP.UI/
│   └── FM/
│       └── tb_FM_PaymentRecordController.cs  # [MODIFY] 优化事务调用逻辑
├── RUINORERP.AOP/                      # 假设的AOP目录
│   └── TransactionInterceptor.cs      # [MODIFY] 优化拦截器
└── RUINORERP.Common/
    └── Diagnostics/
        └── TransactionDiagnostics.cs  # [NEW] 事务诊断工具
```

### 关键代码结构

```
// TransactionContext.cs - 事务上下文信息
public class TransactionContext
{
    public Guid TransactionId { get; set; }
    public DateTime CreatedAt { get; set; }
    public string CallerMethod { get; set; }
    public string StackTrace { get; set; }
    public TransactionStatus Status { get; set; }
    public IDbConnection DedicatedConnection { get; set; }
}

// UnitOfWorkManage.cs - 增强的事务管理
public class UnitOfWorkManage
{
    private static readonly AsyncLocal<TransactionContext> _currentTransaction = new AsyncLocal<TransactionContext>();
    private static readonly ConcurrentDictionary<Guid, TransactionContext> _activeTransactions = new ConcurrentDictionary<Guid, TransactionContext>();
    
    public void BeginTran()
    {
        // 增强的检测逻辑
        var existingContext = _currentTransaction.Value;
        if (existingContext != null && existingContext.Status == TransactionStatus.Active)
        {
            throw new InvalidOperationException($"检测到活跃事务残留: {existingContext.TransactionId}");
        }
        
        // 创建新事务上下文
        var context = new TransactionContext
        {
            TransactionId = Guid.NewGuid(),
            CreatedAt = DateTime.Now,
            CallerMethod = GetCallerMethod(),
            Status = TransactionStatus.Active
        };
        
        // 获取专用连接
        context.DedicatedConnection = GetDedicatedConnection();
        
        _currentTransaction.Value = context;
        _activeTransactions.TryAdd(context.TransactionId, context);
        
        // 启动事务
        BeginTransactionOnConnection(context.DedicatedConnection);
    }
}
```

### 监控与日志

- 记录每个事务的完整生命周期（开始、提交、回滚、超时）
- 在日志中包含TransactionId和调用堆栈
- 后台清理操作记录到独立日志文件

## Agent Extensions

### SubAgent

- **code-explorer**
- 用途：在复杂代码库中搜索事务相关的类和方法，特别是UnitOfWorkManage、tb_FM_PaymentRecordController和AOP拦截器的实现
- 预期结果：精确定位所有相关代码文件，获取完整的调用链和依赖关系

### Skill

- **skill-creator**
- 用途：创建事务诊断和监控的专用技能，用于后续自动化检测类似问题
- 预期结果：生成可重用的诊断工具集，包括事务状态查询、僵尸事务清理等功能