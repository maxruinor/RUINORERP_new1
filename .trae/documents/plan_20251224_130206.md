# 代码重构方案：减少表格显示逻辑的冗余代码

## 1. 现有代码分析

### 文件结构与关系
- **GridViewDisplayHelper.cs**：核心工具类，处理外键关联、缓存机制和枚举固定值
- **GridViewDisplayTextResolver.cs**：非泛型版本的显示文本解析器，用于视图分析
- **GridViewDisplayTextResolverGeneric.cs**：泛型版本的显示文本解析器

### 重复代码与冗余逻辑
1. **两个Resolver类之间的重复**：
   - AddReferenceKeyMapping方法
   - AddFixedDictionaryMapping方法
   - AddFixedDictionaryMappingByEnum方法
   - AddColumnDisplayType方法
   - AddReferenceKeyColumnMapping方法
   - 单元格格式化事件处理逻辑

2. **Resolver类与Helper类之间的重复**：
   - Resolver类中的一些方法只是简单调用Helper类的对应方法

3. **Helper类内部的重复**：
   - InitializeFixedDictionaryMappings的泛型和非泛型版本
   - InitializeReferenceKeyMapping的泛型和非泛型版本

## 2. 重构方案

### 设计原则
- **DRY原则**：消除重复代码，提高代码复用性
- **单一职责**：每个类只负责特定功能
- **继承复用**：通过抽象基类提取共同逻辑
- **最小修改**：保持现有API的完整性，减少对现有代码的影响

### 重构步骤

#### 1. 创建抽象基类
创建`AbstractGridViewDisplayTextResolver`抽象基类，提取两个Resolver类的共同逻辑：

```csharp
public abstract class AbstractGridViewDisplayTextResolver
{
    protected GridViewDisplayHelper displayHelper;
    protected Type _entityType;
    
    protected AbstractGridViewDisplayTextResolver(Type entityType)
    {
        _entityType = entityType;
        displayHelper = new GridViewDisplayHelper();
    }
    
    // 提取共同方法和属性
    // ...
}
```

#### 2. 重构两个Resolver类
- **GridViewDisplayTextResolver**：继承自抽象基类，处理非泛型场景
- **GridViewDisplayTextResolverGeneric<T>**：继承自抽象基类，处理泛型场景

#### 3. 优化Helper类
- 简化泛型方法的实现，直接调用非泛型方法
- 移除不必要的重复代码

#### 4. 统一事件处理
将单元格格式化事件处理逻辑提取到基类中，减少重复

## 3. 具体实现

### 1. 创建抽象基类AbstractGridViewDisplayTextResolver

**文件**：`e:\CodeRepository\SynologyDrive\RUINORERP\RUINORERP.UI\Common\AbstractGridViewDisplayTextResolver.cs`

**核心代码**：
```csharp
public abstract class AbstractGridViewDisplayTextResolver
{
    protected GridViewDisplayHelper displayHelper;
    protected Type _entityType;
    
    // 用于存储列的显示类型
    protected Dictionary<string, string> ColumnDisplayTypes { get; set; } = new Dictionary<string, string>();
    
    // 用于存储外键列的映射
    protected Dictionary<string, string> ReferenceKeyColumnMappings { get; set; } = new Dictionary<string, string>();
    
    protected AbstractGridViewDisplayTextResolver(Type entityType)
    {
        _entityType = entityType;
        displayHelper = new GridViewDisplayHelper();
    }
    
    // 提取共同方法...
    
    // 单元格格式化事件处理
    protected void OnDataGridViewCellFormatting(DataGridView dataGridView, DataGridViewCellFormattingEventArgs e, string tableName)
    {
        if (e.FormattingApplied) return;
        if (!dataGridView.Columns[e.ColumnIndex].Visible) return;
        if (e.Value == null) {
            e.Value = "";
            return;
        }
        
        string columnName = dataGridView.Columns[e.ColumnIndex].Name;
        string oldValue = e.Value?.ToString();
        
        // 处理特殊列类型（如图片）
        if (ColumnDisplayTypes.ContainsKey(columnName))
        {
            // 图片处理逻辑...
        }
        
        // 获取显示文本
        string displayText = displayHelper.GetGridViewDisplayText(tableName, columnName, e.Value);
        if (!string.IsNullOrEmpty(displayText) && !displayText.Equals(oldValue))
        {
            e.Value = displayText;
            e.FormattingApplied = true;
        }
    }
}
```

### 2. 重构GridViewDisplayTextResolver

**修改内容**：
- 继承自AbstractGridViewDisplayTextResolver
- 移除重复的方法实现，使用基类的方法
- 简化单元格格式化事件处理

### 3. 重构GridViewDisplayTextResolverGeneric<T>

**修改内容**：
- 继承自AbstractGridViewDisplayTextResolver
- 使用typeof(T)初始化基类
- 移除重复的方法实现，使用基类的方法
- 简化单元格格式化事件处理

### 4. 优化GridViewDisplayHelper

**修改内容**：
- 简化泛型方法，直接调用非泛型方法
- 如：
  ```csharp
  public void InitializeFixedDictionaryMappings<T>()
  {
      InitializeFixedDictionaryMappings(typeof(T));
  }
  ```

## 4. 预期效果

1. **减少代码重复**：通过抽象基类提取共同逻辑，减少两个Resolver类之间的重复代码
2. **提高可维护性**：修改共同逻辑只需修改基类，减少维护成本
3. **保持API兼容性**：现有代码无需修改即可使用重构后的类
4. **优化代码结构**：清晰的继承层次，每个类职责明确
5. **提高性能**：减少不必要的方法调用和重复逻辑

## 5. 测试建议

1. **功能测试**：验证重构后的代码能够正确显示外键关联、枚举值等
2. **性能测试**：比较重构前后的性能差异，确保没有性能下降
3. **兼容性测试**：确保现有代码能够正常工作，无需修改
4. **边界测试**：测试各种边界情况，如空值、无效枚举值等

## 6. 实施风险与应对措施

1. **风险**：重构可能引入新的bug
   **应对**：充分测试，保持代码版本控制，以便回滚

2. **风险**：现有代码可能依赖于某些内部实现
   **应对**：保持现有API不变，只修改内部实现

3. **风险**：重构可能影响系统性能
   **应对**：进行性能测试，确保重构后的代码性能不低于原代码

通过这个重构方案，我们可以减少代码重复，优化代码结构，提高代码的可维护性和扩展性，同时保持与现有系统的兼容性。