## 修复查询条件重复添加问题

### 1. 分析问题原因
- 当前`QueryFilter.SetQueryField`方法使用`QueryFields.Contains(queryField)`检查重复
- 但`QueryField`类未重写`Equals`和`GetHashCode`方法，导致使用默认引用相等性检查
- 每次调用`SetQueryField`创建新对象，即使字段名相同也被视为不同对象

### 2. 修复方案

#### 2.1 为`QueryField`类添加相等性比较方法
- 重写`Equals`方法，基于`FieldName`和`QueryTargetType`进行比较
- 重写`GetHashCode`方法，确保相同字段生成相同哈希码

#### 2.2 优化`SetQueryField`方法的重复检查逻辑
- 使用更准确的判断条件：基于`FieldName`和`QueryTargetType`检查
- 当检测到重复时，返回已存在的字段而不是创建新字段
- 添加日志记录重复添加尝试

#### 2.3 添加用户反馈机制
- 在重复添加时记录详细日志
- 考虑添加调试信息，便于开发人员追踪问题

### 3. 代码修改计划

#### 3.1 修改`QueryField.cs`
```csharp
// 添加Equals方法
public override bool Equals(object obj)
{
    if (obj is QueryField other)
    {
        return this.FieldName == other.FieldName && 
               this.QueryTargetType == other.QueryTargetType;
    }
    return false;
}

// 添加GetHashCode方法
public override int GetHashCode()
{
    return HashCode.Combine(FieldName, QueryTargetType);
}
```

#### 3.2 修改`QueryFilter.cs`中的`SetQueryField`方法
```csharp
// 检查是否已存在相同字段
var existingField = QueryFields.FirstOrDefault(qf => 
    qf.FieldName == fieldID && qf.QueryTargetType == typeof(T));
if (existingField != null)
{
    // 记录日志
    // 返回已存在的字段
    return existingField;
}

// 继续创建新字段...
```

### 4. 验证和测试
- 确保库存视图中重复添加SKU字段时被正确拦截
- 测试不同场景下的重复添加情况
- 验证修改不影响现有功能

### 5. 代码审查点
- 确保相等性比较逻辑准确
- 确保日志记录详细有用
- 确保修改符合现有架构设计
- 确保性能不受负面影响

### 6. 预期效果
- 相同属性/字段重复添加时被正确拦截
- 避免出现无描述的重复查询条件
- 提高系统的健壮性和用户体验
- 便于开发人员追踪和调试问题