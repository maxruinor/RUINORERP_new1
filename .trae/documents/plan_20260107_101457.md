## 现有代码分析

1. **锁定状态检查逻辑**：
   - 已实现`CheckLockStatusAndUpdateUI`方法用于检查单据锁定状态
   - 在关键操作中调用该方法检查锁定状态
   - 但在一些地方没有正确处理返回结果

2. **关键操作按钮处理**：
   - 新增、修改、保存、提交、审核等操作都调用了锁定状态检查
   - 但没有统一的锁定状态提示机制
   - 被锁定单据的关键操作按钮点击后可能仍会执行实际操作

3. **锁定和解锁入口**：
   - 锁定入口：`LockBill`方法
   - 解锁入口：`UNLock`方法和`UNLockByBizName`方法
   - 存在重复冗余的锁定状态检查和UI更新代码

4. **锁定状态变化通知**：
   - 已实现`LockStatusNotificationService`用于处理锁定状态变化通知
   - 已实现`OnLockStatusChanged`方法用于更新UI
   - 但在多窗体环境下可能存在同步问题

## 修复计划

### 1. 完善关键操作按钮的锁定状态检查和提示机制

**修改文件**：`BaseBillEditGeneric.cs`

**修改内容**：
- 在`CheckLockStatusAndUpdateUI`方法中，当单据被锁定且锁定用户不是当前用户时，添加状态栏提示
- 在各个关键操作方法中，确保当`CanPerformCriticalOperations`为`false`时，只显示状态提示，不执行实际操作
- 统一使用`MainForm.Instance.ShowStatusText`方法显示状态栏提示

### 2. 优化锁定和解锁入口的重复冗余代码

**修改文件**：`BaseBillEditGeneric.cs`

**修改内容**：
- 提取锁定状态检查和UI更新的重复代码到公共方法
- 统一处理锁定和解锁操作的UI更新和状态栏提示
- 确保锁定和解锁操作后，及时更新UI和状态栏

### 3. 完善锁定状态变化时的UI同步机制

**修改文件**：`BaseBillEditGeneric.cs`

**修改内容**：
- 确保`OnLockStatusChanged`方法能够正确处理多窗体环境下的锁定状态同步
- 在锁定状态变化时，更新所有打开相同单据的窗体的UI
- 确保状态栏提示信息的准确性和及时性

### 4. 确保被锁定单据的关键操作按钮点击后无实际操作执行

**修改文件**：`BaseBillEditGeneric.cs`

**修改内容**：
- 在各个关键操作方法中，确保当`CanPerformCriticalOperations`为`false`时，不执行实际操作
- 只显示"单据[单据编号]已被[用户名]锁定"的状态栏提示

## 具体代码修改

### 1. 完善`CheckLockStatusAndUpdateUI`方法

在`CheckLockStatusAndUpdateUI`方法中，当单据被锁定且锁定用户不是当前用户时，添加状态栏提示：

```csharp
// 如果单据被锁定，且锁定用户不是当前用户
if (isLocked && lockInfo.LockedUserId != currentUserId)
{
    // 显示状态栏提示
    string billNo = EditEntity?.GetPropertyValue(EntityMappingHelper.GetEntityInfo<T>().NoField)?.ToString() ?? billId.ToString();
    MainForm.Instance.ShowStatusText($"单据{billNo}已被{lockInfo.LockedUserName}锁定");
    return (isLocked, false, lockInfo);
}
```

### 2. 优化关键操作方法中的锁定状态检查

在各个关键操作方法中，确保正确处理锁定状态检查结果：

```csharp
// 检查锁定状态
var lockStatus = await CheckLockStatusAndUpdateUI(EditEntity.PrimaryKeyID);
if (!lockStatus.CanPerformCriticalOperations)
{
    // 只显示状态提示，不执行实际操作
    return;
}
```

### 3. 优化锁定和解锁方法

统一处理锁定和解锁操作的UI更新和状态栏提示：

```csharp
// LockBill方法
public async Task<bool> LockBill(long? billId = null, string billNo = null, long? userId = null)
{
    // 执行锁定操作
    var result = await _integratedLockService.LockBillAsync(finalBillId, finalBillNo, EntityMappingHelper.GetEntityInfo<T>().BizType, CurMenuInfo.MenuID);
    
    // 更新UI和状态栏
    await CheckLockStatusAndUpdateUI(finalBillId, true);
    
    if (result.IsSuccess)
    {
        MainForm.Instance.ShowStatusText($"成功锁定单据{finalBillNo}");
    }
    else
    {
        MainForm.Instance.ShowStatusText($"锁定单据{finalBillNo}失败：{result.Message}");
    }
    
    return result.IsSuccess;
}

// UNLock方法
public override void UNLock(bool NeedUpdateUI = false)
{
    // 执行解锁操作
    _integratedLockService.UnlockBillAsync(currentPkid).Wait();
    
    // 更新UI和状态栏
    if (NeedUpdateUI)
    {
        CheckLockStatusAndUpdateUI(currentPkid, true).Wait();
    }
    
    MainForm.Instance.ShowStatusText($"成功解锁单据{BillNo}");
}
```

### 4. 完善`OnLockStatusChanged`方法

确保在锁定状态变化时，更新UI和状态栏：

```csharp
private void OnLockStatusChanged(LockStatusChangeEventArgs args)
{
    // 确保在UI线程执行
    if (this.InvokeRequired)
    {
        this.Invoke(new Action<LockStatusChangeEventArgs>(OnLockStatusChanged), args);
        return;
    }
    
    // 更新锁信息
    _currentLockInfo = args.LockInfo;
    
    // 更新UI
    UpdateLockUI(args.LockInfo);
    
    // 更新状态栏提示
    if (args.LockInfo != null && args.LockInfo.IsLocked)
    {
        string billNo = EditEntity?.GetPropertyValue(EntityMappingHelper.GetEntityInfo<T>().NoField)?.ToString() ?? args.BillId.ToString();
        MainForm.Instance.ShowStatusText($"单据{billNo}已被{args.LockInfo.LockedUserName}锁定");
    }
    else
    {
        string billNo = EditEntity?.GetPropertyValue(EntityMappingHelper.GetEntityInfo<T>().NoField)?.ToString() ?? args.BillId.ToString();
        MainForm.Instance.ShowStatusText($"单据{billNo}已解锁");
    }
}
```

## 预期效果

1. **关键操作按钮点击事件的锁定状态检查逻辑**：
   - 当单据被锁定时，点击关键操作按钮只显示状态栏提示，不执行实际操作
   - 状态栏提示格式为"单据[单据编号]已被[用户名]锁定"

2. **锁定状态变化时的UI同步机制**：
   - 当单据锁定状态变化时，所有打开相同单据的窗体都会及时更新锁定状态
   - 状态栏提示信息准确、及时

3. **重复冗余代码的优化**：
   - 提取重复的锁定状态检查和UI更新代码到公共方法
   - 遵循DRY原则，减少代码冗余

4. **多窗体(MDI框架)环境下的锁定状态同步问题**：
   - 确保在多窗体环境下，锁定状态能够正确同步
   - 当窗体关闭时，取消对锁定状态变化的订阅

## 测试场景

1. **打开同一单据的多个窗体**：
   - 在一个窗体中锁定单据，其他窗体应及时更新锁定状态
   - 其他窗体点击关键操作按钮时，应显示状态栏提示

2. **不同用户打开同一单据**：
   - 用户A锁定单据后，用户B点击关键操作按钮应显示状态栏提示
   - 用户B无法执行实际操作

3. **锁定和解锁操作**：
   - 执行锁定操作后，状态栏应显示"成功锁定单据[单据编号]"
   - 执行解锁操作后，状态栏应显示"成功解锁单据[单据编号]"

4. **关键操作按钮处理**：
   - 当单据被锁定时，点击新增、修改、保存、提交、审核等按钮，只显示状态栏提示，不执行实际操作
