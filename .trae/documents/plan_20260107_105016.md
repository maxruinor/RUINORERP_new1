## 问题分析

1. **光标锁定问题**：在 `UCBuyingRequisition.cs` 中，当光标落入引用单据对应的文本框后，点击其他区域时光标被锁定，无法移动到其他输入框。

2. **数据类型校验机制**：问题是由于引用单据绑定的数据类型校验机制导致的。具体来说，当引用单据绑定的是ID（long类型），但显示的内容是编号（string类型）时，数据类型校验机制会导致光标锁定。

3. **销售出库单的解决方案**：在 `UCSaleOut.cs` 中，销售出库单引用销售订单时，使用了 `DataBindingHelper.BindData4TextBox` 方法绑定销售订单编号，并使用 `ControlBindingHelper.ConfigureControlFilter` 方法配置了控件过滤，这种方式避免了光标锁定问题。

## 修复计划

### 1. 修复请购单的引用单据绑定

**修改文件**：`UCBuyingRequisition.cs`

**修改内容**：
- 在 `BindData` 方法中，修改引用单据的绑定方式，参考销售出库单的实现
- 使用 `DataBindingHelper.BindData4TextBox` 方法绑定引用单据编号，而不是直接绑定ID
- 使用 `ControlBindingHelper.ConfigureControlFilter` 方法配置控件过滤

### 2. 修复具体代码

**修改点1**：在 `BindData` 方法中，修改引用单据的绑定逻辑

**修改前代码**：
```csharp
//先绑定这个。InitFilterForControl 这个才生效
DataBindingHelper.BindData4TextBox<tb_BuyingRequisition>(entity, v => v.RefBillNO, txtRefBillID, BindDataType4TextBox.Text, true);
DataBindingHelper.BindData4TextBoxWithTagQuery<tb_BuyingRequisition>(entity, v => v.RefBillID, txtRefBillID, true);

//创建表达式  草稿 结案 和没有提交的都不显示
var lambdaOrder = Expressionable.Create<tb_PurOrder>()
                .And(t => t.DataStatus == (int)DataStatus.确认)
                 .And(t => t.isdeleted == false)
                 .AndIF(AuthorizeController.GetPurBizLimitedAuth(MainForm.Instance.AppContext) && !MainForm.Instance.AppContext.IsSuperUser, t => t.Employee_ID == MainForm.Instance.AppContext.CurUserInfo.UserInfo.Employee_ID)//限制了销售只看到自己的客户,采购不限制
                .ToExpression();//注意 这一句 不能少

BaseProcessor basePro = Startup.GetFromFacByName<BaseProcessor>(typeof(tb_BuyingRequisition).Name + "Processor");
QueryFilter queryFilter = basePro.GetQueryFilter();

queryFilter.FilterLimitExpressions.Add(lambdaOrder);//意思是只有审核确认的。没有结案的。才能查询出来。

DataBindingHelper.InitFilterForControlByExp<tb_BuyingRequisition>(entity, txtRefBillID, c => c.RefBillNO, queryFilter);
```

**修改后代码**：
```csharp
//先绑定这个。ControlBindingHelper.ConfigureControlFilter 这个才生效
DataBindingHelper.BindData4TextBox<tb_BuyingRequisition>(entity, v => v.RefBillNO, txtRefBillID, BindDataType4TextBox.Text, true);

//创建表达式  草稿 结案 和没有提交的都不显示
var lambdaOrder = Expressionable.Create<tb_PurOrder>()
                .And(t => t.DataStatus == (int)DataStatus.确认)
                 .And(t => t.isdeleted == false)
                 .AndIF(AuthorizeController.GetPurBizLimitedAuth(MainForm.Instance.AppContext) && !MainForm.Instance.AppContext.IsSuperUser, t => t.Employee_ID == MainForm.Instance.AppContext.CurUserInfo.UserInfo.Employee_ID)//限制了销售只看到自己的客户,采购不限制
                .ToExpression();//注意 这一句 不能少

BaseProcessor basePro = Startup.GetFromFacByName<BaseProcessor>(typeof(tb_BuyingRequisition).Name + "Processor");
QueryFilter queryFilter = basePro.GetQueryFilter();

queryFilter.FilterLimitExpressions.Add(lambdaOrder);//意思是只有审核确认的。没有结案的。才能查询出来。

// 使用ControlBindingHelper.ConfigureControlFilter配置控件过滤，避免光标锁定问题
ControlBindingHelper.ConfigureControlFilter<tb_BuyingRequisition, tb_PurOrder>(entity, txtRefBillID, t => t.RefBillNO,
    f => f.PurOrderNo, queryFilter, a => a.RefBillID, b => b.PurOrder_ID, null, false);
```

### 3. 检查其他类似功能

**修改内容**：
- 检查整个客户端项目中是否还有类似的情况，即加载数据后引用的单据绑定的是ID（long），显示的内容是编号（string）
- 修复所有类似的光标锁定问题

### 4. 测试验证

**测试内容**：
- 验证双击请购单编号能够正常打开请购单窗体并正确加载数据
- 验证光标能够在各输入框间正常切换，不会被锁定
- 验证数据类型校验的正确性

## 预期效果

修复后，从请购单查询列表双击请购单编号时，能够正常打开请购单窗体并正确加载数据，光标能够在各输入框间正常切换，不会被锁定，同时保持数据类型校验的正确性。