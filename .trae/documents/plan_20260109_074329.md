# 提醒对象链路配置模块设计方案

## 1. 系统架构与设计思路

### 1.1 设计目标

基于现有提醒规则系统，扩展实现"谁的什么单据在什么状态下会提醒给谁"的完整链路配置，实现提醒规则的精细化管理和自动化执行。

### 1.2 核心概念

* **提醒源对象**："谁的" - 规则的触发者范围ActionType

* **单据类型**："什么单据" - 适用的业务单据类型

* **单据状态**："什么状态下" - 触发提醒的单据状态

* **提醒目标对象**："提醒给谁" - 规则的接收者范围

* **提醒操作类型**：触发提醒的具体操作

### 1.3 技术架构

* 基于现有 `BaseListGeneric` 和 `BaseEditGeneric` 框架开发

* 采用雪花ID作为主键

* 与现有提醒规则系统无缝集成

* 支持与服务器消息处理和客户端IM系统对接

## 2. 数据库设计

### 2.1 提醒对象链路主表 `tb_ReminderObjectLink`

| 字段名          | 数据类型          | 说明     | 约束                  |
| ------------ | ------------- | ------ | ------------------- |
| LinkId       | bigint        | 链路ID   | 主键，雪花ID             |
| LinkName     | nvarchar(100) | 链路名称   | 非空                  |
| Description  | nvarchar(500) | 链路描述   | 可空                  |
| SourceType   | int           | 提醒源类型  | 非空（1：角色，2：人员，3：部门）  |
| SourceValue  | bigint        | 提醒源值   | 非空，关联对应表ID          |
| BizType      | int           | 单据类型   | 非空，关联 `BizType` 枚举  |
| BillStatus   | int           | 单据状态   | 非空，单据的触发状态          |
| ActionType   | int           | 操作类型   | 非空，触发提醒的操作          |
| TargetType   | int           | 提醒目标类型 | 非空（1：角色，2：人员，3：部门）  |
| TargetValue  | bigint        | 提醒目标值  | 非空，关联对应表ID          |
| IsEnabled    | bit           | 是否启用   | 非空，默认1              |
| CreateUserId | bigint        | 创建人ID  | 非空，关联 `tb_UserInfo` |
| CreateTime   | datetime      | 创建时间   | 非空，默认当前时间           |
| UpdateUserId | bigint        | 更新人ID  | 可空，关联 `tb_UserInfo` |
| UpdateTime   | datetime      | 更新时间   | 可空                  |

### 2.2 链路与规则关联表 `tb_ReminderLinkRuleRelation`

| 字段名        | 数据类型     | 说明   | 约束                              |
| ---------- | -------- | ---- | ------------------------------- |
| RelationId | bigint   | 关联ID | 主键，雪花ID                         |
| LinkId     | bigint   | 链路ID | 非空，外键关联 `tb_ReminderObjectLink` |
| RuleId     | bigint   | 规则ID | 非空，外键关联 `tb_ReminderRule`       |
| CreateTime | datetime | 创建时间 | 非空，默认当前时间                       |

## 3. 模型层设计

### 3.1 提醒对象链路实体 `tb_ReminderObjectLink`

```csharp
[Serializable()]
[Description("提醒对象链路")]
[SugarTable("tb_ReminderObjectLink")]
public partial class tb_ReminderObjectLink : BaseEntity, ICloneable
{
    // 基本属性（对应数据库表字段）
    public long LinkId { get; set; }
    public string LinkName { get; set; }
    public string Description { get; set; }
    public int SourceType { get; set; }
    public long SourceValue { get; set; }
    public int BizType { get; set; }
    public int BillStatus { get; set; }
    public int ActionType { get; set; }
    public int TargetType { get; set; }
    public long TargetValue { get; set; }
    public bool IsEnabled { get; set; }
    public long CreateUserId { get; set; }
    public DateTime CreateTime { get; set; }
    public long? UpdateUserId { get; set; }
    public DateTime? UpdateTime { get; set; }

    // 扩展属性
    [SugarColumn(IsIgnore = true)]
    [Navigate(NavigateType.OneToMany, nameof(tb_ReminderLinkRuleRelation.LinkId))]
    public virtual List<tb_ReminderLinkRuleRelation> RuleRelations { get; set; }
}
```

### 3.2 链路与规则关联实体 `tb_ReminderLinkRuleRelation`

```csharp
[Serializable()]
[Description("提醒链路规则关联")]
[SugarTable("tb_ReminderLinkRuleRelation")]
public partial class tb_ReminderLinkRuleRelation : BaseEntity, ICloneable
{
    public long RelationId { get; set; }
    public long LinkId { get; set; }
    public long RuleId { get; set; }
    public DateTime CreateTime { get; set; }

    // 扩展属性
    [SugarColumn(IsIgnore = true)]
    [Navigate(NavigateType.OneToOne, nameof(LinkId))]
    public virtual tb_ReminderObjectLink Link { get; set; }

    [SugarColumn(IsIgnore = true)]
    [Navigate(NavigateType.OneToOne, nameof(RuleId))]
    public virtual tb_ReminderRule Rule { get; set; }
}
```

## 4. UI层设计

### 4.1 提醒对象链路列表 `UCReminderObjectLinkList`

* **继承**：`BaseListGeneric<tb_ReminderObjectLink>`

* **功能**：

  * 链路的新增、编辑、删除、查询

  * 支持按链路名称、单据类型、状态等过滤

  * 显示链路的核心信息（名称、描述、单据类型、状态、是否启用等）

  * 集成到现有菜单体系

### 4.2 提醒对象链路编辑 `UCReminderObjectLinkEdit`

* **继承**：`BaseEditGeneric<tb_ReminderObjectLink>`

* **布局**：选项卡式布局，分为基本信息、提醒源配置、单据配置、提醒目标配置

* **核心功能**：

  * **基本信息**：链路名称、描述、是否启用

  * **提醒源配置**：选择提醒源类型（角色/人员/部门）和具体值

  * **单据配置**：选择单据类型、单据状态、操作类型

  * **提醒目标配置**：选择提醒目标类型（角色/人员/部门）和具体值

  * 提供保存、取消、测试功能

### 4.3 界面风格

* 使用现有 Krypton Toolkit 控件

* 保持与现有 `UCReminderRuleEdit` 一致的UI风格

* 支持键盘快捷键和上下文菜单

* 提供详细的操作提示和验证

## 5. 业务逻辑设计

### 5.1 链路管理服务 `ReminderObjectLinkService`

* 提供链路的增删改查功能

* 实现链路与规则的关联管理

* 提供链路的启用/禁用功能

* 实现链路的验证和测试功能

### 5.2 链路规则引擎 `ReminderObjectLinkEngine`

* 根据单据信息和操作类型匹配链路规则

* 确定提醒源和提醒目标

* 生成提醒消息并传递给现有提醒服务

### 5.3 与现有系统集成

#### 5.3.1 服务器端集成

在 `MessageCommandHandler` 中添加链路规则判断：

```csharp
// 处理发送任务状态通知命令
private async Task<ResponseBase> HandleSendTodoNotificationAsync(
    MessageRequest request, CommandContext executionContext, CancellationToken cancellationToken)
{
    try
    {
        // 提取业务数据
        if (request.Data is MessageData messageData && messageData.BizData is TodoUpdate update)
        {
            // 使用链路规则引擎获取通知目标
            var linkEngine = new ReminderObjectLinkEngine(_dbContext);
            var recipients = await linkEngine.GetNotificationRecipientsAsync(
                update.BizType, update.UpdateType, update.CurrentStatus, update.CreatedBy);
            
            if (recipients.Any())
            {
                // 广播任务状态更新给相关用户
                await _TodoNotificationService.NotifyTodoChangeAsync(update, messageData, recipients);
            }

            return MessageResponse.Success(request.CommandType, "任务状态通知处理成功");
        }
        else
        {
            return MessageResponse.Fail(request.CommandType, "任务状态通知数据格式错误");
        }
    }
    catch (Exception ex)
    {
        _logger?.LogError(ex, "处理任务状态通知命令时出错");
        return MessageResponse.Fail(request.CommandType, $"处理任务状态通知失败: {ex.Message}");
    }
}
```

#### 5.3.2 客户端集成

在 `EnhancedMessageManager` 中添加链路规则判断：

```csharp
// 处理提醒消息
private void ProcessReminderMessage(MessageData message)
{
    try
    {
        // 使用链路规则引擎判断当前用户是否需要接收该提醒
        var linkEngine = new ReminderObjectLinkEngine();
        var shouldReceive = linkEngine.ShouldReceiveNotification(
            message.BizType, message.MessageType, message.ActionType, MainForm.Instance.AppContext.CurUserInfo.UserInfo.User_ID);
        
        if (shouldReceive)
        {
            // 显示提醒
            ShowNotification(message);
        }
    }
    catch (Exception ex)
    {
        _logger?.LogError(ex, "处理提醒消息时出错");
    }
}
```

## 6. 实现步骤

1. **数据库设计与创建**

   * 创建提醒对象链路表 `tb_ReminderObjectLink`

   * 创建链路与规则关联表 `tb_ReminderLinkRuleRelation`

   * 创建必要的索引

2. **模型层实现**

   * 创建 `tb_ReminderObjectLink` 实体类

   * 创建 `tb_ReminderLinkRuleRelation` 实体类

   * 实现实体类之间的关联关系

3. **业务层实现**

   * 实现 `ReminderObjectLinkService`

   * 实现 `ReminderObjectLinkEngine`

   * 与现有提醒规则系统集成

4. **UI层实现**

   * 创建 `UCReminderObjectLinkList` 列表控件

   * 创建 `UCReminderObjectLinkEdit` 编辑控件

   * 集成到现有菜单体系

5. **集成实现**

   * 与服务器消息处理集成

   * 与客户端IM系统集成

   * 与现有提醒规则集成

6. **测试与优化**

   * 测试链路配置功能

   * 测试链路规则引擎的准确性和性能

   * 优化界面交互和性能

## 7. 预期效果

* 实现完整的"谁的什么单据在什么状态下会提醒给谁"链路配置

* 与现有提醒规则系统无缝集成

* 支持与服务器消息处理和客户端IM系统对接

* 提供灵活、强大的提醒规则配置能力

* 保持与现有系统一致的UI风格和用户体验

## 8. 后续扩展

* 支持链路规则的导入/导出

* 支持链路规则的版本管理

* 支持链路规则的统计和分析

* 支持更复杂的链路条件表达式

* 支持链路规则的批量操作

该设计方案充分考虑了现有系统的架构和风格，确保新功能能够无缝集成到现有系统中，同时提供灵活、强大的提醒对象链路配置能力。
