### 问题分析
**异常原因**：
- SqlSugar在映射数据时，调用`SetProperty`方法设置实体属性值
- `SetProperty`方法的`CallerMemberName`参数在反射调用时为`null`
- 当`propertyName`为`null`时，`_changedProperties.TryGetValue`方法抛出异常
- 这导致SqlSugar无法正确绑定`Created_by`属性

**错误信息**：
- 中文：`Created_by绑定到tb_MenuInfo失败,可以试着换一个类型，或者使用ORM自定义类型实现`
- 英文：`tb_MenuInfo Created_by bind error`

### 解决方案
我将修复`SetProperty`方法，确保它在`propertyName`为`null`时能够正常工作：

1. **修改BaseEntity.SetProperty方法**：
   - 检查`propertyName`是否为`null`
   - 如果为`null`，跳过变更记录逻辑
   - 或者，从表达式中获取属性名称

2. **实现步骤**：
   - 修改`SetProperty`方法，添加对`propertyName`的空值检查
   - 确保在反射调用时不会抛出异常
   - 保持原有功能不变

### 预期效果
- ✅ 解决`Created_by`属性绑定失败问题
- ✅ 确保SqlSugar能够正常映射实体属性
- ✅ 保持实体类的变更追踪功能
- ✅ 提高系统的稳定性和可靠性

### 代码变更清单
1. **RUINORERP.Model\Base\BaseEntity.cs**：修改`SetProperty`方法，添加对`propertyName`的空值检查

### 实现代码
```csharp
protected void SetProperty<T>(ref T storage, T value, [CallerMemberName] String propertyName = null)
{
    // 简化为单次高效比较
    if (EqualityComparer<T>.Default.Equals(storage, value))
        return;

    T oldValue = storage;
    storage = value;
    
    // 简化变更记录逻辑，添加propertyName空值检查
    if (!string.IsNullOrEmpty(propertyName))
    {
        if (_changedProperties.TryGetValue(propertyName, out var record))
        {
            record.CurrentValue = value;
            // 若值变回原始值，移除变更记录
            if (object.Equals(record.OriginalValue, value))
            {
                _changedProperties.TryRemove(propertyName, out _);
            }
        }
        else if (!object.Equals(oldValue, value)) // 首次变更需检查有效性
        {
            _changedProperties[propertyName] = new PropertyChangeRecord(originalValue: oldValue, currentValue: value);
        }
    }

    HasChanged = true;

    // 合并通知事件，添加propertyName空值检查
    if (!string.IsNullOrEmpty(propertyName))
    {
        OnPropertyChanged(propertyName, oldValue, value);
    }
}
```

这个修复方案将确保`SetProperty`方法在`propertyName`为`null`时能够正常工作，避免SqlSugar在映射实体属性时抛出异常。