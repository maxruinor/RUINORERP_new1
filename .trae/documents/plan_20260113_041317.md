### 问题分析
当前ServerGlobalConfig的配置更新机制存在问题，导致配置文件变更时，`Startup.GetFromFac<ServerGlobalConfig>()`无法获取到最新值，而`IOptionsMonitor<ServerGlobalConfig>`可以正常获取。

**根本原因**：
- 在Startup.cs的单例注册中，OnChange事件中的`serverConfig = newConfig;`只会更新闭包中的局部变量
- 容器中已经保存了最初返回的实例引用，局部变量的变更不会影响到容器中的实例

### 修复方案

#### 1. 修改ServerGlobalConfig注册方式
**文件**：`RUINORERP.Server\Startup.cs`
**修改内容**：
- 将直接替换实例引用改为更新实例属性
- 或者使用引用类型包装最新实例

#### 2. 实现细节
**方案一：更新实例属性（推荐）**
```csharp
services.AddSingleton<ServerGlobalConfig>(provider =>
{
    var monitor = provider.GetRequiredService<IOptionsMonitor<ServerGlobalConfig>>();
    var serverConfig = monitor.CurrentValue;
    
    // 解析环境变量
    if (!string.IsNullOrEmpty(serverConfig.FileStoragePath))
    {
        serverConfig.FileStoragePath = Environment.ExpandEnvironmentVariables(serverConfig.FileStoragePath);
    }
    
    // 订阅配置变更事件，更新实例属性而非替换引用
    monitor.OnChange(newConfig =>
    {
        // 解析新配置的环境变量
        if (!string.IsNullOrEmpty(newConfig.FileStoragePath))
        {
            newConfig.FileStoragePath = Environment.ExpandEnvironmentVariables(newConfig.FileStoragePath);
        }
        
        // 使用反射更新实例属性
        foreach (var property in typeof(ServerGlobalConfig).GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            if (property.CanWrite)
            {
                var newValue = property.GetValue(newConfig);
                property.SetValue(serverConfig, newValue);
            }
        }
    });
    
    return serverConfig;
});
```

**方案二：使用包装类**
```csharp
// 创建一个配置包装类
public class ConfigWrapper<T> where T : class
{
    public T CurrentValue { get; set; }
}

// 在Startup.cs中注册
services.AddSingleton<ConfigWrapper<ServerGlobalConfig>>();
services.AddSingleton<ServerGlobalConfig>(provider =>
{
    var monitor = provider.GetRequiredService<IOptionsMonitor<ServerGlobalConfig>>();
    var wrapper = provider.GetRequiredService<ConfigWrapper<ServerGlobalConfig>>();
    
    wrapper.CurrentValue = monitor.CurrentValue;
    
    // 解析环境变量
    if (!string.IsNullOrEmpty(wrapper.CurrentValue.FileStoragePath))
    {
        wrapper.CurrentValue.FileStoragePath = Environment.ExpandEnvironmentVariables(wrapper.CurrentValue.FileStoragePath);
    }
    
    monitor.OnChange(newConfig =>
    {
        // 解析新配置的环境变量
        if (!string.IsNullOrEmpty(newConfig.FileStoragePath))
        {
            newConfig.FileStoragePath = Environment.ExpandEnvironmentVariables(newConfig.FileStoragePath);
        }
        
        wrapper.CurrentValue = newConfig;
    });
    
    return wrapper.CurrentValue;
});
```

### 3. 应用范围
需要对所有配置类型（ServerGlobalConfig、SystemGlobalConfig、GlobalValidatorConfig）应用相同的修复方案，确保它们都能正确响应配置变更。

### 4. 预期效果
- 配置文件变更时，OnChange事件能正确更新单例实例
- `Startup.GetFromFac<ServerGlobalConfig>()`能获取到最新配置值
- `IOptionsMonitor<ServerGlobalConfig>`仍然能正常获取最新值
- 三种配置类型都能正确响应配置变更

### 5. 修复优先级
- 高优先级：ServerGlobalConfig（已发现问题）
- 中优先级：SystemGlobalConfig、GlobalValidatorConfig（需要预防性修复）