# 统一防重复操作和防抖机制设计方案

## 设计思路
1. 创建一个中央服务类`RepeatOperationGuardService`，负责处理所有客户端的防重复操作判断
2. 使用短期缓存（如ConcurrentDictionary）存储最近的操作记录
3. 基于`MenuItemEnums`枚举值进行防重复判断
4. 支持配置不同操作类型的防抖时间间隔
5. 提供简单的API，方便在各种基类中调用

## 实现方案

### 1. 创建防重复操作服务类
- 创建`RepeatOperationGuardService`类，包含防重复操作的核心逻辑
- 使用`ConcurrentDictionary`存储最近的操作记录
- 实现`ShouldBlockOperation`方法，用于判断是否应该阻止操作
- 实现`RecordOperation`方法，用于记录操作

### 2. 修改基类，集成防重复操作服务
- 在`BaseUControl`、`BaseQuery`等基类中注入`RepeatOperationGuardService`
- 在`DoButtonClick`方法中添加防重复判断
- 只有通过防重复判断的操作才会继续执行

### 3. 配置不同操作类型的防抖时间间隔
- 支持为不同`MenuItemEnums`配置不同的防抖时间间隔
- 提供默认配置，同时支持自定义配置

### 4. 实现自动清理机制
- 定期清理过期的操作记录，避免内存泄漏
- 使用弱引用或其他机制确保资源被及时释放

## 实现步骤

1. 创建`RepeatOperationGuardService`类
2. 在`Startup`中注册为单例服务
3. 修改基类，注入并使用`RepeatOperationGuardService`
4. 在`DoButtonClick`方法中添加防重复判断
5. 测试并调整配置选项
6. 验证所有基类都能自动获得防重复操作和防抖机制

## 代码结构
```
- RepeatOperationGuardService.cs - 防重复操作服务类
- BaseUControl.cs - 修改，注入并使用防重复操作服务
- BaseQuery.cs - 修改，注入并使用防重复操作服务
- Startup.cs - 注册防重复操作服务为单例
```

## 预期效果
1. 所有客户端基类通过简单的API调用即可获得防重复操作和防抖机制
2. 无需在每个动作中添加重复的防重复判断代码
3. 基于`MenuItemEnums`枚举值，兼容所有操作类型
4. 提供统一的配置和管理方式
5. 减少重复代码，提高代码质量
6. 支持不同操作类型的防抖时间间隔配置
7. 实现自动清理机制，避免内存泄漏