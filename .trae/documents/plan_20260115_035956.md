# 调拨单批量处理优化方案

## 1. 问题分析

### 1.1 当前实现问题

**审核方法（ApprovalAsync）**：
- 已使用批量更新，但可以进一步优化
- 已有`invUpdateListFrom`和`invUpdateListTo`列表
- 已实现批量更新库存
- 已实现批量记录库存流水

**反审核方法（AntiApprovalAsync）**：
- 未使用批量更新，逐个调用`SaveOrUpdate`
- 导致性能较差
- 与审核方法实现不一致

### 1.2 优化目标

1. 统一审核和反审核的实现方式
2. 全部使用批量更新，提高效率
3. 优化代码结构，提高可维护性
4. 确保事务完整性
5. 优化库存流水记录

## 2. 优化方案

### 2.1 反审核方法优化

1. **添加批量更新列表**：
   - `invUpdateListFrom`：用于存放需要更新的调出仓库库存
   - `invUpdateListTo`：用于存放需要更新的调入仓库库存

2. **修改更新逻辑**：
   - 将更新后的库存实体添加到对应列表
   - 移除逐个调用`SaveOrUpdate`的逻辑

3. **批量更新**：
   - 使用`Updateable`批量更新调出仓库库存
   - 使用`Updateable`批量更新调入仓库库存
   - 明确指定要更新的字段

4. **批量记录库存流水**：
   - 保持现有逻辑，在所有库存更新完成后批量记录

### 2.2 审核方法优化

1. **优化代码结构**：
   - 调整代码顺序，使逻辑更清晰
   - 统一变量命名

2. **保持现有批量更新逻辑**：
   - 继续使用`invUpdateListFrom`和`invUpdateListTo`
   - 继续使用批量更新库存
   - 继续使用批量记录库存流水

## 3. 具体修改步骤

### 3.1 修改反审核方法（AntiApprovalAsync）

1. **添加批量更新列表**：
   ```csharp
   List<tb_Inventory> invUpdateListFrom = new List<tb_Inventory>();
   List<tb_Inventory> invUpdateListTo = new List<tb_Inventory>();
   ```

2. **修改调出仓库处理逻辑**：
   - 移除`SaveOrUpdate`调用
   - 将`invFrom`添加到`invUpdateListFrom`

3. **修改调入仓库处理逻辑**：
   - 移除`SaveOrUpdate`调用
   - 将`invTo`添加到`invUpdateListTo`

4. **添加批量更新代码**：
   ```csharp
   // 批量更新调出仓库库存
   int InvUpdateCounterFrom = await _unitOfWorkManage.GetDbClient().Updateable(invUpdateListFrom)
       .UpdateColumns(it => new { it.Quantity, it.Inv_SubtotalCostMoney, it.LatestStorageTime })
       .ExecuteCommandAsync();
   if (InvUpdateCounterFrom == 0)
   {
       _unitOfWorkManage.RollbackTran();
       throw new Exception("调出仓库库存更新失败！");
   }

   // 批量更新调入仓库库存
   int InvUpdateCounterTo = await _unitOfWorkManage.GetDbClient().Updateable(invUpdateListTo)
       .UpdateColumns(it => new { it.Quantity, it.Inv_SubtotalCostMoney, it.LatestOutboundTime })
       .ExecuteCommandAsync();
   if (InvUpdateCounterTo == 0)
   {
       _unitOfWorkManage.RollbackTran();
       throw new Exception("调入仓库库存更新失败！");
   }
   ```

### 3.2 调整审核方法（ApprovalAsync）

1. **优化代码结构**：
   - 调整代码顺序，使逻辑更清晰
   - 统一变量命名

2. **保持现有批量更新逻辑**：
   - 继续使用`invUpdateListFrom`和`invUpdateListTo`
   - 继续使用批量更新库存
   - 继续使用批量记录库存流水

## 4. 预期效果

1. **性能提升**：
   - 批量更新比逐个更新更高效
   - 减少数据库连接次数
   - 提高处理速度

2. **代码一致性**：
   - 审核和反审核方法实现方式统一
   - 提高代码可维护性
   - 便于后续扩展和修改

3. **事务完整性**：
   - 所有操作仍在同一事务内完成
   - 确保数据一致性

4. **逻辑清晰**：
   - 代码结构更清晰
   - 便于理解和维护

## 5. 技术实现要点

### 5.1 批量更新实现

使用ORM框架的批量更新功能：
```csharp
db.Updateable(list)
  .UpdateColumns(it => new { it.Field1, it.Field2 })
  .ExecuteCommandAsync();
```

### 5.2 事务处理

确保所有操作在同一事务内完成：
```csharp
_unitOfWorkManage.BeginTran();
try
{
    // 批量更新操作
    
    _unitOfWorkManage.CommitTran();
}
catch (Exception ex)
{
    _unitOfWorkManage.RollbackTran();
    throw;
}
```

### 5.3 库存流水记录

在所有库存更新完成后，批量记录库存流水：
```csharp
// 批量记录库存流水
tb_InventoryTransactionController<tb_InventoryTransaction> tranController = _appContext.GetRequiredService<tb_InventoryTransactionController<tb_InventoryTransaction>>();
await tranController.BatchRecordTransactions(transactionList);
```

## 6. 测试要点

1. 测试审核调拨单：
   - 调出仓库数量减少
   - 调入仓库数量增加
   - 库存流水记录正确

2. 测试反审核调拨单：
   - 调出仓库数量增加
   - 调入仓库数量减少
   - 库存流水记录正确

3. 测试多明细调拨单：
   - 确保所有明细都正确处理
   - 确保所有仓库库存都正确更新
   - 确保所有库存流水都正确记录

4. 测试性能：
   - 对比优化前后的处理时间
   - 确保批量处理提高了效率

## 7. 风险评估

- **低风险**：修改仅涉及逻辑优化，不影响数据结构
- **向后兼容**：原有功能保持不变
- **易于回滚**：如出现问题，可快速恢复原有逻辑
- **性能提升**：批量处理比逐个处理更高效

该优化方案将显著提高调拨单处理的效率，同时提高代码的可维护性和一致性。