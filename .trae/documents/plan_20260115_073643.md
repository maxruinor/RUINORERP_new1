# 调拨单批量更新优化方案

## 1. 问题分析

当前调拨单处理逻辑中，审核和反审核方法都使用了两个独立的集合来更新库存：
- `invUpdateListFrom`：用于更新调出仓库库存
- `invUpdateListTo`：用于更新调入仓库库存

这两个集合最终都调用相同的批量更新方法，只是更新的仓库不同。由于它们的实体类型相同（都是 `tb_Inventory`），可以合并为一个集合，只执行一次批量更新。

## 2. 优化方案

### 2.1 合并库存更新集合

将 `invUpdateListFrom` 和 `invUpdateListTo` 合并为一个 `invUpdateList` 集合，用于存放所有需要更新的库存实体。

### 2.2 统一批量更新

只执行一次批量更新，将所有库存更新操作合并为一个数据库调用。

### 2.3 保持业务逻辑不变

合并集合后，保持原有业务逻辑不变，确保：
- 调出仓库库存正确减少/增加
- 调入仓库库存正确增加/减少
- 库存流水记录正确生成
- 事务完整性得到保证

## 3. 具体修改步骤

### 3.1 修改 `ApprovalAsync` 方法

1. **合并集合**：将 `invUpdateListFrom` 和 `invUpdateListTo` 合并为一个 `invUpdateList` 集合
2. **添加实体**：将所有需要更新的库存实体添加到 `invUpdateList` 集合
3. **统一更新**：只执行一次批量更新

### 3.2 修改 `AntiApprovalAsync` 方法

1. **合并集合**：将 `invUpdateListFrom` 和 `invUpdateListTo` 合并为一个 `invUpdateList` 集合
2. **添加实体**：将所有需要更新的库存实体添加到 `invUpdateList` 集合
3. **统一更新**：只执行一次批量更新

## 4. 预期效果

### 4.1 性能提升
- 减少一次数据库调用
- 降低网络开销
- 提高处理速度

### 4.2 代码简化
- 减少集合创建和管理
- 简化代码结构
- 提高可维护性

### 4.3 保持兼容性
- 原有业务逻辑保持不变
- 数据更新结果保持一致
- 事务完整性得到保证

## 5. 技术实现要点

### 5.1 合并集合示例

```csharp
// 创建统一的批量更新集合
List<tb_Inventory> invUpdateList = new List<tb_Inventory>();

// 添加调出仓库库存更新
invUpdateList.Add(invFrom);

// 添加调入仓库库存更新
invUpdateList.Add(invTo);

// 统一批量更新
int updateCount = await _unitOfWorkManage.GetDbClient().Updateable(invUpdateList)
    .UpdateColumns(it => new { it.Quantity, it.Inv_SubtotalCostMoney, it.LatestOutboundTime, it.LatestStorageTime })
    .ExecuteCommandAsync();
```

### 5.2 更新字段选择

由于合并后的集合包含不同类型的库存更新（调出和调入），需要确保更新所有可能的字段：
- `Quantity`：库存数量
- `Inv_SubtotalCostMoney`：库存总成本
- `LatestOutboundTime`：最近出库时间
- `LatestStorageTime`：最近入库时间

### 5.3 库存流水记录

库存流水记录仍需分别创建，因为流水记录包含不同的业务信息（调出和调入）。

## 6. 风险评估

- **低风险**：修改仅涉及集合合并和批量更新，不影响业务逻辑
- **向后兼容**：原有功能保持不变
- **易于回滚**：如出现问题，可快速恢复原有逻辑
- **性能提升**：减少数据库调用，提高处理效率

该优化方案将进一步提高调拨单处理的效率，同时简化代码结构，提高可维护性。