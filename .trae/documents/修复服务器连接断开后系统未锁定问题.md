# 修复服务器连接断开后系统未锁定问题

## 问题分析

通过对代码的全面审查，我发现了以下问题：

1. **心跳失败时未正确触发系统锁定**：在`ClientCommunicationService.cs`的`UpdateHeartbeatState`方法中，当心跳失败达到阈值时，只调用了`UpdateLockStatus(true)`更新UI显示，没有调用`LogLock()`方法来真正锁定系统
2. **系统锁定机制不完整**：虽然有心跳失败阈值检测，但触发锁定后没有实际执行系统级别的锁定操作
3. **重连机制存在缺陷**：重连失败后，系统状态没有正确更新

## 修复方案

### 1. 修复心跳失败时的系统锁定逻辑

**修改`ClientCommunicationService.cs`**：
- 在`UpdateHeartbeatState`方法中，当心跳失败达到阈值时，确保正确触发`HeartbeatFailureThresholdReached`事件
- 移除直接调用`MainForm.Instance.UpdateLockStatus(true)`的代码，确保事件机制正常工作

### 2. 完善重连失败时的系统锁定逻辑

**修改`ConnectionManager.cs`**：
- 确保重连失败时正确触发`ReconnectFailed`事件
- 完善重连失败后的状态更新

### 3. 增强系统锁定机制

**修改`MainForm.cs`**：
- 确保`OnHeartbeatFailureThresholdReached`方法正确调用`LogLock()`方法
- 完善`LogLock()`方法的异常处理

### 4. 优化连接状态监测

**修改`ClientCommunicationService.cs`**：
- 增强连接状态监测，确保及时发现连接断开
- 完善连接断开时的处理逻辑

## 代码修改点

### 1. 修改`ClientCommunicationService.cs`的`UpdateHeartbeatState`方法

**当前代码**：
```csharp
// 检查是否达到心跳失败阈值
if (currentFailures >= HEARTBEAT_FAILURE_THRESHOLD)
{
    _logger?.LogError("心跳失败达到阈值({Threshold})，触发锁定事件", HEARTBEAT_FAILURE_THRESHOLD);
    // 停止重连机制以避免资源浪费
    _connectionManager.StopAutoReconnect();
    // 停止心跳检测，因为系统已进入锁定状态
    StopHeartbeat();
    // 异步触发阈值事件
    Task.Run(() => HeartbeatFailureThresholdReached?.Invoke()).ConfigureAwait(false);
    
    // 确保MainForm进入锁定状态
    if (MainForm.Instance != null && !MainForm.Instance.IsLocked)
    {
        try
        {
            if (MainForm.Instance.InvokeRequired)
            {
                MainForm.Instance.BeginInvoke(new Action(() =>
                {
                    MainForm.Instance.UpdateLockStatus(true);
                }));
            }
            else
            {
                MainForm.Instance.UpdateLockStatus(true);
            }
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "更新MainForm锁定状态时发生异常");
        }
    }
}
```

**修改后**：
```csharp
// 检查是否达到心跳失败阈值
if (currentFailures >= HEARTBEAT_FAILURE_THRESHOLD)
{
    _logger?.LogError("心跳失败达到阈值({Threshold})，触发锁定事件", HEARTBEAT_FAILURE_THRESHOLD);
    // 停止重连机制以避免资源浪费
    _connectionManager.StopAutoReconnect();
    // 停止心跳检测，因为系统已进入锁定状态
    StopHeartbeat();
    // 异步触发阈值事件
    Task.Run(() => HeartbeatFailureThresholdReached?.Invoke()).ConfigureAwait(false);
    
    // 移除直接调用UpdateLockStatus的代码，确保通过事件机制触发完整的锁定逻辑
}
```

### 2. 修改`MainForm.cs`的`OnHeartbeatFailureThresholdReached`方法

**当前代码**：
```csharp
private void OnHeartbeatFailureThresholdReached()
{
    try
    {
        logger?.LogWarning("心跳失败达到阈值，检查当前登录和锁定状态");

        // 只有在已登录且未锁定状态下才进入锁定状态
        if (CurrentLoginStatus == LoginStatus.LoggedIn && !IsLocked)
        {
            logger?.LogWarning("当前为已登录且未锁定状态，自动进入注销锁定状态");

            // 在UI线程上执行注销操作
            if (InvokeRequired)
            {
                BeginInvoke(new Action(() =>
                {
                    // 更新锁定状态显示
                    UpdateLockStatus(true);
                    LogLock();
                }));
            }
            else
            {
                // 更新锁定状态显示
                UpdateLockStatus(true);
                LogLock();
            }
        }
        else
        {
            logger?.LogInformation($"当前状态不符合心跳锁定条件，登录状态: {CurrentLoginStatus}, 锁定状态: {IsLocked}");
        }
    }
    catch (Exception ex)
    {
        logger?.LogError(ex, "处理心跳失败阈值事件时发生异常");
    }
}
```

**修改后**：
```csharp
private void OnHeartbeatFailureThresholdReached()
{
    try
    {
        logger?.LogWarning("心跳失败达到阈值，检查当前登录和锁定状态");

        // 只有在已登录且未锁定状态下才进入锁定状态
        if (CurrentLoginStatus == LoginStatus.LoggedIn && !IsLocked)
        {
            logger?.LogWarning("当前为已登录且未锁定状态，自动进入注销锁定状态");

            // 在UI线程上执行注销操作
            if (InvokeRequired)
            {
                BeginInvoke(new Action(() =>
                {
                    // 直接调用LogLock()方法，它会自动更新锁定状态显示
                    LogLock();
                }));
            }
            else
            {
                // 直接调用LogLock()方法，它会自动更新锁定状态显示
                LogLock();
            }
        }
        else
        {
            logger?.LogInformation($"当前状态不符合心跳锁定条件，登录状态: {CurrentLoginStatus}, 锁定状态: {IsLocked}");
        }
    }
    catch (Exception ex)
    {
        logger?.LogError(ex, "处理心跳失败阈值事件时发生异常");
        // 异常情况下，确保系统进入锁定状态
        try
        {
            if (InvokeRequired)
            {
                BeginInvoke(new Action(() =>
                {
                    LogLock();
                }));
            }
            else
            {
                LogLock();
            }
        }
        catch (Exception ex2)
        {
            logger?.LogError(ex2, "异常情况下尝试锁定系统失败");
        }
    }
}
```

### 3. 修改`MainForm.cs`的`OnReconnectFailed`方法

**当前代码**：
```csharp
private void OnReconnectFailed()
{
    try
    {
        logger?.LogWarning("客户端重连失败，检查当前登录状态");

        // 只有在已登录状态下才进入锁定状态，避免登录失败后重复弹出登录窗口
        if (CurrentLoginStatus == LoginStatus.LoggedIn)
        {
            logger?.LogWarning("当前为已登录状态，自动进入注销锁定状态");

            // 在UI线程上执行注销操作
            if (InvokeRequired)
            {
                BeginInvoke(new Action(() =>
                {
                    // 更新锁定状态显示
                    UpdateLockStatus(true);
                    LogLock();
                }));
            }
            else
            {
                // 更新锁定状态显示
                UpdateLockStatus(true);
                LogLock();
            }
        }
        else
        {
            // 如果当前不是登录中状态且已连接，则断开连接
            if (CurrentLoginStatus != LoginStatus.LoggingIn && communicationService != null && communicationService.IsConnected)
            {
                if (InvokeRequired)
                {
                    BeginInvoke(new Action(async () =>
                    {
                        var disconnectResult = await communicationService.Disconnect();
                        logger?.LogInformation($"重连失败处理中断开连接结果: {disconnectResult}");
                    }));
                }
                else
                {
                    Task.Run(async () =>
                    {
                        var disconnectResult = await communicationService.Disconnect();
                        logger?.LogInformation($"重连失败处理中断开连接结果: {disconnectResult}");
                    });
                }
            }
        }
    }
    catch (Exception ex)
    {
        logger?.LogError(ex, "处理重连失败事件时发生异常");
    }
}
```

**修改后**：
```csharp
private void OnReconnectFailed()
{
    try
    {
        logger?.LogWarning("客户端重连失败，检查当前登录状态");

        // 只有在已登录状态下才进入锁定状态，避免登录失败后重复弹出登录窗口
        if (CurrentLoginStatus == LoginStatus.LoggedIn)
        {
            logger?.LogWarning("当前为已登录状态，自动进入注销锁定状态");

            // 在UI线程上执行注销操作
            if (InvokeRequired)
            {
                BeginInvoke(new Action(() =>
                {
                    // 直接调用LogLock()方法，它会自动更新锁定状态显示
                    LogLock();
                }));
            }
            else
            {
                // 直接调用LogLock()方法，它会自动更新锁定状态显示
                LogLock();
            }
        }
        else
        {
            // 如果当前不是登录中状态且已连接，则断开连接
            if (CurrentLoginStatus != LoginStatus.LoggingIn && communicationService != null && communicationService.IsConnected)
            {
                if (InvokeRequired)
                {
                    BeginInvoke(new Action(async () =>
                    {
                        var disconnectResult = await communicationService.Disconnect();
                        logger?.LogInformation($"重连失败处理中断开连接结果: {disconnectResult}");
                    }));
                }
                else
                {
                    Task.Run(async () =>
                    {
                        var disconnectResult = await communicationService.Disconnect();
                        logger?.LogInformation($"重连失败处理中断开连接结果: {disconnectResult}");
                    });
                }
            }
        }
    }
    catch (Exception ex)
    {
        logger?.LogError(ex, "处理重连失败事件时发生异常");
        // 异常情况下，确保系统进入锁定状态
        try
        {
            if (InvokeRequired)
            {
                BeginInvoke(new Action(() =>
                {
                    LogLock();
                }));
            }
            else
            {
                LogLock();
            }
        }
        catch (Exception ex2)
        {
            logger?.LogError(ex2, "异常情况下尝试锁定系统失败");
        }
    }
}
```

## 调试建议

1. **设置断点**：
   - 在`ClientCommunicationService.cs`的`UpdateHeartbeatState`方法中设置断点，查看心跳状态更新
   - 在`MainForm.cs`的`OnHeartbeatFailureThresholdReached`和`OnReconnectFailed`方法中设置断点，查看锁定逻辑
   - 在`MainForm.cs`的`LogLock`方法中设置断点，查看系统锁定的完整流程

2. **监控日志**：
   - 监控心跳失败和重连失败的日志
   - 查看系统锁定状态的变化
   - 检查事件触发和处理的日志

3. **测试场景**：
   - 手动断开网络，查看系统是否正确检测到并锁定
   - 模拟服务器关闭，查看系统是否正确处理
   - 测试连续多次心跳失败后的系统状态

## 预期效果

1. 当服务器连接断开时，心跳检测会正确检测到
2. 心跳失败达到阈值时，系统会触发锁定事件
3. 系统会正确调用`LogLock`方法，锁定系统并显示登录窗口
4. 重连失败时，系统会正确锁定并显示登录窗口
5. 登录成功后，系统会恢复正常状态

## 风险评估

1. 系统锁定机制的修改可能影响现有功能，需要仔细测试
2. 心跳检测和重连机制的修改可能导致系统连接不稳定
3. 事件触发机制的修改可能影响其他功能

## 实施计划

1. 首先修复`ClientCommunicationService.cs`的`UpdateHeartbeatState`方法
2. 然后修改`MainForm.cs`的`OnHeartbeatFailureThresholdReached`方法
3. 接着修改`MainForm.cs`的`OnReconnectFailed`方法
4. 全面测试各个功能，确保修复不会影响现有功能
5. 进行压力测试，确保系统在高负载下仍然稳定

通过以上修改，我们可以确保系统在服务器连接断开后能够正确锁定，并显示登录窗口，防止用户继续操作。