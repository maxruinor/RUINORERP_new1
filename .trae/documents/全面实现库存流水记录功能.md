# 全面实现库存流水记录功能（含实时成本获取）

## 1. 业务场景分析

通过分析代码库，我识别出以下与库存及成本变化相关的业务场景：

### 1.1 出库业务
- 销售出库 (`tb_SaleOutControllerPartial.cs`)
- 库存出库 (`tb_StockOutControllerPartial.cs`)
- 生产领料 (`tb_MaterialRequisitionControllerPartial.cs`)
- 其他出库相关业务

### 1.2 入库业务
- 采购入库 (`tb_PurEntryControllerPartial.cs`)
- 库存入库 (`tb_StockInControllerPartial.cs`)
- 生产退料 (`tb_MaterialReturnControllerPartial.cs`)
- 销售退货 (`tb_SaleOutReControllerPartial.cs`)
- 采购退货 (`tb_PurReturnEntryControllerPartial.cs`)
- 其他入库相关业务

## 2. 现有实现分析

### 2.1 已实现库存流水记录的业务
- 销售出库审核 (`tb_SaleOutControllerPartial.cs:ApprovalAsync`)

### 2.2 未实现库存流水记录的业务
- 销售出库反审
- 采购入库审核和反审
- 库存入库审核和反审
- 库存出库审核和反审
- 生产领料审核和反审
- 生产退料审核和反审
- 销售退货审核和反审
- 采购退货审核和反审

### 2.3 成本获取问题
- 部分出库业务可能从其他订单中获取成本，而非实时获取当前库存成本
- 这会导致成本数据不准确，影响库存流水记录的真实性

## 3. 实现计划

### 3.1 通用实现模式

对于所有出入库业务，我将遵循以下实现模式：

1. **审核通过时**：
   - **实时获取当前库存成本**：优先使用当前库存的实时成本，而非从其他订单传递的成本
   - 记录库存流水到 `tb_InventoryTransaction` 表
   - 对于出库业务，数量为负数；对于入库业务，数量为正数

2. **反审核时**：
   - 记录反向库存流水到 `tb_InventoryTransaction` 表
   - 对于出库业务，数量为正数（恢复库存）；对于入库业务，数量为负数（减少库存）

3. **库存流水记录内容**：
   - 产品ID (`ProdDetailID`)
   - 仓库ID (`Location_ID`)
   - 业务类型 (`BizType`)
   - 参考单据ID (`ReferenceId`)
   - 数量变化 (`QuantityChange`)
   - 变动后数量 (`AfterQuantity`)
   - 单位成本 (`UnitCost`)：实时获取的当前库存成本
   - 交易时间 (`TransactionTime`)
   - 操作人 (`OperatorId`)
   - 备注 (`Notes`)

### 3.2 具体实现步骤

#### 3.2.1 销售出库单 (`tb_SaleOutControllerPartial.cs`)
- **审核时**：已实现库存流水记录，确保成本为实时获取
- **反审核时**：添加库存流水记录，记录反向流水

#### 3.2.2 采购入库单 (`tb_PurEntryControllerPartial.cs`)
- **审核时**：
  - 实时获取当前库存成本
  - 添加库存流水记录
- **反审核时**：
  - 实时获取当前库存成本
  - 添加反向库存流水记录

#### 3.2.3 库存入库单 (`tb_StockInControllerPartial.cs`)
- **审核时**：
  - 实时获取当前库存成本
  - 添加库存流水记录
- **反审核时**：
  - 实时获取当前库存成本
  - 添加反向库存流水记录

#### 3.2.4 库存出库单 (`tb_StockOutControllerPartial.cs`)
- **审核时**：
  - 实时获取当前库存成本
  - 添加库存流水记录
- **反审核时**：
  - 实时获取当前库存成本
  - 添加反向库存流水记录

#### 3.2.5 生产领料单 (`tb_MaterialRequisitionControllerPartial.cs`)
- **审核时**：
  - 实时获取当前库存成本
  - 添加库存流水记录
- **反审核时**：
  - 实时获取当前库存成本
  - 添加反向库存流水记录

#### 3.2.6 生产退料单 (`tb_MaterialReturnControllerPartial.cs`)
- **审核时**：
  - 实时获取当前库存成本
  - 添加库存流水记录
- **反审核时**：
  - 实时获取当前库存成本
  - 添加反向库存流水记录

#### 3.2.7 销售退货单 (`tb_SaleOutReControllerPartial.cs`)
- **审核时**：
  - 实时获取当前库存成本
  - 添加库存流水记录
- **反审核时**：
  - 实时获取当前库存成本
  - 添加反向库存流水记录

#### 3.2.8 采购退货单 (`tb_PurReturnEntryControllerPartial.cs`)
- **审核时**：
  - 实时获取当前库存成本
  - 添加库存流水记录
- **反审核时**：
  - 实时获取当前库存成本
  - 添加反向库存流水记录

### 3.3 实时成本获取实现

对于所有出库业务，我将确保在审核过程中实时获取当前库存成本，具体实现方式如下：

```csharp
// 实时获取当前库存成本
var inv = await _unitOfWorkManage.GetDbClient().Queryable<tb_Inventory>()
    .Where(i => i.ProdDetailID == child.ProdDetailID && i.Location_ID == child.Location_ID)
    .FirstAsync();

// 使用实时成本更新明细成本
if (inv != null && inv.Inv_Cost > 0)
{
    child.Cost = inv.Inv_Cost;
    // 更新小计成本
    child.SubtotalCostAmount = child.Cost * child.Quantity;
}
```

### 3.4 技术实现要点

1. **实时成本优先**：在所有出库业务中，优先使用当前库存的实时成本，而非从其他订单传递的成本
2. **事务一致性**：确保库存更新、成本更新和库存流水记录在同一个事务中完成
3. **批量处理**：使用 `BatchRecordTransactions` 方法批量记录库存流水，提高性能
4. **业务类型枚举**：使用 `BizType` 枚举明确标识不同的业务类型
5. **反向流水记录**：反审核时记录反向流水，保持数据的完整性和可追溯性
6. **成本准确性验证**：在记录库存流水前，验证成本数据的准确性，确保不为0或负数（除非有特殊业务场景）

## 4. 预期效果

通过以上实现，将实现以下效果：

1. 所有出库行为都将记录实时成本和数量到 `tb_InventoryTransaction` 表
2. 所有入库行为都将记录实时成本和数量到 `tb_InventoryTransaction` 表
3. 出库成本采用实时获取方式，保证数据准确性
4. 覆盖所有出入库相关业务场景
5. 所有影响库存和成本的业务操作都能被准确、实时地记录
6. 解决了从其他订单中获取非实时成本导致的数据不准确问题

## 5. 代码实现示例

以下是库存出库单审核时的实时成本获取和库存流水记录实现示例：

```csharp
// 处理分组数据，更新库存记录的各字段
foreach (var group in inventoryGroups)
{
    var inv = group.Value.Inventory;
    // 记录原始库存数量，用于计算变化量
    int originalQty = inv.Quantity;
    decimal originalCost = inv.Inv_Cost;

    // 实时获取当前库存成本（确保成本准确性）
    decimal realtimeCost = inv.Inv_Cost;
    if (realtimeCost <= 0)
    {
        // 如果当前库存成本为0或负数，尝试从其他途径获取
        // 这里可以根据实际业务逻辑添加其他成本获取方式
        realtimeCost = await GetRealtimeCostAsync(inv.ProdDetailID, inv.Location_ID);
    }

    // 累加数值字段
    inv.Quantity -= group.Value.OutQtySum.ToInt();
    inv.LatestOutboundTime = System.DateTime.Now;
    // 计算衍生字段（如总成本）
    inv.Inv_SubtotalCostMoney = realtimeCost * inv.Quantity;
    invUpdateList.Add(inv);

    // 更新出库明细的成本为实时成本
    foreach (var detail in entity.tb_StockOutDetails)
    {
        if (detail.ProdDetailID == inv.ProdDetailID && detail.Location_ID == inv.Location_ID)
        {
            detail.Cost = realtimeCost;
            detail.SubtotalCostAmount = realtimeCost * detail.Quantity;
        }
    }

    // 创建库存流水记录
    tb_InventoryTransaction transaction = new tb_InventoryTransaction();
    transaction.ProdDetailID = inv.ProdDetailID;
    transaction.Location_ID = inv.Location_ID;
    transaction.BizType = (int)BizType.库存出库单;
    transaction.ReferenceId = entity.StockOut_MainID;
    transaction.QuantityChange = -group.Value.OutQtySum.ToInt(); // 库存出库减少库存
    transaction.AfterQuantity = inv.Quantity;
    transaction.UnitCost = realtimeCost; // 使用实时成本
    transaction.TransactionTime = DateTime.Now;
    transaction.OperatorId = _appContext.CurUserInfo.UserInfo.User_ID;
    transaction.Notes = $"库存出库单审核：{entity.BillNo}，产品：{inv.tb_proddetail.tb_prod.CNName}";

    transactionList.Add(transaction);
}

// 记录库存流水
tb_InventoryTransactionController<tb_InventoryTransaction> tranController = _appContext.GetRequiredService<tb_InventoryTransactionController<tb_InventoryTransaction>>();
await tranController.BatchRecordTransactions(transactionList);
```

## 6. 后续检查

实现完成后，我将进行以下检查：

1. 检查所有出入库相关业务的审核和反审方法是否都已添加库存流水记录
2. 检查所有出库业务是否都实时获取了当前库存成本
3. 检查库存流水记录的准确性和完整性
4. 检查事务处理是否正确，确保库存更新、成本更新和库存流水记录的一致性
5. 检查出库成本是否采用实时获取方式，而非从其他订单中获取
6. 检查所有业务场景是否都已覆盖

通过以上实现和检查，将确保系统中所有影响库存和成本的业务操作都能被准确、实时地记录到 `tb_InventoryTransaction` 表中，同时保证成本数据的准确性。