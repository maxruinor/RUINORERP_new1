# 完善保存按钮机制

## 问题分析
根据对四个窗体基类文件的分析，发现：
1. 没有实现保存按钮的防止重复点击机制
2. 没有实现数据变化时自动启用保存按钮的逻辑
3. 没有根据数据状态动态控制保存按钮的启用/禁用

## 解决方案
需要实现一个完整的保存按钮管理机制，包括：
1. **防止重复点击**：点击保存后立即禁用按钮，操作完成后恢复
2. **数据变化检测**：当实体数据变化时自动启用保存按钮
3. **状态依赖控制**：只有当数据状态允许修改时才启用保存按钮
4. **异常安全**：确保在任何情况下按钮状态都能正确管理

## 实现步骤

### 1. 分析现有代码结构
- 检查 `BaseEntity` 的 `HasChanged` 属性使用情况
- 检查 `StateManager` 中关于保存操作的权限判断
- 检查实体数据变化事件的订阅机制

### 2. 实现数据变化时自动启用保存按钮
- 在 `BoundEntity` 属性设置中添加数据变化检测
- 订阅实体的 `StatusChanged` 事件，当数据变化时检查是否允许保存
- 如果数据变化且状态允许保存，则启用保存按钮

### 3. 实现防止重复点击机制
- 在 `DoButtonClick` 方法的保存分支中添加按钮禁用逻辑
- 使用 `try-finally` 块确保无论保存结果如何，按钮都能恢复可用状态
- 确保与现有的锁定检查逻辑兼容

### 4. 实现基于状态的按钮启用控制
- 在 `UpdateAllUIStates` 方法中，根据当前状态判断是否允许保存
- 调用 `StateManager.CanExecuteAction` 检查保存操作是否允许
- 根据检查结果设置保存按钮的启用/禁用状态

### 5. 统一在基类中实现
- 在 `BaseBillEdit` 中实现核心逻辑
- 在 `BaseBillEditGeneric` 中重写或扩展逻辑以适应单据编辑场景

## 实现细节

### BaseBillEdit.cs 中的实现
1. **在 `BoundEntity` 属性中添加数据变化检测**
   ```csharp
   if (_boundEntity != null)
   {
       _boundEntity.StatusChanged -= OnEntityStatusChanged;
       _boundEntity.PropertyChanged -= OnEntityPropertyChanged;
   }
   _boundEntity = value;
   if (_boundEntity != null)
   {
       _boundEntity.StatusChanged += OnEntityStatusChanged;
       _boundEntity.PropertyChanged += OnEntityPropertyChanged;
   }
   ```

2. **实现 `OnEntityPropertyChanged` 方法**
   ```csharp
   private void OnEntityPropertyChanged(object sender, PropertyChangedEventArgs e)
   {
       if (sender is BaseEntity entity && entity.HasChanged)
       {
           UpdateSaveButtonState();
       }
   }
   ```

3. **实现 `UpdateSaveButtonState` 方法**
   ```csharp
   private void UpdateSaveButtonState()
   {
       bool canSave = false;
       if (EditEntity != null)
       {
           canSave = StateManager?.CanExecuteActionWithMessage(EditEntity, MenuItemEnums.保存).CanExecute ?? false;
       }
       
       // 查找保存按钮并更新状态
       var saveButton = FindToolStripButtonByName("toolStripButtonSave");
       if (saveButton != null)
       {
           saveButton.Enabled = canSave;
       }
   }
   ```

4. **修改 `DoButtonClick` 方法**
   ```csharp
   case MenuItemEnums.保存:
       // 防止重复点击：立即禁用保存按钮
       var saveButton = FindToolStripButtonByName("toolStripButtonSave");
       bool wasEnabled = saveButton?.Enabled ?? true;
       if (saveButton != null)
       {
           saveButton.Enabled = false;
       }
       
       try
       {
           // 保存操作是异步的
           _ = Save(true);
       }
       finally
       {
           // 确保按钮恢复可用状态
           if (saveButton != null)
           {
               saveButton.Enabled = wasEnabled;
               // 重新检查保存权限，确保状态正确
               UpdateSaveButtonState();
           }
       }
       break;
   ```

### BaseBillEditGeneric.cs 中的实现
1. **重写或扩展 `UpdateSaveButtonState` 方法**（如果需要）
2. **确保与现有的锁定检查逻辑兼容**
3. **在 `BindData` 方法中添加数据变化检测**

## 预期效果
1. **数据变化时**：当实体数据发生变化且状态允许保存时，保存按钮自动启用
2. **点击保存时**：按钮立即变为灰色不可点击状态，防止重复点击
3. **保存完成后**：无论成功或失败，按钮恢复为可点击状态
4. **状态变化时**：当数据状态改变时，自动检查并更新保存按钮的启用状态
5. **异常安全**：即使保存过程中发生异常，按钮也能恢复可用状态

## 测试要点
1. 测试数据变化时保存按钮是否自动启用
2. 测试不同数据状态下保存按钮的启用/禁用逻辑
3. 测试正常保存流程中按钮状态的变化
4. 测试保存失败时按钮状态的恢复
5. 测试保存过程中发生异常时按钮状态的恢复
6. 验证在不同类型的单据窗体中都能正常工作