# 完善基础信息列表中的复制性信息新增功能

## 实现方案

### 1. 在BaseListGeneric.cs中添加可忽略字段配置机制

1. **添加ConfigureIgnoreProperties虚方法**：
   - 在BaseListGeneric类中添加虚方法，允许子类重写以配置特定业务字段的忽略规则
   - 默认实现配置通用字段，如主键、创建时间、修改时间等

2. **添加重置相关方法**：
   - 添加ResetIgnoredProperties方法，用于重置配置的忽略字段
   - 添加ResetPrimaryKey方法，用于重置主键
   - 添加ResetApprovalStatus方法，用于重置审批状态（如果适用）

### 2. 完善AddByCopy方法

1. **修改AddByCopy方法**：
   - 在创建新实体后，获取忽略属性配置
   - 重置需要忽略的字段
   - 重置主键
   - 重置审批状态（如果适用）

2. **支持两种重置机制**：
   - 系统预设方式：通过ConfigureIgnoreProperties方法配置需要重置的字段
   - 用户交互方式：保持现有的UI交互方式，用户可以在窗体中修改字段值

### 3. 确保代码复用和一致性

1. **复用现有功能**：
   - 使用与BaseBillEditGeneric相同的IgnorePropertyConfiguration类
   - 实现类似的重置方法，确保功能一致性

2. **保持兼容性**：
   - 确保修改后的AddByCopy方法与现有的调用方式兼容
   - 保持对普通BaseEdit和泛型BaseEditGeneric的支持

## 具体修改步骤

### 步骤1：在BaseListGeneric.cs中添加ConfigureIgnoreProperties方法

```csharp
/// <summary>
/// 配置复制操作时需要忽略的属性
/// </summary>
/// <returns>忽略属性配置</returns>
protected virtual IgnorePropertyConfiguration ConfigureIgnoreProperties()
{
    var config = new IgnorePropertyConfiguration();

    // 使用字符串方式配置通用属性
    config.IgnoreIfExists<T>("DataStatus")
          .IgnoreIfExists<T>("PrimaryKeyID")
          .IgnoreIfExists<T>("Created_at")
          .IgnoreIfExists<T>("Created_by")
          .IgnoreIfExists<T>("Modified_at")
          .IgnoreIfExists<T>("Modified_by")
          .IgnoreIfExists<T>("ApprovalStatus")
          .IgnoreIfExists<T>("ApprovalResults")
          .IgnoreIfExists<T>("Approver_by")
          .IgnoreIfExists<T>("Approver_at")
          .IgnoreIfExists<T>("PrintStatus");

    return config;
}
```

### 步骤2：在BaseListGeneric.cs中添加重置相关方法

```csharp
/// <summary>
/// 重置需要忽略的属性
/// </summary>
/// <param name="entity">实体对象</param>
/// <param name="ignoreConfig">忽略属性配置</param>
private void ResetIgnoredProperties(object entity, IgnorePropertyConfiguration ignoreConfig)
{
    if (entity == null) return;

    var entityType = entity.GetType();
    var ignoredProperties = ignoreConfig.GetIgnoredProperties(entityType);

    foreach (var propName in ignoredProperties)
    {
        if (ReflectionHelper.ExistPropertyName(entityType, propName))
        {
            var prop = entityType.GetProperty(propName);
            if (prop != null && prop.CanWrite)
            {
                // 根据属性类型设置默认值
                if (prop.PropertyType == typeof(string))
                    prop.SetValue(entity, null);
                else if (prop.PropertyType == typeof(int))
                    prop.SetValue(entity, 0);
                else if (prop.PropertyType == typeof(long))
                    prop.SetValue(entity, 0L);
                else if (prop.PropertyType == typeof(decimal))
                    prop.SetValue(entity, 0m);
                else if (prop.PropertyType == typeof(DateTime))
                    prop.SetValue(entity, DateTime.MinValue);
                else if (prop.PropertyType == typeof(DateTime?))
                    prop.SetValue(entity, null);
                else if (prop.PropertyType == typeof(bool))
                    prop.SetValue(entity, false);
            }
        }
    }
}

/// <summary>
/// 重置实体的主键
/// </summary>
/// <param name="entity">实体对象</param>
/// <param name="pkCol">主键列名</param>
private void ResetPrimaryKey(object entity, string pkCol)
{
    if (entity == null) return;

    long pkid = (long)ReflectionHelper.GetPropertyValue(entity, pkCol);
    if (pkid > 0)
    {
        ReflectionHelper.SetPropertyValue(entity, pkCol, 0);
    }
}

/// <summary>
/// 重置审批状态相关属性
/// </summary>
/// <param name="entity">实体对象</param>
private void ResetApprovalStatus(object entity)
{
    if (entity == null) return;

    if (ReflectionHelper.ExistPropertyName(entity.GetType(), typeof(ApprovalStatus).Name))
    {
        ReflectionHelper.SetPropertyValue(entity, typeof(ApprovalStatus).Name, (int)ApprovalStatus.未审核);
    }
    if (ReflectionHelper.ExistPropertyName(entity.GetType(), typeof(DataStatus).Name))
    {
        ReflectionHelper.SetPropertyValue(entity, typeof(DataStatus).Name, (int)DataStatus.草稿);
    }

    if (ReflectionHelper.ExistPropertyName(entity.GetType(), "ApprovalResults"))
    {
        ReflectionHelper.SetPropertyValue(entity, "ApprovalResults", false);
    }

    BusinessHelper.Instance.InitEntity(entity);
    BusinessHelper.Instance.ClearEntityApproverInfo(entity);
    BusinessHelper.Instance.ClearEntityEditInfo(entity);
    BusinessHelper.Instance.InitStatusEntity(entity);
}
```

### 步骤3：修改AddByCopy方法

```csharp
protected void AddByCopy()
{
    object frm = Activator.CreateInstance(EditForm);
    if (frm.GetType().BaseType.Name.Contains("BaseEditGeneric"))
    {
        T selectItem = null;
        #region 复制性新增就是把当前的值复制到新值中
        //先取当前选中的
        if (bindingSourceList.Current != null)
        {
            selectItem = (T)bindingSourceList.Current;
        }
        #endregion
        #region 泛型情况

        BaseEditGeneric<T> frmadd = frm as BaseEditGeneric<T>;
        frmadd.bindingSourceEdit = bindingSourceList;
        object NewObj = frmadd.bindingSourceEdit.AddNew();
        if (frmadd.usedActionStatus)
        {
            frmadd.BindData(NewObj as BaseEntity, ActionStatus.新增);
        }
        else
        {
            frmadd.BindData(NewObj as BaseEntity);
        }

        //复制性 的就是把原有值除主键全部复制过去。
        FastCopy<T, T>.Copy(selectItem as T, NewObj as T, true);
        
        // 获取忽略属性配置
        var ignoreConfig = ConfigureIgnoreProperties();
        
        // 重置需要忽略的属性
        ResetIgnoredProperties(NewObj, ignoreConfig);
        
        // 设置主键为0才会新增，这里代码顺序不能反
        string PKCol = BaseUIHelper.GetEntityPrimaryKey<T>();
        ResetPrimaryKey(NewObj, PKCol);
        
        // 重置审批状态
        ResetApprovalStatus(NewObj);

        if (frmadd.ShowDialog() == DialogResult.OK)
        {
            ToolBarEnabledControl(MenuItemEnums.新增);
        }
        else
        {
            frmadd.bindingSourceEdit.CancelEdit();
        }
        #endregion
    }
    else
    {
        #region 普通情况
        BaseEdit frmadd = frm as BaseEdit;
        frmadd.bindingSourceEdit = bindingSourceList;
        object obj = frmadd.bindingSourceEdit.AddNew();
        frmadd.BindData(obj as BaseEntity, ActionStatus.新增);
        if (frmadd.ShowDialog() == DialogResult.OK)
        {
            ToolBarEnabledControl(MenuItemEnums.新增);
        }
        else
        {
            frmadd.bindingSourceEdit.CancelEdit();
        }
        #endregion
    }
}
```

### 步骤4：添加必要的命名空间引用

在BaseListGeneric.cs文件顶部添加必要的命名空间引用：

```csharp
using RUINORERP.Business.CommService;
using RUINORERP.Common.Extensions;
using RUINORERP.Model.Enums;
using System.Reflection;
```

## 预期效果

1. **功能完善**：基础信息列表中的复制性新增功能与单据编辑中的复制性新增功能保持一致

2. **灵活性**：通过虚方法允许子类重写，实现具体业务字段的自定义重置规则

3. **可靠性**：确保复制生成的新实体能够正确保存到系统中，且不会与原实体产生数据冲突

4. **用户体验**：保持现有的UI交互方式，用户可以在窗体中修改字段值

5. **代码复用**：复用现有的IgnorePropertyConfiguration类和重置方法，确保功能一致性

## 注意事项

1. 确保BaseListGeneric.cs文件中已经添加了必要的命名空间引用

2. 确保IgnorePropertyConfiguration类在RUINORERP.Business.CommService命名空间中可用

3. 确保ReflectionHelper、BaseUIHelper、BusinessHelper等辅助类在BaseListGeneric中可用

4. 测试修改后的功能，确保复制性新增能够正确工作，且不会影响现有的功能

5. 确保子类可以通过重写ConfigureIgnoreProperties方法来自定义忽略字段规则
