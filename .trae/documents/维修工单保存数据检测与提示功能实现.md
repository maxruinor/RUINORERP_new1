# 维修工单保存数据检测与提示功能实现

## 1. 实现目标
根据用户最新要求，调整实现逻辑：
- **保存时**：仅显示预览信息，提示系统将在审核通过后生成的单据类型、数量及相关费用信息
- **审核时**：根据费用分摊模式和承担方类型，执行对应单据生成逻辑

## 2. 核心逻辑流程

### 2.1 保存流程调整
1. 在 `UCASRepairOrder.cs` 的 `Save` 方法中，保存成功后添加预览信息提示
2. 根据当前工单的费用分摊模式，预测并显示将要生成的单据类型和金额
3. 不执行实际的单据生成操作，仅提供预览

### 2.2 审核流程调整
1. 在 `tb_AS_RepairOrderControllerPartial.cs` 的 `ApprovalAsync` 方法中，根据 `ExpenseAllocationMode` 和 `ExpenseBearerType` 判断费用分摊模式
2. 执行对应类型的单据生成逻辑
3. 确保所有分摊模式都能正确处理

## 3. 具体分摊模式处理

### 3.1 单一分摊-客户模式
- **条件**：`ExpenseAllocationMode == 1` 且 `ExpenseBearerType == 1`
- **逻辑**：调用已实现的 `BuildReceivablePayable` 方法生成客户应收款单
- **保存预览提示**："该工单为单一客户分摊模式，审核通过后将生成客户应收款单，金额：XXX"
- **审核成功提示**："已生成客户应收款单"

### 3.2 单一分摊-供应商模式
- **条件**：`ExpenseAllocationMode == 1` 且 `ExpenseBearerType == 2`
- **逻辑**：不生成任何费用单据
- **保存预览提示**："该工单为供应商承担费用模式，审核通过后不生成费用单据"
- **审核成功提示**："供应商承担费用，不生成费用单据"

### 3.3 单一分摊-己方公司模式
- **条件**：`ExpenseAllocationMode == 1` 且 `ExpenseBearerType == 3`
- **逻辑**：生成维修售后费用支出单
- **保存预览提示**："该工单为己方公司承担费用模式，审核通过后将生成维修售后费用支出单，金额：XXX"
- **审核成功提示**："已生成维修售后费用支出单"

### 3.4 混合分摊模式
- **条件**：`ExpenseBearerType == 4`（混合分摊）
- **逻辑**：按50%比例生成客户应收款单
- **保存预览提示**："该工单为混合分摊模式，审核通过后将按50%比例生成客户应收款单，金额：XXX"
- **审核成功提示**："已按50%比例生成客户应收款单"

## 4. 实现步骤

### 4.1 第一步：修改 UCASRepairOrder.cs
1. 在 `Save` 方法的保存成功分支后，添加预览信息提示逻辑
2. 添加 `ShowExpenseAllocationPreview` 私有方法，根据当前工单信息生成预览提示
3. 使用 `MessageBox.Show` 显示预览信息

### 4.2 第二步：修改 tb_AS_RepairOrderControllerPartial.cs
1. 在 `ApprovalAsync` 方法中，替换现有的应收款生成逻辑（第97-170行）
2. 添加 `HandleExpenseAllocation` 私有方法，实现根据不同分摊模式生成对应单据
3. 在方法中实现所有四种分摊模式的处理逻辑

### 4.3 第三步：实现集团公司费用单生成
1. 在 `HandleExpenseAllocation` 方法中，添加生成集团公司费用单的逻辑
2. 可以复用或参考现有应收款单生成逻辑

### 4.4 第四步：实现混合分摊模式
1. 在 `HandleExpenseAllocation` 方法中，添加混合分摊模式的处理逻辑
2. 在调用 `BuildReceivablePayable` 方法前，将工单金额乘以50%作为应收金额

## 5. 代码实现要点

### 5.1 UCASRepairOrder.cs 关键代码
```csharp
// 在 Save 方法保存成功后调用
if (SaveResult.Succeeded)
{
    MainForm.Instance.PrintInfoLog($"保存成功,{EditEntity.RepairOrderNo}。");
    // 显示费用分摊预览信息
    ShowExpenseAllocationPreview(EditEntity);
}

// 预览信息提示方法
private void ShowExpenseAllocationPreview(tb_AS_RepairOrder entity)
{
    string previewMsg = string.Empty;
    decimal totalAmount = entity.TotalAmount;
    
    if (entity.ExpenseAllocationMode == (int)ExpenseAllocationMode.单一承担)
    {
        switch ((ExpenseBearerType)entity.ExpenseBearerType)
        {
            case ExpenseBearerType.客户:
                previewMsg = $"该工单为单一客户分摊模式，审核通过后将生成客户应收款单，金额：{totalAmount:C}";
                break;
            case ExpenseBearerType.供应商:
                previewMsg = "该工单为供应商承担费用模式，审核通过后不生成费用单据";
                break;
            case ExpenseBearerType.己方公司:
                previewMsg = $"该工单为己方公司承担费用模式，审核通过后将生成维修售后费用支出单，金额：{totalAmount:C}";
                break;
        }
    }
    else if (entity.ExpenseBearerType == (int)ExpenseBearerType.Mixed)
    {
        decimal halfAmount = totalAmount * 0.5m;
        previewMsg = $"该工单为混合分摊模式，审核通过后将按50%比例生成客户应收款单，金额：{halfAmount:C}";
    }
    
    if (!string.IsNullOrEmpty(previewMsg))
    {
        MessageBox.Show(previewMsg, "费用分摊预览", MessageBoxButtons.OK, MessageBoxIcon.Information);
    }
}
```

### 5.2 tb_AS_RepairOrderControllerPartial.cs 关键代码
```csharp
// 替换现有的应收款生成逻辑
if (authorizeController.EnableFinancialModule())
{
    // 处理费用分摊
    await HandleExpenseAllocation(entity);
}

// 费用分摊处理方法
private async Task HandleExpenseAllocation(tb_AS_RepairOrder entity)
{
    decimal totalAmount = entity.TotalAmount;
    
    if (entity.ExpenseAllocationMode == (int)ExpenseAllocationMode.单一承担)
    {
        switch ((ExpenseBearerType)entity.ExpenseBearerType)
        {
            case ExpenseBearerType.客户:
                // 生成客户应收款单（复用现有逻辑）
                await GenerateCustomerReceivable(entity, totalAmount);
                break;
            case ExpenseBearerType.供应商:
                // 不生成单据，记录日志
                _logger.LogInformation($"维修工单 {entity.RepairOrderNo} 为供应商承担费用，不生成费用单据");
                break;
            case ExpenseBearerType.己方公司:
                // 生成集团公司费用单
                await GenerateCompanyExpenseOrder(entity, totalAmount);
                break;
        }
    }
    else if (entity.ExpenseBearerType == (int)ExpenseBearerType.Mixed)
    {
        // 混合分摊，按50%比例生成客户应收款单
        decimal halfAmount = totalAmount * 0.5m;
        await GenerateCustomerReceivable(entity, halfAmount);
    }
}

// 生成客户应收款单方法
private async Task GenerateCustomerReceivable(tb_AS_RepairOrder entity, decimal amount)
{
    // 记录原始金额
    decimal originalAmount = entity.TotalAmount;
    
    try
    {
        // 临时修改工单金额为计算后的金额（仅用于生成应收款单）
        entity.TotalAmount = amount;
        
        // 生成应收款单
        var ctrpay = _appContext.GetRequiredService<tb_FM_ReceivablePayableController<tb_FM_ReceivablePayable>>();
        var receivablePayable = await ctrpay.BuildReceivablePayable(entity);
        var rmpay = await ctrpay.BaseSaveOrUpdateWithChild<tb_FM_ReceivablePayable>(receivablePayable, false);
        
        if (!rmpay.Succeeded)
        {
            throw new Exception($"应收款单生成失败：{rmpay.ErrorMsg ?? "未知错误"}