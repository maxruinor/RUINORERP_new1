# 跨客户端单据状态变更同步方案

## 1. 现有架构分析

### 1.1 核心组件
- **TodoUpdate**: 任务状态更新数据结构，包含更新类型、业务类型、单据ID等
- **TodoSyncManager**: 任务状态同步管理器，负责本地状态更新分发
- **TodoListManager**: 处理单据状态更新并确定所属工作台节点
- **UCTodoList**: 工作台列表控件，显示待办事项
- **ClientCommunicationService**: 客户端通信服务，负责与服务器通信
- **TodoCommandHandler**: 处理来自服务器的任务状态通知
- **TodoNotificationService**: 服务器端，向客户端推送任务状态变更通知

### 1.2 通信机制
- 客户端通过`SendCommandWithResponseAsync`方法发送命令
- 服务器通过`NotifyTodoChangeAsync`方法广播通知
- 支持`MessageCommands.SendTodoNotification`命令

## 2. 实现方案

### 2.1 客户端发送状态变更

**修改文件**: 
- `BaseBillEditGeneric.cs`
- `BaseBillQueryMC.cs`

**实现逻辑**: 
1. 在单据状态变更方法中（如审核、提交、删除等），添加发送状态更新的逻辑
2. 使用`MessageService`发送状态更新命令
3. 构造`TodoUpdate`对象，包含完整的状态变更信息

**关键代码示例**:
```csharp
// 构造TodoUpdate对象
var todoUpdate = TodoUpdate.Create(
    TodoUpdateType.StatusChanged,
    bizType,
    billId,
    entity,
    nameof(DataStatus),
    dataStatus
);
todoUpdate.OperationDescription = "单据已审核";
todoUpdate.InitiatorUserId = currentUserId;

// 发送到服务器
await _messageService.SendCommandAsync(
    MessageCommands.SendTodoNotification,
    new MessageRequest(MessageType.Business, todoUpdate)
);
```

### 2.2 服务器端处理

**修改文件**: 
- 添加服务器命令处理器

**实现逻辑**: 
1. 创建命令处理器`TodoStatusUpdateCommandHandler`
2. 处理客户端发送的`MessageCommands.SendTodoNotification`命令
3. 调用`TodoNotificationService.NotifyTodoChangeAsync`广播给所有客户端

**关键代码示例**:
```csharp
[CommandHandler(MessageCommands.SendTodoNotification)]
public async Task HandleTodoStatusUpdateAsync(MessageRequest request)
{
    if (request?.Data is TodoUpdate update)
    {
        // 处理状态更新逻辑
        await _todoNotificationService.NotifyTodoChangeAsync(update);
    }
}
```

### 2.3 客户端接收和更新

**现有代码已实现**: 
- `TodoCommandHandler`处理`SendTodoNotification`命令
- `TodoSyncManager.Instance.PublishUpdate(update)`发布更新
- `UCTodoList`通过订阅接收更新并刷新UI

**增强功能**: 
- 确保`TodoCommandHandler`正确处理所有业务类型
- 优化`UCTodoList.RefreshDataNodes`方法，提高批量更新性能

### 2.4 消息中心通知

**修改文件**: 
- `TodoCommandHandler.cs`

**实现逻辑**: 
1. 在`ProcessTaskStatusChangeAsync`方法中，添加将更新添加到消息管理器的逻辑
2. 使用`MessageService`添加系统消息
3. 确保消息包含完整的状态变更信息

**关键代码示例**:
```csharp
// 添加到消息管理器
var messageService = Startup.GetFromFac<MessageService>();
var message = new MessageData
{
    Id = SnowflakeIdHelper.GetLongId(),
    MessageType = MessageType.Business,
    Title = "任务状态变更",
    Content = update.OperationDescription,
    BizData = update,
    SendTime = DateTime.Now,
    IsRead = false
};
await messageService.AddMessageAsync(message);
```

## 3. 实现步骤

1. **客户端发送逻辑**: 
   - 在`BaseBillEditGeneric.cs`的状态变更方法中添加发送代码
   - 在`BaseBillQueryMC.cs`的状态变更方法中添加发送代码

2. **服务器端命令处理**: 
   - 创建`TodoStatusUpdateCommandHandler`
   - 注册到命令处理系统

3. **客户端消息中心集成**: 
   - 完善`TodoCommandHandler`中的消息添加逻辑

4. **测试验证**: 
   - 测试单据状态变更是否同步到其他客户端
   - 测试消息中心是否收到通知
   - 测试工作台列表是否正确更新

## 4. 注意事项

1. **性能优化**: 
   - 批量处理状态更新，减少网络请求
   - 优化UI更新逻辑，避免频繁刷新

2. **错误处理**: 
   - 添加网络通信错误处理
   - 确保状态同步失败时不影响主业务流程

3. **安全性**: 
   - 验证发送者权限
   - 确保状态变更的合法性

4. **数据一致性**: 
   - 确保服务器和客户端状态一致
   - 添加状态验证机制

## 5. 预期效果

1. **实时同步**: 单据状态变更后，所有客户端实时更新
2. **消息通知**: 状态变更会显示在消息中心
3. **工作台更新**: 工作台待办事项列表自动刷新
4. **跨客户端**: 支持多个客户端之间的状态同步

该方案基于现有代码架构，最小化修改，实现跨客户端单据状态同步功能。