# RUINORERP自动更新系统文档

## 1. 项目概述

本文档涵盖RUINORERP系统的自动更新解决方案，包括两个核心组件：

### 1.1 AutoUpdate
AutoUpdate是RUINORERP系统的自动更新组件，负责检查、下载、安装系统更新，同时提供版本管理、跳过版本和版本回滚功能。该组件采用C#开发，基于.NET Framework，提供用户友好的更新界面和完善的异常处理机制。

### 1.2 AutoUpdateTools
AutoUpdateTools是配套的更新发布工具集，提供压缩更新包创建、版本信息管理和发布验证功能。该工具集简化了更新包的创建和发布流程，支持高效的文件压缩和版本控制。

## 2. 项目结构

### 2.1 AutoUpdate项目结构

```
├── App.ico                     # 应用程序图标
├── AppUpdater.cs               # 更新器核心功能类
├── AssemblyInfo.cs             # 程序集信息
├── AutoUpdate.csproj           # 项目文件
├── AutoUpdaterList.xml         # 更新列表配置文件
├── Compress.cs                 # 压缩文件处理类
├── CompressedUpdateTester.cs   # 压缩更新测试类
├── EnhancedVersionManager.cs   # 增强版本管理器
├── FrmUpdate.cs                # 更新主窗口
├── FrmUpdate.resx              # 界面资源文件
├── IniFiles.cs                 # INI配置文件处理
├── SkipVersionManager.cs       # 跳过版本管理
├── VersionHistoryManager.cs    # 版本历史管理
├── VersionRollbackManager.cs   # 版本回滚管理
├── XmlFiles.cs                 # XML文件处理
├── ZipArchiveExtensions.cs     # ZIP文件扩展
├── app.config                  # 应用程序配置
├── frmDebugInfo.cs             # 调试信息窗口
└── frmDebugInfo.resx           # 调试窗口资源
```

### 2.2 AutoUpdateTools项目结构

```
├── CompressPublisher.cs    # 压缩发布管理器
├── frmAULWriter.cs         # 更新列表写入器界面
├── frmAULWriter.resx       # 更新列表写入器资源
├── Program.cs              # 程序入口
└── AutoUpdateTools.csproj  # 项目文件
```

## 3. 核心功能实现

### 3.1 自动更新功能

自动更新是系统的核心功能，通过以下步骤实现：

1. **更新检查**：程序启动时检查是否有新版本可用
2. **文件下载**：下载更新包到临时目录
3. **文件安装**：替换旧文件，安装新文件
4. **自我更新**：特殊处理更新程序自身的更新
5. **压缩更新支持**：支持下载和安装压缩更新包，提高更新效率

#### 自我更新实现

自我更新功能通过`LastCopy`方法实现，核心逻辑包括：

```csharp
private void LastCopy()
{
    try
    {
        AppendAllText("更新完成");
        // 根据不同的版本号，复制相应的文件到对应的目录
        for (int i = 0; i < versionDirList.Count; i++)
        {
            CopyFile((tempUpdatePath + versionDirList[i]), Directory.GetCurrentDirectory(), versionDirList[i]);
        }
        AppendAllText("更新完成");

        // 版本管理：只保留指定数量的版本
        try
        {
            List<string> versions = new List<string>();
            string[] subDirectories = Directory.GetDirectories(tempUpdatePath);
            foreach (var subdir in subDirectories)
            {
                string verDir = Path.GetFileName(subdir);
                versions.Add(verDir);
            }

            if (versions.Count > 0)
            {
                versions.Sort();
                int deleteCount = versions.Count - MaxVersionCount;
                versions = versions.Take(deleteCount).ToList();

                foreach (var version in versions)
                {
                    System.IO.Directory.Delete(tempUpdatePath + version, true);
                }
            }
        }
        catch (Exception exx)
        {
            AppendAllText($"版本管理清理失败 - {exx.Message}");
        }
    }
    catch (Exception ex)
    {
        string errorMsg = $"更新过程中发生错误: {ex.Message}";
        AppendAllText(errorMsg);
        // 错误处理...
    }
}
```

### 3.2 跳过当前版本功能

用户可以选择跳过当前版本的更新，该功能通过`SkipVersionManager`类实现：

#### SkipVersionManager.cs核心功能

```csharp
public class SkipVersionManager
{
    private readonly string skipVersionFilePath;

    public SkipVersionManager()
    {
        // 使用应用程序数据文件夹存储跳过的版本信息
        string appDataPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "RUINORERP");
        Directory.CreateDirectory(appDataPath);
        skipVersionFilePath = Path.Combine(appDataPath, "SkippedVersions.xml");
    }

    // 记录跳过的版本
    public void SkipVersion(string version, string applicationId)
    {
        try
        {
            XmlDocument xmlDoc = new XmlDocument();
            // 加载或创建XML文档
            // ...
            // 创建或更新跳过版本记录
            // ...
            xmlDoc.Save(skipVersionFilePath);
        }
        catch (Exception ex)
        {
            Console.WriteLine("保存跳过版本信息失败: " + ex.Message);
        }
    }

    // 检查指定版本是否被跳过
    public bool IsVersionSkipped(string version, string applicationId)
    {
        try
        {
            if (!File.Exists(skipVersionFilePath))
            {
                return false;
            }
            // 加载XML并检查是否存在跳过记录
            // ...
        }
        // ...
    }
}
```

#### 跳过版本按钮事件处理

```csharp
private void btnskipCurrentVersion_Click(object sender, EventArgs e)
{
    try
    {
        // 获取当前版本信息
        string currentVersion = this.NewVersion;
        string appId = "RUINORERP";
        
        // 使用SkipVersionManager记录跳过的版本
        SkipVersionManager skipManager = new SkipVersionManager();
        skipManager.SkipVersion(currentVersion, appId);
        
        // 设置跳过版本状态并关闭窗口
        mainResult = -9;
        SkipCurrentVersion = true;
        this.Close();
        
        // 记录日志
        WriteLog("用户选择跳过版本：" + currentVersion);
    }
    catch (Exception ex)
    {
        MessageBox.Show("记录跳过版本信息时发生错误：" + ex.Message, "操作提示", MessageBoxButtons.OK, MessageBoxIcon.Warning);
        mainResult = -9;
        SkipCurrentVersion = true;
        this.Close();
    }
}
```

### 3.3 版本回滚功能

系统支持回滚到历史版本，该功能通过`VersionRollbackManager`类实现：

#### VersionRollbackManager.cs核心功能

```csharp
public class VersionRollbackManager
{
    private VersionHistoryManager versionHistoryManager;
    
    // 获取可回滚的版本列表
    public List<VersionEntry> GetRollbackVersions()
    {
        try
        {
            var allVersions = versionHistoryManager.GetAllVersions();
            if (allVersions.Count <= 1)
            {
                return new List<VersionEntry>();
            }

            // 返回除当前版本外的所有版本（按安装时间倒序）
            return allVersions.Skip(1).ToList();
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"获取回滚版本列表失败: {ex.Message}");
            return new List<VersionEntry>();
        }
    }

    // 执行版本回滚
    public bool RollbackToVersion(string targetVersion)
    {
        try
        {
            // 1. 验证目标版本是否存在于历史记录中
            // 2. 检查目标版本是否为当前版本
            // 3. 从服务器获取目标版本的更新包
            // 4. 解压并安装目标版本
            // 5. 更新版本历史记录
            // ...
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"执行版本回滚失败: {ex.Message}");
            return false;
        }
    }
}
```

#### VersionHistoryManager核心功能

版本历史管理器负责记录和维护版本历史，支持版本回滚：

```csharp
public class VersionHistoryManager
{
    // 版本历史记录文件路径
    private string HistoryFilePath { get; set; }

    // 版本历史记录列表
    public List<VersionEntry> VersionHistory { get; set; }

    // 记录新版本安装
    public void RecordNewVersion(string version, DateTime? installTime = null)
    {
        // 记录新版本到历史
        // ...
    }

    // 获取所有版本
    public List<VersionEntry> GetAllVersions()
    {
        return VersionHistory.OrderByDescending(v => v.InstallTime).ToList();
    }

    // 获取当前版本
    public VersionEntry GetCurrentVersion()
    {
        return VersionHistory.OrderByDescending(v => v.InstallTime).FirstOrDefault();
    }
}
```

## 4. 功能检查结果

### 4.1 跳过当前版本功能

✅ **已完成**
- 通过`SkipVersionManager`类实现了跳过版本的记录和检查
- 在UI中提供了`btnskipCurrentVersion`按钮供用户选择跳过
- 支持通过XML文件持久化存储跳过版本信息
- 提供了强制更新选项，可以覆盖跳过设置

### 4.2 版本回滚功能

✅ **已完成**
- 通过`VersionRollbackManager`类实现了回滚功能
- 支持查看历史版本列表
- 可以回滚到任意历史版本
- 通过`VersionHistoryManager`维护版本安装历史
- 提供了文件复制和替换机制确保回滚的可靠性

### 4.3 自动自我更新功能

✅ **已完成**
- 通过`LastCopy`方法实现了程序自身的更新
- 采用文件备份机制确保更新安全
- 提供了测试模式用于验证自我更新流程
- 实现了版本文件夹管理和清理

## 5. 技术特点

1. **多线程处理**：支持后台下载，不阻塞主线程
2. **异常处理**：完善的错误捕获和日志记录机制
3. **文件操作优化**：支持大型文件和压缩文件的高效处理
4. **用户体验**：提供友好的界面和操作反馈
5. **配置灵活**：通过XML配置支持多种更新场景
6. **版本管理**：完善的版本历史和回滚支持

## 6. 配置与部署

### 6.1 AutoUpdate配置

1. **配置文件**：`AutoUpdaterList.xml`定义了更新源、应用信息和更新文件列表
2. **部署要求**：需要.NET Framework环境和相应的权限
3. **版本存储**：版本历史存储在`VersionHistory.xml`中
4. **跳过版本存储**：存储在用户应用数据文件夹中的`SkippedVersions.xml`
5. **压缩更新配置**：通过`AppUpdater.cs`中的`CheckForCompressedUpdate`方法检查服务器上的压缩更新包

### 6.2 AutoUpdateTools使用方法

1. **启动应用**：运行AutoUpdateTools.exe启动更新列表写入器
2. **创建更新包**：使用CompressPublisher类创建压缩更新包
3. **发布配置**：配置服务器路径、版本信息和发布选项
4. **验证更新**：使用CompressedUpdateTester测试更新包的有效性

## 7. 日志与调试

1. **日志记录**：通过`AppendAllText`和`WriteLog`方法记录操作日志
2. **调试窗口**：提供`frmDebugInfo`调试窗口查看详细信息
3. **异常捕获**：关键操作都有异常处理，确保程序稳定运行

## 8. 总结与建议

AutoUpdate组件已成功实现了所有要求的功能，包括跳过版本、版本回滚和自我更新。系统设计合理，代码结构清晰，具有良好的可维护性。

### 改进建议

1. **增强回滚可靠性**：可以添加回滚前的系统快照功能
2. **优化大文件下载**：添加断点续传功能
3. **安全性增强**：添加更新包签名验证机制
4. **用户体验优化**：提供更详细的更新内容说明和进度展示
5. **网络适应性**：添加网络状况检测和自动重试机制

## 7. 新增功能：压缩更新支持

### 7.1 功能概述

系统新增了压缩更新功能，通过GZip压缩算法优化更新包大小，提高下载速度和更新效率。同时增强了版本管理机制，支持更灵活的版本信息处理。

### 7.2 核心组件

#### 7.2.1 EnhancedVersionManager

增强版本管理器，负责处理压缩更新包的解压和安装：

- **ProcessCompressedUpdate**：处理压缩更新包，解压并安装更新
- **ParseVersionInfo**：解析版本信息XML文件
- **CopyExtractedFiles**：复制解压后的文件到目标目录

#### 7.2.2 CompressPublisher

压缩发布管理器，用于创建压缩更新包：

- **Publish**：创建并发布压缩更新包
- **CreateVersionInfoFile**：创建版本信息XML文件
- **UpdatePublishXml**：更新发布配置文件

#### 7.2.3 CompressedUpdateTester

压缩更新测试工具，用于验证压缩更新功能：

- **TestCompressedUpdate**：测试压缩更新包的处理
- **TestCheckForCompressedUpdate**：测试检查服务器压缩更新包
- **GenerateVersionInfoXml**：生成版本信息XML文件

### 7.3 使用方法

#### 7.3.1 创建压缩更新包

```csharp
// 创建CompressPublisher实例
CompressPublisher publisher = new CompressPublisher(
    sourceDir: @"E:\SourceFolder",
    targetDir: @"E:\TargetFolder",
    version: "1.2.3.4",
    description: "新版本更新说明",
    serverUrl: "http://updates.example.com/"
);

// 发布压缩更新包
PublishResult result = publisher.Publish();

if (result.Success)
{
    Console.WriteLine("压缩更新包发布成功！");
    Console.WriteLine($"文件路径: {result.OutputFilePath}");
    Console.WriteLine($"文件大小: {result.FileSize} 字节");
}
else
{
    Console.WriteLine($"发布失败: {result.ErrorMessage}");
}
```

#### 7.3.2 检查和安装压缩更新

```csharp
// 创建AppUpdater实例
AppUpdater updater = new AppUpdater();

// 检查服务器上的压缩更新包
bool hasUpdate = updater.CheckForCompressedUpdate("http://updates.example.com/update.zip");

if (hasUpdate)
{
    // 处理压缩更新包
    bool success = updater.ProcessCompressedUpdate(
        compressedFilePath: @"E:\Downloads\update.zip",
        tempDir: @"E:\Temp",
        targetDir: @"E:\Application"
    );
    
    if (success)
    {
        Console.WriteLine("压缩更新安装成功！");
    }
}
```

## 8. 技术特点

1. **多线程处理**：支持后台下载，不阻塞主线程
2. **异常处理**：完善的错误捕获和日志记录机制
3. **文件操作优化**：支持大型文件和压缩文件的高效处理
4. **用户体验**：提供友好的界面和操作反馈
5. **配置灵活**：通过XML配置支持多种更新场景
6. **版本管理**：完善的版本历史和回滚支持
7. **压缩优化**：通过GZip压缩算法减小更新包大小，提高下载效率
8. **发布工具**：提供专用工具简化更新包创建和发布流程

## 9. 总结与建议

AutoUpdate组件已成功实现了所有要求的功能，包括跳过版本、版本回滚和自我更新。系统设计合理，代码结构清晰，具有良好的可维护性。新增的压缩更新功能和AutoUpdateTools项目进一步增强了系统的更新效率和易用性。

### 改进建议

1. **增强回滚可靠性**：可以添加回滚前的系统快照功能
2. **优化大文件下载**：添加断点续传功能
3. **安全性增强**：添加更新包签名验证机制
4. **用户体验优化**：提供更详细的更新内容说明和进度展示
5. **网络适应性**：添加网络状况检测和自动重试机制
6. **批量更新支持**：支持多客户端同时更新的场景优化
7. **差分更新**：实现基于文件差异的增量更新，进一步减小更新包大小

## 10. 版本信息

- **当前版本**：根据`AutoUpdaterList.xml`中的配置
- **更新日期**：根据系统日志记录
- **开发者**：RUINORERP开发团队

---

*本文档由AutoUpdate组件自动生成，最后更新时间：2024年*