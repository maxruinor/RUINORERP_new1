# 序号生成并发优化实施方案

## 一、优化概述

本方案通过引入**乐观锁**和**行级锁**机制,解决当前序号生成服务在高并发场景下的性能瓶颈和锁竞争问题。

### 核心优化点

| 优化项 | 原实现 | 优化后 | 改进效果 |
|--------|--------|--------|----------|
| 锁机制 | 全局锁 `_queueLock` | 按键分片锁 `_keyLocks` | 不同序列键可并行处理 |
| 数据库访问 | 无锁查询 | `WITH(UPDLOCK, HOLDLOCK)` 行级锁 | 避免脏读,保证一致性 |
| 并发控制 | 重试机制 | 乐观锁 + 指数退避重试 | 减少锁等待时间,提高吞吐量 |
| 批量更新 | 大事务批量更新 | 小事务逐条更新 | 减少锁持有时间,避免死锁 |
| 缓存策略 | 内存缓存 + 队列 | 同上 + 异步刷新 | 不阻塞主流程,提升响应速度 |

## 二、优化后服务类: OptimizedDatabaseSequenceService

### 2.1 核心特性

```csharp
public class OptimizedDatabaseSequenceService : IDisposable
{
    // 按键分片锁,不同序列键独立加锁
    private readonly ConcurrentDictionary<string, object> _keyLocks;
    
    // 使用行级锁从数据库获取值
    private long GetNextValueWithRowLock(...);
    
    // 乐观锁更新机制
    .Where(s => s.SequenceKey == sequenceKey 
        && s.CurrentValue == currentVersion) // 乐观锁条件
}
```

### 2.2 并发安全保证

1. **行级锁**: 使用 `WITH(UPDLOCK, HOLDLOCK)` 确保读取时锁定该行
2. **乐观锁**: 只在版本号未变化时更新,避免长时间持有锁
3. **按键锁**: 不同序列键使用不同的锁对象,支持并行处理
4. **指数退避重试**: 冲突时等待时间递增,避免雪崩

### 2.3 性能提升

- **TPS提升**: 预计提升 3-5 倍(取决于并发场景)
- **锁等待时间**: 减少 60-80%
- **死锁概率**: 接近零(乐观锁机制)

## 三、实施步骤

### 步骤1: 备份原有服务

```bash
# 1. 备份 DatabaseSequenceService.cs
copy DatabaseSequenceService.cs DatabaseSequenceService.cs.bak

# 2. 新建优化服务
# OptimizedDatabaseSequenceService.cs 已创建
```

### 步骤2: 修改依赖注入配置

#### 方式A: 直接替换(推荐)

```csharp
// Startup.cs 或 ServiceCollectionExtensions.cs

// 原有注册
// services.AddSingleton<DatabaseSequenceService, DatabaseSequenceService>();

// 替换为优化版
services.AddSingleton<DatabaseSequenceService, OptimizedDatabaseSequenceService>();
```

#### 方式B: 并存运行(灰度发布)

```csharp
// Startup.cs

// 注册优化版服务
services.AddSingleton<OptimizedDatabaseSequenceService>();

// 同时注册原有服务(可选,用于回滚)
services.AddSingleton<DatabaseSequenceService, DatabaseSequenceService>();

// BNRFactory 使用优化版
var optimizedService = new OptimizedDatabaseSequenceService(sqlSugarClient);
var bnrFactory = new BNRFactory(optimizedService, cacheManager);
```

### 步骤3: 验证功能

#### 3.1 单元测试

```csharp
[Fact]
public void TestConcurrentSequenceGeneration()
{
    // 测试并发生成同一序列键
    var service = new OptimizedDatabaseSequenceService(sqlSugarClient);
    string testKey = "CONCURRENT_TEST";
    
    // 并发生成100个序号
    var tasks = Enumerable.Range(0, 100).Select(i => 
        Task.Run(() => service.GetNextSequenceValue(testKey))
    ).ToArray();
    
    Task.WaitAll(tasks);
    
    // 验证唯一性
    var values = tasks.Select(t => t.Result).OrderBy(v => v).ToList();
    Assert.Equal(100, values.Count);
    Assert.Equal(1, values[0]);
    Assert.Equal(100, values[99]);
    
    // 清理
    service.DeleteSequence(testKey);
}
```

#### 3.2 集成测试

```csharp
// 测试业务单据编号生成
[Fact]
public void TestBusinessNumberGeneration()
{
    var service = new OptimizedDatabaseSequenceService(sqlSugarClient);
    var factory = new BNRFactory(service, cacheManager);
    
    // 设置业务类型
    BNRFactory.SetCurrentBusinessType("SalesOrder");
    
    // 并发生成50个销售订单号
    var tasks = Enumerable.Range(0, 50).Select(i => 
        Task.Run(() => factory.Create("{S:SO}{D:yyyyMMdd}{DB:SALES_ORDER/00000}"))
    ).ToArray();
    
    Task.WaitAll(tasks);
    
    // 验证唯一性
    var numbers = tasks.Select(t => t.Result).Distinct().ToList();
    Assert.Equal(50, numbers.Count);
    
    BNRFactory.SetCurrentBusinessType(null);
}
```

### 步骤4: 性能基准测试

```csharp
// 性能对比测试
public void PerformanceComparison()
{
    // 测试参数
    int threadCount = 100;
    int requestsPerThread = 100;
    string testKey = "PERF_TEST";
    
    // 测试原有服务
    var oldService = new DatabaseSequenceService(sqlSugarClient);
    var oldWatch = Stopwatch.StartNew();
    RunConcurrentTest(oldService, threadCount, requestsPerThread, testKey);
    oldWatch.Stop();
    Console.WriteLine($"原有服务耗时: {oldWatch.ElapsedMilliseconds}ms");
    
    // 测试优化服务
    var newService = new OptimizedDatabaseSequenceService(sqlSugarClient);
    var newWatch = Stopwatch.StartNew();
    RunConcurrentTest(newService, threadCount, requestsPerThread, testKey);
    newWatch.Stop();
    Console.WriteLine($"优化服务耗时: {newWatch.ElapsedMilliseconds}ms");
    
    // 计算性能提升
    double improvement = (double)(oldWatch.ElapsedMilliseconds - newWatch.ElapsedMilliseconds) 
        / oldWatch.ElapsedMilliseconds * 100;
    Console.WriteLine($"性能提升: {improvement:F2}%");
}
```

### 步骤5: 上线部署

#### 5.1 灰度发布策略

```yaml
阶段1: 10% 流量切换到优化服务
  - 监控错误率、响应时间
  - 对比序号生成成功率
  - 持续观察24小时

阶段2: 50% 流量切换
  - 继续监控关键指标
  - 收集用户反馈
  - 持续观察48小时

阶段3: 100% 流量切换
  - 全面切换到优化服务
  - 保留原有服务72小时(用于快速回滚)
  - 确认稳定后下线原有服务
```

#### 5.2 监控指标

```csharp
// 监控关键指标
public class SequenceServiceMonitor
{
    // 序号生成成功率
    public double SuccessRate { get; set; }
    
    // 平均响应时间(ms)
    public double AverageResponseTime { get; set; }
    
    // 锁等待次数
    public int LockWaitCount { get; set; }
    
    // 乐观锁冲突次数
    public int OptimisticLockConflictCount { get; set; }
    
    // 死锁次数
    public int DeadlockCount { get; set; }
}
```

## 四、回滚方案

如果优化服务出现问题,可按以下步骤快速回滚:

### 4.1 回滚步骤

```bash
# 1. 切换依赖注入回原有服务
# Startup.cs
services.AddSingleton<DatabaseSequenceService, DatabaseSequenceService>();

# 2. 重新编译部署

# 3. 清理可能的数据不一致
-- 检查序号表是否有重复
SELECT SequenceKey, COUNT(*) as Count 
FROM SequenceNumbers 
GROUP BY SequenceKey 
HAVING COUNT(*) > 1;

-- 删除重复记录(保留最新的)
WITH CTE AS (
    SELECT SequenceKey, CurrentValue,
        ROW_NUMBER() OVER (PARTITION BY SequenceKey ORDER BY LastUpdated DESC) as rn
    FROM SequenceNumbers
)
DELETE FROM SequenceNumbers
WHERE Id IN (
    SELECT Id FROM SequenceNumbers s
    JOIN CTE c ON s.SequenceKey = c.SequenceKey AND s.CurrentValue = c.CurrentValue
    WHERE c.rn > 1
);
```

### 4.2 数据校验

```csharp
// 校验序号连续性
public void ValidateSequenceContinuity(string sequenceKey)
{
    var sequences = _sqlSugarClient.Queryable<SequenceNumbers>()
        .Where(s => s.SequenceKey.StartsWith(sequenceKey))
        .OrderBy(s => s.CurrentValue)
        .ToList();
    
    for (int i = 1; i < sequences.Count; i++)
    {
        if (sequences[i].CurrentValue - sequences[i-1].CurrentValue > 1)
        {
            Console.WriteLine($"检测到序号不连续: {sequences[i].SequenceKey}");
        }
    }
}
```

## 五、注意事项

### 5.1 数据库兼容性

- SQL Server: 完全支持 `WITH(UPDLOCK, HOLDLOCK)`
- MySQL: 使用 `SELECT ... FOR UPDATE`
- PostgreSQL: 使用 `SELECT ... FOR UPDATE`

### 5.2 内存使用

- 按键锁字典会随不同序列键数量增长
- 建议监控 `_keyLocks` 的大小,超过10000个键时考虑清理策略

### 5.3 缓存一致性

- 内存缓存与数据库可能存在短暂不一致
- 通过定期刷新机制保证最终一致性
- 如需强一致性,可移除缓存层

## 六、性能优化建议

### 6.1 进一步优化方向

1. **引入Redis缓存层**: 将热点序列放入Redis,使用 `INCR` 原子操作
2. **预生成序号**: 批量预生成序号池,减少数据库访问
3. **雪花算法**: 对于不需要连续序号的场景,使用雪花算法替代数据库

### 6.2 配置调优

```csharp
// 批量更新阈值调优
// 低并发场景: 20-50
// 高并发场景: 100-200
private const int BatchUpdateThreshold = 50;

// 缓存刷新周期调优
// 实时性要求高: 1000ms
// 性能优先: 5000-10000ms
private const int CacheMaxLifetime = 5000;

// 重试次数调优
// 网络不稳定: 5-10次
// 网络稳定: 3-5次
private const int MaxRetries = 5;
```

## 七、FAQ

### Q1: 乐观锁会导致重复序号吗?

**A**: 不会。乐观锁更新失败时会重试,直到成功获取唯一值。

### Q2: 按键锁会占用太多内存吗?

**A**: 每个序列键占用一个lock对象(~24字节),假设10000个不同键,约240KB,可接受。

### Q3: 服务重启后缓存数据丢失怎么办?

**A**: 优化服务在关闭时会调用 `FlushAllToDatabase()` 确保数据持久化。

### Q4: 如何验证优化效果?

**A**: 建议使用性能基准测试对比TPS、响应时间、锁等待时间等指标。

## 八、联系方式

如有问题,请联系技术团队或在项目Issue中反馈。

---

**文档版本**: v1.0
**最后更新**: 2025-01-10
**维护者**: RUINOR ERP技术团队
