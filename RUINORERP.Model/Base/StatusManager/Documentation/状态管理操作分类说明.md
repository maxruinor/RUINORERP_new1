# 状态管理操作分类说明

## 概述

RUINORERP状态管理系统将操作分为两大类，分别采用不同的权限验证策略，确保单据状态管理的精确性和灵活性。

## 操作分类

### 1. 状态转换类操作（State Transition Actions）

#### 定义
具有明确目标状态的操作，会改变单据的业务状态。

#### 包含操作
- **提交**：将单据从草稿状态转换为新建状态
- **审核**：将单据从新建状态转换为确认状态
- **反审**：将单据从确认状态转换回新建状态
- **结案**：将单据转换为完结状态
- **反结案**：将单据从完结状态转换回新建状态
- **作废**：将单据转换为作废状态

#### 权限验证策略
1. **状态转换规则验证**：检查当前状态是否允许转换到目标状态
2. **操作权限规则验证**：检查当前状态是否允许执行该操作
3. **目标状态冲突检查**：如果目标状态与当前状态相同，则不允许执行

#### 验证流程
```csharp
// 状态转换类操作验证示例
var result = StateManager.CanExecuteActionWithMessage(entity, MenuItemEnums.提交);
// 验证流程：
// 1. 获取当前状态
// 2. 映射目标状态（提交->新建）
// 3. 验证状态转换规则（草稿->新建是否允许）
// 4. 验证操作权限规则（草稿状态是否允许提交）
// 5. 返回验证结果和详细消息
```

### 2. 无目标状态操作（Non-State Transition Actions）

#### 定义
不改变单据业务状态的操作，仅基于当前状态判断权限。

#### 包含操作
- **新增**：创建新单据（始终允许）
- **修改**：编辑当前单据内容
- **删除**：删除当前单据
- **保存**：保存单据数据
- **查询**：查看单据信息（始终允许）
- **打印**：打印单据（始终允许）
- **导出**：导出单据数据（始终允许）

#### 权限验证策略
1. **当前状态权限验证**：仅检查当前状态是否允许执行该操作
2. **终态检查**：对于修改、删除、保存操作，检查是否为终态状态
3. **提交后修改规则**：对于修改操作，根据全局模式设置判断提交后是否允许修改

#### 验证流程
```csharp
// 无目标状态操作验证示例
var result = StateManager.CanExecuteActionWithMessage(entity, MenuItemEnums.修改);
// 验证流程：
// 1. 获取当前状态
// 2. 验证操作权限规则（当前状态是否允许修改）
// 3. 检查是否为终态状态（完结/作废状态不允许修改）
// 4. 检查提交后修改规则（根据全局模式设置）
// 5. 返回验证结果和详细消息
```

## 全局规则配置

### 提交修改模式
系统支持两种提交修改模式，影响无目标状态操作的权限判断：

#### 严格模式（Strict Mode）
- 单据提交后不允许修改
- 适用于需要严格流程控制的业务场景
- 设置方法：`GlobalStateRulesManager.Instance.SetSubmitModifyRuleMode(SubmitModifyRuleMode.严格模式);`

#### 灵活模式（Flexible Mode）
- 单据提交后仍然允许修改
- 适用于需要灵活处理的业务场景
- 设置方法：`GlobalStateRulesManager.Instance.SetSubmitModifyRuleMode(SubmitModifyRuleMode.灵活模式);`

### 状态类型支持
系统支持多种业务状态类型，每种类型都有独立的操作权限规则：

- **DataStatus**：基础数据状态（草稿、新建、确认、完结、作废）
- **PaymentStatus**：付款状态（草稿、待审核、已支付）
- **PrePaymentStatus**：预付款状态（草稿、待审核、已生效、待核销等）
- **ARAPStatus**：应收应付状态（草稿、待审核、待支付、部分支付等）
- **StatementStatus**：对账状态（草稿、新建、确认、部分结算、全部结清等）

## UI层集成

### 按钮状态更新
UI层通过以下流程更新按钮状态：

1. **状态变更事件监听**：监听实体的`StatusChanged`事件
2. **UI状态获取**：调用`StateManager.GetUIControlStates(entity)`获取所有按钮状态
3. **按钮状态应用**：根据返回的状态字典更新各个按钮的`Enabled`属性

### 操作权限验证
在执行具体操作前，UI层会验证操作权限：

```csharp
// 保存操作权限验证示例
case MenuItemEnums.保存:
    var canSave = StateManager.CanExecuteActionWithMessage(EditEntity, MenuItemEnums.保存);
    if (!canSave.CanExecute)
    {
        MessageBox.Show(canSave.Message, "保存权限验证", MessageBoxButtons.OK, MessageBoxIcon.Warning);
        MainForm.Instance.uclog.AddLog($"保存操作被拒绝：{canSave.Message}");
        return;
    }
    // 继续执行保存操作
    break;
```

### 用户反馈优化
系统提供友好的用户反馈机制：

- **权限拒绝提示**：使用消息框显示详细的拒绝原因
- **操作日志记录**：在系统日志中记录权限验证结果
- **状态栏信息**：在主界面状态栏显示操作反馈信息

## 最佳实践

### 1. 操作权限验证时机
- **UI按钮状态更新**：在状态变更时自动更新按钮可用性
- **操作执行前**：在执行具体操作前再次验证权限，确保安全性
- **批量操作**：对批量操作进行统一的权限验证

### 2. 错误处理策略
- **权限验证失败**：提供清晰的用户提示和操作指导
- **系统异常**：记录详细日志，便于问题排查
- **网络超时**：提供重试机制和降级处理

### 3. 性能优化建议
- **缓存机制**：利用状态缓存管理器减少重复验证
- **异步处理**：使用异步方法避免UI线程阻塞
- **批量更新**：批量更新UI状态，减少界面刷新次数

## 扩展开发指南

### 添加新的操作类型
1. 在`MenuItemEnums`中添加新的操作枚举值
2. 在`GlobalStateRulesManager`的操作分类常量中添加相应分类
3. 在状态类型的操作权限规则中添加新操作的权限配置
4. 在UI层添加相应的按钮和处理逻辑

### 自定义状态类型
1. 定义新的状态枚举类型
2. 在`GlobalStateRulesManager`中添加状态转换规则
3. 添加UI按钮规则配置
4. 添加操作权限规则配置
5. 在`UnifiedStateManager`的状态类型识别逻辑中添加新类型支持

### 自定义验证逻辑
1. 使用`GlobalStateRulesManager.RegisterCustomHandler`注册自定义处理器
2. 在处理器中实现特定的业务逻辑
3. 确保处理器返回正确的目标状态值

## 常见问题解答

### Q: 为什么有些操作始终允许？
A: 查询、打印、导出等操作设计为始终允许，确保用户可以随时查看和备份数据。

### Q: 如何修改提交后的修改权限？
A: 通过设置全局提交修改模式来控制：`GlobalStateRulesManager.Instance.SetSubmitModifyRuleMode(mode);`

### Q: 状态转换验证失败如何处理？
A: 系统会返回详细的错误消息，UI层应该显示友好的提示信息，指导用户进行正确的操作。

### Q: 如何添加新的业务状态类型？
A: 参考扩展开发指南，定义新的状态枚举并配置相应的规则。

## 版本历史

- **V1.0**：初始版本，实现基础的操作分类和权限验证
- **V2.0**：优化UI层集成，增强用户体验
- **V3.0**：添加自定义处理器支持，提高扩展性
- **V4.0**：完善文档和最佳实践指南