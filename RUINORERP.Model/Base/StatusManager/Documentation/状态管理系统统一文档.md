# RUINOR ERP 状态管理系统统一文档

## 文档概述

本文档是RUINORERP状态管理系统的完整技术文档,整合了状态管理的设计、实现、使用指南和最佳实践。

**版本信息**:
- **文档版本**: V5.0 (2026-01-25)
- **系统版本**: V4.1
- **最后更新**: 2026年1月25日

## 目录

1. [系统概述](#系统概述)
2. [设计目标](#设计目标)
3. [状态类型系统](#状态类型系统)
4. [核心架构](#核心架构)
5. [状态转换规则](#状态转换规则)
6. [操作分类与权限验证](#操作分类与权限验证)
7. [UI集成机制](#ui集成机制)
8. [使用指南](#使用指南)
9. [最佳实践](#最佳实践)
10. [常见问题](#常见问题)

---

## 系统概述

### 核心功能

RUINORERP状态管理系统是一个企业级的状态管理框架,提供:

- **统一状态管理**: 集中管理所有实体的状态转换和验证
- **规则化配置**: 支持可配置的状态转换规则和UI控制规则
- **事件驱动**: 基于事件的UI状态同步机制
- **高性能缓存**: 多层缓存优化系统性能
- **扩展性设计**: 支持自定义状态类型和验证逻辑

### 设计理念

**核心理念**: 状态管理是统一的、规则化的,而不是分散在各个业务模块中。

1. **状态与业务分离**: 状态的验证和转换在状态管理系统中完成,与具体单据业务的数据验证无关
2. **底层控制**: 所有状态控制和管理在底层定义好,业务类不负责状态验证和转换
3. **基类负责**: 实体的状态保存和加载由基类(BaseEntity)负责
4. **特殊扩展**: 通过注册等扩展机制支持特殊情况

### 系统特点

1. **单例模式**: GlobalStateRulesManager确保全局唯一实例
2. **线程安全**: 使用Lazy<T>实现线程安全的延迟初始化
3. **向后兼容**: 保留原有接口,现有代码无需修改
4. **易于扩展**: 提供清晰的接口,方便添加新的规则类型
5. **职责分离**: 状态管理只控制按钮Enabled状态,Visible由权限系统管理

---

## 设计目标

### 状态管理场景

用户在单据录入、修改、保存、提交、审核时,需要根据当前状态进行判断和处理。

**重要设计原则**:

1. **互斥性**: DataStatus和业务性状态(多种枚举)不会在同一个单据中同时存在
2. **共存性**: ActionStatus(操作性状态)可以与其他状态同时存在
3. **审核状态**: 单据包含ApprovalStatus和ApprovalResults字段

### 核心目标

1. **状态一致性**: 确保状态的一致性和准确性
2. **统一管理**: 提供统一的状态管理接口
3. **灵活性**: 支持不同业务模块的状态定义和转换
4. **高性能**: 优化状态管理系统的性能和资源利用率
5. **可维护性**: 集中管理所有状态相关逻辑
6. **降低复杂度**: 将状态逻辑从业务类中分离

### 架构设计原则

1. **单一职责**: 每个类只负责单一功能
2. **开放封闭**: 对扩展开放,对修改封闭
3. **依赖倒置**: 依赖抽象而非具体实现
4. **事件驱动**: 采用事件驱动模式,减少模块间直接依赖
5. **异常隔离**: 单个订阅者的异常不影响整体

### 技术设计原则

1. **松耦合**: 状态管理组件与业务组件解耦
2. **依赖注入**: 通过IoC容器管理组件生命周期
3. **反射优化**: 使用缓存机制优化反射性能
4. **异步支持**: 支持异步状态转换操作
5. **异常处理**: 提供完善的异常处理和恢复机制

---

## 状态类型系统

### 1. 数据性状态 (DataStatus)

表示实体的数据生命周期状态,所有实体共用的基础状态。

```csharp
public enum DataStatus
{
    草稿 = 0,   // 新创建但未提交的数据
    新建 = 1,   // 已提交但未确认的数据
    确认 = 2,   // 已确认但未完成的数据
    完结 = 3,   // 已完成的数据
    作废 = 4,   // 已作废的数据
}
```

**特点**:
- 线性流程: 通常遵循 草稿→新建→确认→完结 的流程
- 可逆性: 作废状态可以重新激活为草稿
- 业务无关: 适用于所有实体类型

### 2. 操作性状态 (ActionStatus)

表示用户对实体的操作状态,反映当前正在执行的操作。

```csharp
public enum ActionStatus
{
    无操作 = 0,  // 默认状态,未进行任何操作
    新增 = 1,    // 用户正在创建新记录
    修改 = 2,    // 用户正在修改现有记录
    删除 = 3,    // 用户正在删除记录
    加载 = 4,    // 系统正在加载数据
    复制 = 5,    // 用户正在复制现有记录
}
```

**特点**:
- UI行为控制: 为UI层提供操作状态信息
- 互不冲突: ActionStatus变更不会触发实体的HasChanged标志
- 可与其他状态共存

**状态转换规则**:
- 无操作 → 新增/修改/删除/加载/复制: 允许(开始操作)
- 新增/修改/删除/加载/复制 → 无操作: 允许(操作完成/取消)
- 其他直接转换: 不推荐,应通过无操作状态过渡

### 3. 业务性状态 (BusinessStatus)

表示实体的业务流程状态,由具体业务模块定义。

#### 预付款状态 (PrePaymentStatus)

```csharp
public enum PrePaymentStatus
{
    草稿 = 1,       // 初始状态
    待审核 = 2,     // 提交后等待审核
    已生效 = 3,     // 审核通过
    待核销 = 4,     // 支付完成,等待核销
    部分核销 = 5,   // 部分金额核销
    全额核销 = 6,   // 全额核销
    已结案 = 7,     // 结案(包含部分/全额退款)
}
```

#### 应收应付状态 (ARAPStatus)

```csharp
public enum ARAPStatus
{
    草稿 = 1,       // 初始状态
    待审核 = 2,     // 提交后等待审核
    待支付 = 3,     // 审核通过,待支付
    部分支付 = 4,   // 部分金额支付
    全部支付 = 5,   // 全部支付
    坏账 = 6,       // 标记为坏账
    已冲销 = 7,     // 冲销处理
}
```

#### 付款状态 (PaymentStatus)

```csharp
public enum PaymentStatus
{
    草稿 = 1,       // 初始状态
    待审核 = 2,     // 提交后等待审核
    已支付 = 3,     // 支付完成
}
```

#### 对账状态 (StatementStatus)

```csharp
public enum StatementStatus
{
    草稿 = 1,       // 初始状态
    新建 = 2,       // 已创建对账单
    已发送 = 3,     // 已发送给客户
    已确认 = 4,     // 客户确认对账
    已结清 = 5,     // 完全结清
    部分结算 = 6,   // 部分金额结算
    已作废 = 7,     // 流程终止
}
```

**特点**:
- 业务相关: 与具体业务紧密相关
- 动态性: 可以动态添加和修改
- 可扩展: 支持添加新的业务状态类型

### 4. 审核状态

```csharp
[Flags]
public enum ApprovalStatus
{
    未审核 = 0,
    已审核 = 1,
    驳回 = 2,
}

bool ApprovalResults : true/false
```

**说明**:
- 支持多级审核、多人审核(如会签、分步审核)
- 单级审核时使用简单版本
- 财务模块同样支持多级审核

### 5. 统一实体状态 (EntityStatus)

EntityStatus类是状态管理系统的核心类,统一管理实体的所有状态信息。

```csharp
public class EntityStatus : IEquatable<EntityStatus>, ICloneable
{
    private DataStatus? _dataStatus;              // 数据状态
    private ActionStatus _actionStatus;            // 操作状态
    private readonly Dictionary<Type, object> _businessStatuses;  // 业务状态字典
    private ApprovalStatus _approvalStatus;         // 审批状态
    private readonly List<ApprovalResult> _approvalResults; // 审批结果列表
    private readonly Dictionary<string, object> _stateProperties; // 动态状态属性
}
```

**关键特性**:

1. **状态存储**:
   - `_dataStatus`: 快速访问的数据状态字段
   - `_actionStatus`: 操作状态字段
   - `_businessStatuses`: 业务状态字典,支持多种类型
   - `_stateProperties`: 动态状态属性字典

2. **状态互斥机制**:
   - DataStatus与业务性状态互斥,设置DataStatus时会清除所有业务性状态
   - 设置业务性状态时会清除DataStatus状态
   - 操作状态(ActionStatus)可与其他状态共存

3. **关键方法**:
   - `GetDataStatus()`: 获取数据状态
   - `GetActionStatus()`: 获取操作状态
   - `GetBusinessStatus<T>()`: 获取指定类型的业务状态
   - `SetDataStatus()`: 设置数据状态
   - `SetActionStatus()`: 设置操作状态
   - `SetBusinessStatus<T>()`: 设置指定类型的业务状态
   - `CanTransitionTo()`: 验证是否可以转换到指定状态
   - `Clone()`: 克隆当前状态

---

## 核心架构

### 核心组件

#### 1. GlobalStateRulesManager

全局状态规则管理器,单例模式,统一管理所有状态转换规则和UI控件规则。

**主要功能**:
- 状态转换规则管理
- UI按钮规则管理
- 操作权限规则管理
- 全局提交修改模式控制

**使用示例**:

```csharp
// 获取全局规则管理器实例
var rulesManager = GlobalStateRulesManager.Instance;

// 验证状态转换是否合法
bool canTransition = rulesManager.IsTransitionAllowed(DataStatus.草稿, DataStatus.新建);

// 获取可转换的状态列表
var availableTransitions = rulesManager.GetAvailableTransitions(DataStatus.草稿);

// 添加自定义状态转换规则
rulesManager.AddTransitionRule(DataStatus.草稿, DataStatus.新建, DataStatus.作废);

// 获取UI按钮规则
var buttonRules = rulesManager.GetButtonRules(DataStatus.草稿);

// 添加自定义按钮规则(只控制Enabled状态)
rulesManager.AddButtonRule(DataStatus.草稿, "btnCustom", true);

// 设置全局提交修改模式
rulesManager.SetSubmitModifyRuleMode(SubmitModifyRuleMode.严格模式);
```

**初始化方法**:

```csharp
// 方法一: 在应用启动时手动初始化
GlobalRulesInitializer.InitializeGlobalRules();

// 方法二: 使用Microsoft DI容器
services.AddGlobalStateRules();

// 方法三: 使用Autofac容器
builder.AddGlobalStateRules();
```

#### 2. UnifiedStateManager

统一状态管理器,是整个状态管理系统的核心实现类。

**核心功能**:
- 状态获取和设置
- 状态转换和验证
- 操作权限检查
- UI状态管理
- 缓存管理
- 事件触发

**主要接口**:

```csharp
public interface IUnifiedStateManager
{
    // 状态获取方法
    DataStatus GetDataStatus(object entity);
    ActionStatus GetActionStatus(object entity);
    object GetBusinessStatus(object entity, Type businessStatusType);
    T GetBusinessStatus<T>(object entity) where T : struct, Enum;
    EntityStatus GetEntityStatus(object entity);
    
    // 状态设置方法
    Task<bool> SetDataStatusAsync(object entity, DataStatus status, string reason = null);
    Task<bool> SetActionStatusAsync(object entity, ActionStatus status, string reason = null);
    Task<bool> SetBusinessStatusAsync(object entity, object businessStatus, string reason = null);
    Task<bool> SetBusinessStatusAsync<T>(object entity, T status, string reason = null) where T : struct, Enum;
    
    // 状态转换方法
    Task<StateTransitionResult> TransitionDataStatusAsync(object entity, DataStatus toStatus, string reason = null);
    Task<StateTransitionResult> TransitionActionStatusAsync(object entity, ActionStatus toStatus, string reason = null);
    Task<StateTransitionResult> TransitionBusinessStatusAsync(object entity, object toStatus, string reason = null);
    
    // 状态验证方法
    Task<StateTransitionResult> CanTransitionDataStatusAsync(object entity, DataStatus toStatus);
    Task<StateTransitionResult> CanTransitionActionStatusAsync(object entity, ActionStatus toStatus);
    Task<StateTransitionResult> CanTransitionBusinessStatusAsync(object entity, object toStatus);
    
    // 操作权限方法
    (bool CanExecute, string Message) CanExecuteActionWithMessage(object entity, MenuItemEnums action);
    IEnumerable<MenuItemEnums> GetAvailableActions(object entity);
    
    // 缓存管理方法
    void ClearCache();
    void ClearCache(object entity);
    void ClearCache(Type entityType);
    
    // 事件
    event EventHandler<StateTransitionEventArgs> StateTransitioning;
    event EventHandler<StateTransitionEventArgs> StateTransitioned;
    event EventHandler<StateTransitionEventArgs> StateTransitionFailed;
}
```

#### 3. StatusCacheManager

状态缓存管理器,提供多层次的缓存功能。

**缓存类型**:
- 状态转换规则缓存
- UI控件状态缓存
- 操作权限缓存
- 反射结果缓存

**使用示例**:

```csharp
var cacheManager = StatusCacheManager.Instance;

// 获取缓存
var cachedStatus = cacheManager.Get<DataStatus>("entity_123");
if (cachedStatus != null)
{
    // 使用缓存
}

// 设置缓存
cacheManager.Set("entity_123", DataStatus.新建);

// 清除缓存
cacheManager.ClearCache(entity);
cacheManager.ClearCacheAll();
```

#### 4. 辅助类

##### StateTransitionResult

状态转换结果类,封装状态转换的结果信息。

```csharp
public class StateTransitionResult
{
    public ResultType ResultType { get; }  // 结果类型
    public bool IsSuccess { get; }         // 是否成功
    public bool CanTransition { get; }     // 是否可转换
    public string Message { get; }         // 消息
    public Exception Exception { get; }   // 异常信息
    public object FromStatus { get; }      // 源状态
    public object ToStatus { get; }        // 目标状态
}
```

##### StateTransitionEventArgs

状态转换事件参数类,用于状态转换事件。

```csharp
public class StateTransitionEventArgs : EventArgs
{
    public object Entity { get; }
    public Type EntityType { get; }
    public object EntityId { get; }
    public Type StatusType { get; }
    public object FromStatus { get; }
    public object ToStatus { get; }
    public string Reason { get; }
    public string UserId { get; }
    public DateTime TransitionTime { get; }
}
```

---

## 状态转换规则

### DataStatus转换规则

```csharp
草稿 -> [新建, 作废]
新建 -> [确认, 作废]
确认 -> [完结, 作废]
完结 -> []
作废 -> [草稿]
```

### ActionStatus转换规则

```csharp
无操作 -> [新增, 修改, 删除, 加载, 复制]
新增 -> [修改, 删除, 无操作]
修改 -> [修改, 删除, 无操作]
删除 -> [新增, 无操作]
加载 -> [修改, 删除, 复制, 无操作]
复制 -> [新增, 修改, 删除, 无操作]
```

### 业务状态转换规则

每种业务状态类型都有独立的转换规则,例如:

**PrePaymentStatus转换规则**:
```csharp
草稿 -> [待审核, 作废]
待审核 -> [已生效, 草稿]
已生效 -> [待核销, 已结案]
待核销 -> [部分核销, 全额核销, 已生效]
部分核销 -> [待核销, 全额核销, 已结案]
全额核销 -> [已结案]
已结案 -> []
```

### 自定义规则

支持通过代码动态添加状态转换规则:

```csharp
// 添加自定义状态转换规则
var rulesManager = GlobalStateRulesManager.Instance;
rulesManager.AddTransitionRule(CustomStatus.待处理, CustomStatus.处理中, CustomStatus.已取消);
rulesManager.AddTransitionRule(CustomStatus.处理中, CustomStatus.已完成, CustomStatus.已取消);
```

---

## 操作分类与权限验证

### 操作分类

RUINORERP状态管理系统将操作分为两大类:

#### 1. 状态转换类操作

具有明确目标状态的操作,会改变单据的业务状态。

**包含操作**:
- **提交**: 将单据从草稿状态转换为新建状态
- **审核**: 将单据从新建状态转换为确认状态
- **反审**: 将单据从确认状态转换回新建状态
- **结案**: 将单据转换为完结状态
- **反结案**: 将单据从完结状态转换回新建状态
- **作废**: 将单据转换为作废状态

**权限验证策略**:
1. 状态转换规则验证
2. 操作权限规则验证
3. 目标状态冲突检查

**验证流程**:
```csharp
var result = StateManager.CanExecuteActionWithMessage(entity, MenuItemEnums.提交);
// 验证流程:
// 1. 获取当前状态
// 2. 映射目标状态(提交->新建)
// 3. 验证状态转换规则(草稿->新建是否允许)
// 4. 验证操作权限规则(草稿状态是否允许提交)
// 5. 返回验证结果和详细消息
```

#### 2. 无目标状态操作

不改变单据业务状态的操作,仅基于当前状态判断权限。

**包含操作**:
- **新增**: 创建新单据(始终允许)
- **修改**: 编辑当前单据内容
- **删除**: 删除当前单据
- **保存**: 保存单据数据
- **查询**: 查看单据信息(始终允许)
- **打印**: 打印单据(始终允许)
- **导出**: 导出单据数据(始终允许)

**权限验证策略**:
1. 当前状态权限验证
2. 终态检查(修改、删除、保存操作)
3. 提交后修改规则(根据全局模式设置)

**验证流程**:
```csharp
var result = StateManager.CanExecuteActionWithMessage(entity, MenuItemEnums.修改);
// 验证流程:
// 1. 获取当前状态
// 2. 验证操作权限规则(当前状态是否允许修改)
// 3. 检查是否为终态状态(完结/作废状态不允许修改)
// 4. 检查提交后修改规则(根据全局模式设置)
// 5. 返回验证结果和详细消息
```

### 全局规则配置

#### 提交修改模式

系统支持两种提交修改模式:

**严格模式**:
- 单据提交后不允许修改
- 适用于需要严格流程控制的业务场景
- 设置方法: `GlobalStateRulesManager.Instance.SetSubmitModifyRuleMode(SubmitModifyRuleMode.严格模式);`

**灵活模式**:
- 单据提交后仍然允许修改
- 适用于需要灵活处理的业务场景
- 设置方法: `GlobalStateRulesManager.Instance.SetSubmitModifyRuleMode(SubmitModifyRuleMode.灵活模式);`

---

## UI集成机制

### 控件状态同步

#### 按钮状态管理

1. **职责分离**:
   - 状态管理系统只控制按钮的可用性(Enabled状态)
   - 按钮可见性(Visible)完全由权限系统管理
   - 消除了状态管理和权限管理在按钮控制上的职责重叠

2. **数据结构简化**:
   - GetButtonRules方法返回值从`Dictionary<string, (bool Enabled, bool Visible)>`简化为`Dictionary<string, bool>`
   - AddButtonRule方法参数从`(buttonName, enabled, visible)`简化为`(buttonName, enabled)`

3. **UI状态获取**:
```csharp
// 获取特定状态的按钮规则
var buttonRules = GlobalStateRulesManager.Instance.GetButtonRules(DataStatus.草稿);
// buttonRules 是 Dictionary<string, bool>，key是按钮名称,value是Enabled状态
```

#### UI层集成流程

1. **状态变更事件监听**:
```csharp
entity.StatusChanged += OnEntityStatusChanged;

private void OnEntityStatusChanged(object sender, StatusChangedEventArgs e)
{
    // 更新UI按钮状态
    UpdateButtonStates();
}
```

2. **UI状态获取**:
```csharp
// 获取所有按钮状态
var buttonStates = StateManager.GetUIControlStates(entity);

// 更新各个按钮的Enabled状态
foreach (var kvp in buttonStates)
{
    var button = FindControl(kvp.Key);
    if (button != null)
    {
        button.Enabled = kvp.Value;
    }
}
```

3. **操作权限验证**:
```csharp
// 保存操作权限验证示例
case MenuItemEnums.保存:
    var canSave = StateManager.CanExecuteActionWithMessage(EditEntity, MenuItemEnums.保存);
    if (!canSave.CanExecute)
    {
        MessageBox.Show(canSave.Message, "保存权限验证", MessageBoxButtons.OK, MessageBoxIcon.Warning);
        return;
    }
    // 继续执行保存操作
    break;
```

### 事件系统

#### 事件类型

1. **状态转换前事件**: 在状态转换前触发
2. **状态转换后事件**: 在状态转换后触发
3. **状态转换失败事件**: 在状态转换失败时触发

#### 事件处理

```csharp
// 订阅状态转换事件
stateManager.StateTransitioning += (sender, e) =>
{
    Console.WriteLine($"状态转换前: {e.EntityType.Name} 从 {e.FromStatus} 转换到 {e.ToStatus}");
    // 可以在这里添加转换前的逻辑
};

stateManager.StateTransitioned += (sender, e) =>
{
    Console.WriteLine($"状态转换后: {e.EntityType.Name} 从 {e.FromStatus} 转换到 {e.ToStatus}");
    // 更新UI、发送通知等
};

stateManager.StateTransitionFailed += (sender, e) =>
{
    Console.WriteLine($"状态转换失败: {e.Message}");
    // 错误处理、日志记录等
};
```

### 统一事件触发机制(V4.1版本)

**重要改进**: V4.1版本实现了统一的事件触发机制,所有状态变更必须通过状态管理器统一触发。

1. **重构BaseEntity.OnStatusChanged方法**:
   - 移除降级处理逻辑
   - 强制使用状态管理器触发事件
   - 统一事件触发路径

2. **增强错误处理**:
   - 异常不再被静默捕获
   - 确保状态管理失败时能被上层调用者感知

3. **异常隔离机制**:
   - 单个订阅者的异常不会影响整体
   - 使用try-catch包装每个事件处理器

---

## 使用指南

### 基本配置

#### 服务注册

```csharp
// 使用Microsoft DI容器
services.AddSingleton<GlobalStateRulesManager>();
services.AddSingleton<StatusCacheManager>();
services.AddSingleton<IUnifiedStateManager, UnifiedStateManager>();

// 或者使用扩展方法
services.AddGlobalStateRules();
services.AddStateManager();
```

#### 初始化

```csharp
// 在应用启动时初始化全局规则
GlobalRulesInitializer.InitializeGlobalRules();
```

### 状态管理操作示例

#### 获取实体状态

```csharp
// 获取实体的数据状态
var dataStatus = stateManager.GetDataStatus(entity);

// 获取实体的操作状态
var actionStatus = stateManager.GetActionStatus(entity);

// 获取实体的业务状态
var businessStatus = stateManager.GetBusinessStatus<PrePaymentStatus>(entity);

// 获取实体的完整状态
var entityStatus = stateManager.GetEntityStatus(entity);
```

#### 设置实体状态

```csharp
// 设置实体的数据状态
var success = await stateManager.SetDataStatusAsync(entity, DataStatus.确认, "确认数据");

// 设置实体的操作状态
var success = await stateManager.SetActionStatusAsync(entity, ActionStatus.修改, "修改数据");

// 设置实体的业务状态
var success = await stateManager.SetBusinessStatusAsync(entity, PrePaymentStatus.已生效, "审核通过");
```

#### 状态转换

```csharp
// 转换实体的数据状态
var result = await stateManager.TransitionDataStatusAsync(entity, DataStatus.完结, "完成处理");
if (!result.IsSuccess)
{
    Console.WriteLine($"状态转换失败: {result.Message}");
}

// 转换实体的业务状态
var result = await stateManager.TransitionBusinessStatusAsync(entity, PrePaymentStatus.已生效, "审核通过");
```

#### 状态验证

```csharp
// 验证数据状态转换
var checkResult = await stateManager.CanTransitionDataStatusAsync(entity, DataStatus.完结);
if (checkResult.CanTransition)
{
    // 可以转换
}
else
{
    // 不能转换
    var reason = checkResult.Message;
}
```

#### 操作权限检查

```csharp
// 检查是否可以执行某个操作
var canExecute = stateManager.CanExecuteActionWithMessage(entity, MenuItemEnums.保存);
if (!canExecute.CanExecute)
{
    MessageBox.Show(canExecute.Message, "权限验证", MessageBoxButtons.OK, MessageBoxIcon.Warning);
    return;
}

// 获取可执行的操作列表
var availableActions = stateManager.GetAvailableActions(entity);
```

### UI层集成示例

```csharp
public class BaseBillEditGeneric : Form
{
    private IUnifiedStateManager _stateManager;
    
    public BaseBillEditGeneric()
    {
        InitializeComponent();
        
        // 初始化状态管理器
        _stateManager = GlobalStateRulesManager.Instance;
    }
    
    // 绑定数据
    public void BindData(TEntity entity, ActionStatus actionStatus)
    {
        CurrentEntity = entity;
        CurrentActionStatus = actionStatus;
        
        // 订阅状态变更事件
        entity.StatusChanged += OnEntityStatusChanged;
        
        // 更新UI状态
        UpdateUIState();
    }
    
    // 状态变更事件处理
    private void OnEntityStatusChanged(object sender, StatusChangedEventArgs e)
    {
        if (InvokeRequired)
        {
            Invoke(new Action(() => UpdateUIState()));
        }
        else
        {
            UpdateUIState();
        }
    }
    
    // 更新UI状态
    private void UpdateUIState()
    {
        if (CurrentEntity == null) return;
        
        // 获取所有按钮状态
        var buttonStates = _stateManager.GetUIControlStates(CurrentEntity);
        
        // 更新各个按钮的Enabled状态
        foreach (var kvp in buttonStates)
        {
            var button = FindControl(kvp.Key);
            if (button != null)
            {
                button.Enabled = kvp.Value;
            }
        }
    }
    
    // 保存操作
    private async void btnSave_Click(object sender, EventArgs e)
    {
        // 验证保存权限
        var canSave = _stateManager.CanExecuteActionWithMessage(CurrentEntity, MenuItemEnums.保存);
        if (!canSave.CanExecute)
        {
            MessageBox.Show(canSave.Message, "保存权限验证", MessageBoxButtons.OK, MessageBoxIcon.Warning);
            return;
        }
        
        // 设置操作状态
        await _stateManager.SetActionStatusAsync(CurrentEntity, ActionStatus.修改, "修改数据");
        
        // 执行保存操作
        await SaveDataAsync();
        
        // 恢复无操作状态
        await _stateManager.SetActionStatusAsync(CurrentEntity, ActionStatus.无操作, "操作完成");
    }
    
    // 提交操作
    private async void btnSubmit_Click(object sender, EventArgs e)
    {
        // 验证提交权限
        var canSubmit = _stateManager.CanExecuteActionWithMessage(CurrentEntity, MenuItemEnums.提交);
        if (!canSubmit.CanExecute)
        {
            MessageBox.Show(canSubmit.Message, "提交权限验证", MessageBoxButtons.OK, MessageBoxIcon.Warning);
            return;
        }
        
        // 执行状态转换
        var result = await _stateManager.TransitionDataStatusAsync(CurrentEntity, DataStatus.新建, "提交单据");
        if (!result.IsSuccess)
        {
            MessageBox.Show(result.Message, "提交失败", MessageBoxButtons.OK, MessageBoxIcon.Error);
            return;
        }
        
        // 更新UI状态
        UpdateUIState();
        
        MessageBox.Show("提交成功", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
    }
}
```

---

## 最佳实践

### 状态定义

1. **使用枚举**: 状态应使用枚举定义,避免使用魔术数字或字符串
2. **有意义的名称**: 状态名称应具有明确的业务含义
3. **避免状态爆炸**: 避免定义过多不必要的状态
4. **文档化**: 为每个状态提供清晰的文档说明

### 状态转换规则

1. **明确规则**: 状态转换规则应明确、无歧义
2. **最小权限**: 默认情况下,状态转换应被禁止,只有明确允许的转换才能执行
3. **规则集中管理**: 所有状态转换规则应集中管理,避免散布在业务代码中
4. **规则可配置**: 状态转换规则应可配置,支持动态修改

### 状态验证

1. **多层验证**: 实现多层验证机制,包括基础验证、业务验证和权限验证
2. **验证前置**: 在状态转换前进行验证,避免无效转换
3. **验证结果明确**: 验证结果应明确指出是否通过及原因
4. **验证可扩展**: 支持添加自定义验证逻辑

### 缓存策略

1. **合理缓存**: 对频繁访问的状态信息进行缓存
2. **缓存更新**: 状态变更时及时更新缓存
3. **缓存过期**: 设置合理的缓存过期时间
4. **缓存监控**: 监控缓存使用情况,优化缓存策略

### UI集成

1. **职责分离**: 状态管理只控制Enabled,Visible由权限系统管理
2. **事件驱动**: 使用事件驱动的UI状态更新机制
3. **异步处理**: 使用异步方法避免UI线程阻塞
4. **用户反馈**: 提供友好的用户反馈和错误提示

### 异常处理

1. **异常捕获**: 捕获状态管理过程中的异常
2. **异常记录**: 记录异常信息,便于问题排查
3. **异常恢复**: 提供异常恢复机制
4. **用户友好**: 向用户提供友好的错误提示

---

## 常见问题

### Q: 为什么有些操作始终允许?

A: 查询、打印、导出等操作设计为始终允许,确保用户可以随时查看和备份数据。

### Q: 如何修改提交后的修改权限?

A: 通过设置全局提交修改模式来控制:
```csharp
GlobalStateRulesManager.Instance.SetSubmitModifyRuleMode(SubmitModifyRuleMode.严格模式);
```

### Q: 如何添加新的业务状态类型?

A: 步骤如下:

1. 定义新的业务状态枚举:
```csharp
public enum CustomBusinessStatus
{
    待处理 = 1,
    处理中 = 2,
    已完成 = 3,
    已取消 = 4
}
```

2. 在GlobalStateRulesManager中添加状态转换规则:
```csharp
var rulesManager = GlobalStateRulesManager.Instance;
rulesManager.AddTransitionRule(CustomBusinessStatus.待处理, CustomBusinessStatus.处理中, CustomBusinessStatus.已取消);
rulesManager.AddTransitionRule(CustomBusinessStatus.处理中, CustomBusinessStatus.已完成, CustomBusinessStatus.已取消);
```

3. 添加UI按钮规则:
```csharp
rulesManager.AddButtonRule(CustomBusinessStatus.待处理, "btnProcess", true);
rulesManager.AddButtonRule(CustomBusinessStatus.处理中, "btnComplete", true);
```

4. 添加操作权限规则:
```csharp
var customActions = new List<MenuItemEnums> { MenuItemEnums.提交, MenuItemEnums.审核 };
rulesManager.AddActionPermissionRule(CustomBusinessStatus.待处理, customActions);
```

5. 在UnifiedStateManager的状态类型识别逻辑中添加新类型支持

### Q: 状态转换验证失败如何处理?

A: 系统会返回详细的错误消息,UI层应该显示友好的提示信息:
```csharp
var result = await stateManager.TransitionDataStatusAsync(entity, DataStatus.完结, "完成处理");
if (!result.IsSuccess)
{
    MessageBox.Show(result.Message, "状态转换失败", MessageBoxButtons.OK, MessageBoxIcon.Warning);
    return;
}
```

### Q: 如何优化状态管理性能?

A: 可以通过以下方式优化:

1. **启用缓存**: 确保缓存机制已启用
2. **批量操作**: 对于批量状态更新,使用批量操作方法
3. **避免频繁查询**: 缓存状态信息,避免重复查询
4. **异步操作**: 使用异步方法,避免阻塞

### Q: DataStatus和业务状态为什么互斥?

A: 这是系统的设计决定:
- DataStatus表示数据生命周期状态,适用于所有实体
- 业务状态表示具体业务流程状态,与特定业务相关
- 互斥设计避免了状态冲突和复杂性

### Q: ActionStatus与其他状态为什么可以共存?

A: ActionStatus表示用户当前的操作状态,如"正在新增"、"正在修改",它反映了UI层的操作意图,而不是实体的业务状态,因此可以与其他状态共存。

---

## 版本历史

### V5.0 (2026-01-25)
- 统合5个文档为一个完整文档
- 删除过时信息
- 完善架构说明
- 补充使用示例
- 优化文档结构

### V4.1 (2024)
- 修复状态验证逻辑
- 统一事件处理机制
- 增强参数校验
- 改进错误处理
- UI按钮规则优化(职责分离)

### V4.0 (2024-04-15)
- 全面重构状态管理系统
- 实现统一状态定义和规则化状态转换
- 优化状态验证机制
- 增加缓存支持
- 提高扩展性

### V3.5 (2024-02-10)
- 完善状态转换规则
- 增强扩展性

### V3.0 (2023-12-20)
- 优化状态验证机制
- 增加缓存支持

### V2.0 (2023-09-15)
- 重构状态管理架构
- 引入状态转换规则

### V1.0 (2023-06-01)
- 初始版本
- 实现基本状态管理功能

---

## 附录

### A. 状态类型映射

| 状态类型 | 说明 | 属性名 |
|---------|------|--------|
| DataStatus | 数据生命周期状态 | DataStatus |
| ActionStatus | 操作状态 | ActionStatus |
| PrePaymentStatus | 预付款状态 | PrePaymentStatus |
| ARAPStatus | 应收应付状态 | ARAPStatus |
| PaymentStatus | 付款状态 | PaymentStatus |
| StatementStatus | 对账状态 | StatementStatus |

### B. 操作与状态映射

| 操作 | 目标状态 | 操作类型 |
|------|---------|---------|
| 新增 | 无 | 无目标状态操作 |
| 修改 | 无 | 无目标状态操作 |
| 删除 | 无 | 无目标状态操作 |
| 保存 | 无 | 无目标状态操作 |
| 提交 | 新建 | 状态转换类操作 |
| 审核 | 确认 | 状态转换类操作 |
| 反审 | 新建 | 状态转换类操作 |
| 结案 | 完结 | 状态转换类操作 |
| 反结案 | 新建 | 状态转换类操作 |
| 作废 | 作废 | 状态转换类操作 |

### C. 文件结构

```
RUINORERP.Model/Base/StatusManager/
├── Documentation/                    # 文档目录
│   ├── 状态管理系统统一文档.md      # 本文档
│   └── ...
├── GlobalStateRulesManager.cs       # 全局规则管理器
├── GlobalStateInitializer.cs        # 全局初始化器
├── StatusCacheManager.cs            # 缓存管理器
├── UnifiedStateManager.cs           # 统一状态管理器
├── IUnifiedStateManager.cs          # 统一状态管理器接口
├── EntityStatus.cs                  # 实体状态类
├── StateTransitionResult.cs         # 状态转换结果
├── StateTransitionEventArgs.cs      # 状态转换事件参数
└── ...
```

---

**文档维护**: 本文档由RUINORERP开发团队维护,如有疑问或建议请联系开发团队。
