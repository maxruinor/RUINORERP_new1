# 序号生成机制优化指南

## 问题分析

基于对现有代码和数据库数据的分析，发现序号生成机制存在以下问题：

1. **序列键格式不统一**：数据库中存在混合格式的SequenceKey，有些是动态规则（如`DEFAULT_{S:请购单}{D:yyMM}`），有些是直接的业务标识+日期（如`请购单2511`）

2. **键生成逻辑分散**：序列键的生成逻辑不够集中，缺乏统一的规范和清理机制

3. **特殊字符处理不完善**：未对生成的键进行特殊字符处理，可能导致数据库操作问题

4. **重置逻辑冗余**：时间重置逻辑与键生成混合，不够清晰

## 优化措施

### 1. 统一序列键格式

**主要修改文件**：`DatabaseSequenceParameter.cs`

- 创建了`GenerateStandardSequenceKey`私有方法，集中处理序列键生成逻辑
- 所有序列键都采用`SEQ_`作为固定前缀，便于识别和管理
- 对业务标识部分进行特殊字符清理，确保键的有效性
- 添加了长度限制，避免生成过长的键

### 2. 优化动态键生成逻辑

**主要修改文件**：`DatabaseSequenceService.cs`

- 完善了`GenerateDynamicKey`方法，明确处理NONE重置类型
- 添加了键格式规范化处理，移除或替换特殊字符
- 保持与时间重置功能的兼容性

### 3. 增强错误处理和日志记录

- 添加了更完善的空值检查和异常处理
- 提供详细的日志记录，便于调试和问题排查
- 在关键节点添加了警告信息

## 使用说明

### 标准格式示例

优化后的序号生成支持以下标准格式：

#### 1. 基础序号格式
```
{S:业务类型前缀}{DB:业务标识/0000}
```

示例：
```
{S:PO}{DB:PURCHASE_ORDER/0000}  // 生成 PO0001, PO0002...
```

#### 2. 带日期的序号格式
```
{S:业务类型前缀}{D:yyyyMM}{DB:业务标识/0000}
```

示例：
```
{S:SO}{D:yyyyMM}{DB:SALES_ORDER/0000}  // 生成 SO2025110001, SO2025110002...
```

#### 3. 按时间重置的序号格式
```
{S:业务类型前缀}{D:yyyyMM}{DB:业务标识/0000/monthly}
```

示例：
```
{S:INV}{D:yyyyMM}{DB:INVOICE/0000/monthly}  // 每月重置序号，生成 INV2025110001, 下月从 INV2025120001 开始
```

### 重置类型说明

- **None**：序号持续递增，不自动重置
- **Daily**：每天重置序号从1开始
- **Monthly**：每月重置序号从1开始
- **Yearly**：每年重置序号从1开始

## 数据库迁移建议

对于已有的序列数据，建议进行以下清理：

1. 将所有直接使用业务标识+日期格式的键（如`请购单2511`）迁移到新的标准格式
2. 保留原有的`DEFAULT_{S:xxx}{D:yyMM}`格式的键，但在后续使用中逐步替换为新格式
3. 可以编写一个迁移脚本，将现有数据映射到新的格式，并保留当前序号值

## 注意事项

1. 新的键生成机制会自动清理特殊字符，将非字母、数字、下划线和中文的字符替换为下划线
2. 键长度限制为200个字符，超过此限制会自动生成基于时间戳的默认键
3. 对于嵌套表达式处理，保持了与原有逻辑的兼容性

## 性能优化

- 保留了原有的内存缓存机制，减少数据库访问
- 批量更新队列和后台刷新任务继续有效
- 序列键生成逻辑的优化不会对性能产生负面影响，反而通过更规范的处理提高了可靠性