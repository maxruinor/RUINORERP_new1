using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using RUINORERP.PacketSpec.Commands;
using RUINORERP.PacketSpec.Commands.Message;
using RUINORERP.PacketSpec.Models.Responses;
using RUINORERP.PacketSpec.Serialization;
using RUINORERP.Server.Network.Models;
using RUINORERP.Server.Network.Interfaces.Services;
using SuperSocket.Server.Abstractions.Session;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.DependencyInjection;
using RUINORERP.PacketSpec;
using RUINORERP.PacketSpec.Enums.Core;
using ICommand = RUINORERP.PacketSpec.Commands.ICommand;
using SuperSocket.Command;
using Azure;
using RUINORERP.PacketSpec.Models.Core;
using RUINORERP.PacketSpec.Commands.Authentication;
using RUINORERP.PacketSpec.Errors;
using RUINORERP.PacketSpec.Core;

namespace RUINORERP.Server.Network.SuperSocket
{
    /// <summary>
    /// 统一的SuperSocket命令适配器
    /// 整合了原有的SimplifiedSuperSocketAdapter、SocketCommand和SuperSocketCommandAdapter的功能
    /// 
    /// 工作流程：
    /// 1. SuperSocket接收到来自客户端的数据包
    /// 2. SuperSocketCommandAdapter.ExecuteAsync方法被调用
    /// 3. 从CommandDispatcher获取已注册的命令类型映射
    /// 4. 根据数据包中的命令ID创建对应的命令实例
    /// 5. 通过CommandDispatcher.DispatchAsync方法分发命令给相应的处理器
    /// 6. 处理结果通过网络返回给客户端
    /// </summary>
    [Command(Key = "SuperSocketCommandAdapter")]
    public class SuperSocketCommandAdapter<TAppSession> : IAsyncCommand<TAppSession, ServerPackageInfo>
        where TAppSession : IAppSession
    {
        private readonly CommandDispatcher _commandDispatcher;
        private readonly ILogger<SuperSocketCommandAdapter> _logger;
        private readonly ICommandFactory _commandFactory;
        private readonly CommandPacketAdapter packetAdapter;
        private ISessionService SessionService => Program.ServiceProvider.GetRequiredService<ISessionService>();
     
  
        /// <summary>
        /// 构造函数
        /// </summary>
        /// <param name="commandDispatcher">命令调度器</param>
        /// <param name="commandFactory">命令工厂</param>
        /// <param name="logger">日志记录器</param>
        public SuperSocketCommandAdapter(
            CommandDispatcher commandDispatcher,
            CommandPacketAdapter _packetAdapter,
            ICommandFactory commandFactory,
            ILogger<SuperSocketCommandAdapter> logger = null)
        {
            packetAdapter = _packetAdapter;
            _commandDispatcher = commandDispatcher;
            _commandFactory = commandFactory;
            _logger = logger;
        }



        /// <summary>
        /// 执行命令
        /// 将SuperSocket的命令调用转换为现有的命令处理系统
        /// </summary>
        /// <param name="session">SuperSocket会话</param>
        /// <param name="package">数据包</param>
        /// <param name="cancellationToken">取消令牌</param>
        /// <returns>执行结果任务</returns>
        public async ValueTask ExecuteAsync(TAppSession session, ServerPackageInfo package, CancellationToken cancellationToken)
        {
            if (package == null)
            {
                _logger?.LogWarning("接收到空的数据包");
                await SendErrorResponseAsync(session, package, UnifiedErrorCodes.System_InternalError, cancellationToken);
                return;
            }

            try
            {
                if (string.IsNullOrEmpty(package.Packet.SessionId))
                {
                    package.Packet.SessionId = session.SessionID;
                }

                // 确保命令调度器已初始化
                if (!_commandDispatcher.IsInitialized)
                {
                    await _commandDispatcher.InitializeAsync(cancellationToken);
                }

                // 获取现有会话信息
                var sessionInfo = SessionService.GetSession(session.SessionID);
                if (sessionInfo == null)
                {
                    // 如果会话不存在，可能是连接已断开或会话已过期
                    await SendErrorResponseAsync(session, package, UnifiedErrorCodes.Auth_SessionExpired, cancellationToken);
                    return;
                }

                // 更新会话的最后活动时间
                sessionInfo.UpdateActivity(); // 使用专门的UpdateActivity方法更新活动时间
                SessionService.UpdateSession(sessionInfo);
                // 同时调用专门的UpdateSessionActivity方法确保活动时间被正确更新
                SessionService.UpdateSessionActivity(session.SessionID);

                // 创建命令对象（第一层解析：基础命令创建）
                var command = packetAdapter.CreateCommand(package.Packet);
                if (command == null)
                {
                    _logger?.LogWarning("无法创建命令对象: CommandId={CommandId}", package.Packet.CommandId);
                    await SendErrorResponseAsync(session, package, UnifiedErrorCodes.Command_NotFound, cancellationToken);
                    return;
                }

                // 第二层解析：命令预解析（获取指令信息，不解析具体业务数据）
                var commandInfo = PreParseCommand(command, package.Packet);
                if (commandInfo == null)
                {
                    _logger?.LogWarning("命令预解析失败: CommandId={CommandId}", package.Packet.CommandId);
                    await SendErrorResponseAsync(session, package, UnifiedErrorCodes.Command_InvalidFormat, cancellationToken);
                    return;
                }

                // 设置命令优先级（基于预解析结果，使用CommandPriority枚举）
                command.Priority = commandInfo.PriorityLevel;

                // 第三层解析：设置基础数据（不解析具体业务内容）
                // 检查是否为泛型BaseCommand<,>类型，如果是则自动设置请求二进制数据
                var commandType = command.GetType();
                if (commandType.IsGenericType &&
                    commandType.GetGenericTypeDefinition() == typeof(BaseCommand<,>))
                {
                    var setRequest = commandType.GetMethod("SetRequestFromBinary");
                    setRequest?.Invoke(command, new object[] { package.Packet.CommandData });
                }

                // 如果是BaseCommand且包含AuthToken，则自动提取并设置到执行上下文
                if (command is BaseCommand baseCommand && !string.IsNullOrEmpty(baseCommand.AuthToken))
                {
                    // 确保ExecutionContext已初始化
                    if (baseCommand.ExecutionContext == null)
                    {
                        baseCommand.ExecutionContext = new CommandExecutionContext();
                    }
                    // 设置Token
                    baseCommand.ExecutionContext.Token = baseCommand.AuthToken;
                }



                // 通过现有的命令调度器处理命令，添加超时保护
                ResponseBase result;
                try
                {
                    // 使用链接的取消令牌，考虑命令超时设置
                    var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

                    // 如果命令有设置超时时间，则使用命令的超时时间，否则使用默认30秒
                    var timeout = command.TimeoutMs > 0 ? TimeSpan.FromMilliseconds(command.TimeoutMs) : TimeSpan.FromSeconds(30);
                    linkedCts.CancelAfter(timeout);

                    result = await _commandDispatcher.DispatchAsync(package.Packet, command, linkedCts.Token);
                }
                catch (OperationCanceledException ex)
                {
                    _logger?.LogError(ex, "命令执行超时或被取消: CommandId={CommandId}", package.Packet.CommandId);
                    result = ResponseBase.CreateError(UnifiedErrorCodes.System_Timeout.Message, UnifiedErrorCodes.System_Timeout.Code);
                }
                catch (Exception ex)
                {
                    _logger?.LogError(ex, "命令执行异常: CommandId={CommandId}", package.Packet.CommandId);
                    result = ResponseBase.CreateError(UnifiedErrorCodes.System_InternalError.Message, UnifiedErrorCodes.System_InternalError.Code);
                }
                if (result == null)
                {
                    result = ResponseBase.CreateError(UnifiedErrorCodes.System_InternalError.Message, UnifiedErrorCodes.System_InternalError.Code);
                }

                if (!result.IsSuccess)
                {
                    _logger?.LogDebug($"命令执行完成:{result.Message}, Success={result.IsSuccess}");
                }
                await HandleCommandResultAsync(session, package, result, cancellationToken);

                // 记录命令执行完成的日志
                _logger?.LogDebug("命令执行完成: CommandId={CommandId}, Success={Success}",
                    package.Packet.CommandId, result?.IsSuccess ?? false);
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "处理SuperSocket命令时发生异常: CommandId={CommandId}", package.Packet.CommandId);
                // 发送错误响应给客户端
                await SendErrorResponseAsync(session, package, UnifiedErrorCodes.System_InternalError, cancellationToken);
            }
        }


        /// <summary>
        /// 命令预解析信息
        /// </summary>
        private class CommandPreParseInfo
        {
            public uint CommandId { get; set; }
            public string CommandName { get; set; }
            public bool RequiresAuthentication { get; set; }
            public CommandPriority PriorityLevel { get; set; }
            public Type TargetCommandType { get; set; }
        }

        /// <summary>
        /// 预解析命令（第二层解析：获取指令信息，不解析具体业务数据）
        /// </summary>
        /// <param name="command">命令对象</param>
        /// <param name="packet">数据包</param>
        /// <returns>预解析信息</returns>
        private CommandPreParseInfo PreParseCommand(ICommand command, PacketModel packet)
        {
            try
            {
                var commandId = packet.CommandId;

                // 根据命令ID确定命令特性
                var requiresAuth = IsAuthenticationRequired(commandId);
                var priorityLevel = command.Priority;
                var targetType = command?.GetType();

                return new CommandPreParseInfo
                {
                    CommandId = commandId,
                    RequiresAuthentication = requiresAuth,
                    PriorityLevel = priorityLevel,
                    TargetCommandType = targetType
                };
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "命令预解析失败: CommandId={CommandId}", packet.CommandId);
                return null;
            }
        }


        /// <summary>
        /// 判断是否需要认证
        /// </summary>
        private bool IsAuthenticationRequired(uint commandId)
        {
            // 登录相关命令不需要认证
            var authCommands = new uint[]
            {
                AuthenticationCommands.Login.FullCode,
                AuthenticationCommands.LoginRequest.FullCode,
                AuthenticationCommands.PrepareLogin.FullCode,
                AuthenticationCommands.ValidateToken.FullCode,
                AuthenticationCommands.RefreshToken.FullCode
            };

            return !authCommands.Contains(commandId);
        }





        /*
        /// <summary>
        /// 创建命令对象
        /// 根据命令ID和数据包内容创建适当类型的命令对象
        /// </summary>
        /// <param name="package">数据包</param>
        /// <param name="sessionContext">会话上下文</param>
        /// <returns>创建的命令对象</returns>
        protected virtual ICommand CreateCommand(ServerPackageInfo package, SessionInfo sessionContext)
        {
            try
            {
                // 优先使用命令工厂创建命令
                if (_commandFactory != null)
                {
                    var command = _commandFactory.CreateCommand(package.Packet as PacketModel);
                    if (command != null)
                    {
                        // 设置命令的会话ID和数据包模型
                        command.SessionId = sessionContext.SessionID;
                        command.Packet = package.Packet;

                        // 尝试从数据包中获取业务数据 这里晚再再看
                        // businessDataCommand.BusinessData = packetModel.GetJsonData<object>();


                        return command;
                    }
                }

                // 如果命令工厂无法创建命令，尝试根据命令ID查找对应的命令类型
                // 直接使用CommandDispatcher中的方法获取命令类型
                var commandType = _commandDispatcher.GetCommandType(package.Packet.Command.FullCode);
                if (commandType != null)
                {
                    // 尝试使用构造函数创建命令实例
                    var constructor = GetSuitableConstructor(commandType);
                    if (constructor != null)
                    {
                        var parameters = PrepareConstructorParameters(constructor, package, sessionContext);
                        var command = Activator.CreateInstance(commandType, parameters) as ICommand;

                        // 设置命令的会话ID和数据包模型
                            if (command != null)
                            {
                                command.SessionId = sessionContext.SessionID;
                                command.Packet = package.Packet;
                            }

                        _logger?.LogDebug("根据命令ID创建命令实例: CommandId={CommandId}, Type={TypeName}",
                            package.Packet.Command, commandType.FullName);
                        return command;
                    }
                }

                // 如果没有找到对应的命令类型或无法创建实例，使用默认的MessageCommand
                var packetModelForDefault = PacketBuilder.Create()
                    .WithCommand(package.Packet.Command)
                    .WithBinaryData(package.Packet.Body)
                    .WithSession(package.Packet.SessionId)
                    .WithExtension("PacketId", package.Packet.PacketId)
                    .Build();

                var defaultCommand = new MessageCommand(
                    package.Packet.Command,
                    packetModelForDefault,
                    package.Packet.Body);

                // 尝试从数据包中获取业务数据
                //  defaultBusinessDataCommand.BusinessData = packetModelForDefault.GetJsonData<object>();


                return defaultCommand;
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "创建命令对象时出错: CommandId={CommandId}", package.Packet.Command);
                // 如果创建失败，返回一个默认的命令对象
                var packetModelForError = PacketBuilder.Create()
                    .WithCommand(package.Packet.Command)
                    .WithBinaryData(package.Packet.Body)
                    .WithSession(package.Packet.SessionId)
                    .WithExtension("PacketId", package.Packet.PacketId)
                    .Build();

                return new MessageCommand(
                    package.Packet.Command,
                    packetModelForError,
                    package.Packet.Body)
                {
                    SessionId = sessionContext.SessionID
                };
            }
        }

        /// <summary>
        /// 获取适合的构造函数
        /// </summary>
        /// <param name="commandType">命令类型</param>
        /// <returns>构造函数信息</returns>
        protected virtual ConstructorInfo GetSuitableConstructor(Type commandType)
        {
            try
            {
                // 查找包含CommandId、SessionInfo和Data参数的构造函数
                var constructors = commandType.GetConstructors();
                foreach (var constructor in constructors)
                {
                    var parameters = constructor.GetParameters();
                    if (parameters.Length >= 1 && parameters[0].ParameterType == typeof(PacketModel))
                    {
                        return constructor;
                    }
                }

                // 如果没有找到理想的构造函数，返回第一个可用的构造函数
                return constructors.FirstOrDefault();
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "获取命令类型 {CommandType} 的构造函数时出错", commandType?.FullName ?? "null");
                return null;
            }
        }

        /// <summary>
        /// 准备构造函数参数
        /// </summary>
        /// <param name="constructor">构造函数信息</param>
        /// <param name="package">数据包</param>
        /// <param name="sessionContext">会话上下文</param>
        /// <returns>参数数组</returns>
        protected virtual object[] PrepareConstructorParameters(ConstructorInfo constructor, ServerPackageInfo package, SessionInfo sessionContext)
        {
            try
            {
                var parameters = constructor.GetParameters();
                var parameterValues = new object[parameters.Length];

                for (int i = 0; i < parameters.Length; i++)
                {
                    if (parameters[i].ParameterType == typeof(PacketModel))
                    {
                        // 创建PacketModel对象
                        var builder = PacketBuilder.Create()
                            .WithCommand(package.Packet.Command)
                            .WithBinaryData(package.Packet.Body)
                            .WithSession(package.Packet.SessionId)
                            .WithExtension("PacketId", package.Packet.PacketId);
                        
                        if (package.Packet.Extensions != null)
                        {
                            foreach (var extension in package.Packet.Extensions)
                            {
                                // 避免覆盖已经设置的扩展属性
                                if (extension.Key != "PacketId")
                                {
                                    builder.WithExtension(extension.Key, extension.Value);
                                }
                            }
                        }
                        
                        parameterValues[i] = builder.Build();
                    }
                    else if (parameters[i].ParameterType == typeof(byte[]))
                    {
                        parameterValues[i] = package.Packet.Body;
                    }
                    else if (parameters[i].ParameterType == typeof(CommandId))
                    {
                        parameterValues[i] = package.Packet.Command;
                    }
                    else if (parameters[i].ParameterType == typeof(string))
                    {
                        parameterValues[i] = package.Packet.SessionId;
                    }
                    else
                    {
                        // 对于其他类型的参数，尝试使用默认值或null
                        parameterValues[i] = parameters[i].HasDefaultValue ? parameters[i].DefaultValue : null;
                    }
                }

                return parameterValues;
            }
            catch (Exception ex)
            {
                _logger?.LogError(ex, "准备构造函数参数时出错");
                return new object[0];
            }
        }

        */


        /// <summary>
        /// 处理命令执行结果
        /// </summary>
        /// <param name="session">SuperSocket会话</param>
        /// <param name="requestPackage">请求数据包</param>
        /// <param name="result">命令执行结果</param>
        /// <param name="cancellationToken">取消令牌</param>
        /// <returns>处理结果任务</returns>
        protected virtual async ValueTask HandleCommandResultAsync(
            TAppSession session,
            ServerPackageInfo requestPackage,
            ResponseBase result,
            CancellationToken cancellationToken)
        {
            if (result == null)
            {
                _logger?.LogWarning("命令执行结果为空，发送默认错误响应");
                await SendErrorResponseAsync(session, requestPackage, UnifiedErrorCodes.System_InternalError, cancellationToken);
                return;
            }

            if (result.IsSuccess)
            {
                // 命令执行成功，发送成功响应
                var responsePackage = CreateResponsePackage(requestPackage, result);
                await SendResponseAsync(session, responsePackage, cancellationToken);
            }
            else
            {
                // 命令执行失败，发送增强的错误响应
                // 从结果中提取所有错误信息，包括元数据中的详细信息
                var errorCode = ExtractErrorCodeFromResponse(result);
                await SendEnhancedErrorResponseAsync(session, requestPackage, result, errorCode, cancellationToken);
            }
        }

        /// <summary>
        /// 创建响应数据包
        /// </summary>
        /// <param name="requestPackage">请求数据包</param>
        /// <param name="result">命令执行结果</param>
        /// <returns>响应数据包</returns>
        protected virtual PacketModel CreateResponsePackage(ServerPackageInfo requestPackage, ResponseBase result)
        {
            var response = new PacketModel
            {
                PacketId =IdGenerator. GenerateResponseId(requestPackage.Packet.PacketId),
                Direction = requestPackage.Packet.Direction == PacketDirection.Request ? PacketDirection.Response : requestPackage.Packet.Direction,
                SessionId = requestPackage.Packet.SessionId,
                Status = result.IsSuccess ? PacketStatus.Completed : PacketStatus.Error,
                Extensions = new Dictionary<string, object>
                {
                    ["Data"] = result,
                    ["Message"] = result.Message,
                    ["Code"] = result.Code,
                    ["TimestampUtc"] = result.TimestampUtc
                }
            };

            // 如果请求包中包含RequestId，则在响应包中保留它，以便客户端匹配请求和响应
            if (requestPackage.Packet?.Extensions?.TryGetValue("RequestId", out var requestId) == true)
            {
                response.Extensions["RequestId"] = requestId;
            }

            // 设置请求标识
            if (!string.IsNullOrEmpty(result.RequestId))
            {
                response.Extensions["RequestId"] = result.RequestId;
            }

            // 添加元数据
            if (result.Metadata != null && result.Metadata.Count > 0)
            {
                foreach (var metadata in result.Metadata)
                {
                    response.Extensions[metadata.Key] = metadata.Value;
                }
            }

            // 优先使用WithJsonData设置业务响应数据
            if (result != null)
            {
                try
                {
                    response.WithJsonData(result);
                }
                catch (Exception ex)
                {
                    _logger?.LogWarning(ex, "Failed to set JSON data for response packet {PacketId}", response.PacketId);
                }
            }

            return response;
        }

        /// <summary>
        /// 发送响应
        /// </summary>
        /// <param name="session">SuperSocket会话</param>
        /// <param name="package">数据包</param>
        /// <param name="cancellationToken">取消令牌</param>
        /// <returns>发送结果任务</returns>
        protected virtual async ValueTask SendResponseAsync(TAppSession session, PacketModel package, CancellationToken cancellationToken)
        {
            try
            {
                // 检查会话是否有效
                if (session == null)
                {
                    _logger?.LogWarning("尝试发送响应到空会话: PacketId={PacketId}, CommandId={CommandId}",
                        package.PacketId, package.CommandId);
                    return;
                }
                package.SessionId = session.SessionID;
                // 使用统一的序列化方法
                var serializedData = SerializePacket(package);

                // 加密数据
                var originalData = new OriginalData(
                    (byte)package.CommandId.Category,
                    new byte[] { package.CommandId.OperationCode },
                    serializedData
                );
                var encryptedData = PacketSpec.Security.EncryptedProtocol.EncryptionServerPackToClient(originalData);

                // 发送数据并捕获可能的异常
                try
                {
                    await session.SendAsync(encryptedData.ToByteArray(), cancellationToken);
                }
                catch (InvalidOperationException ex) when (ex.Message.Contains("Writing is not allowed after writer was completed"))
                {
                    // 处理管道写入器已完成的特定异常
                    _logger?.LogWarning(ex, "管道写入器已完成，无法发送响应: SessionId={SessionId}, PacketId={PacketId}",
                        package.SessionId, package.PacketId);
                    // 忽略此异常，因为会话可能已经关闭
                }
                catch (Exception ex)
                {
                    // 记录其他发送异常
                    _logger?.LogError(ex, "发送响应时发生异常: SessionId={SessionId}, PacketId={PacketId}",
                        package.SessionId, package.PacketId);
                    // 可以选择是否向上传播异常
                    // throw;
                }
            }
            catch (Exception ex)
            {
                // 捕获所有其他异常以确保方法不会失败
                _logger?.LogError(ex, "处理响应发送时发生未预期的异常");
            }
        }

        /// <summary>
        /// 发送错误响应
        /// </summary>
        /// <param name="session">SuperSocket会话</param>
        /// <param name="requestPackage">请求数据包</param>
        /// <param name="errorCode">错误代码</param>
        /// <param name="cancellationToken">取消令牌</param>
        /// <returns>发送结果任务</returns>
        protected virtual async ValueTask SendErrorResponseAsync(
            TAppSession session,
            ServerPackageInfo requestPackage,
            ErrorCode errorCode,
            CancellationToken cancellationToken)
        { 
            var errorResponse = new PacketModel
            {
                PacketId =IdGenerator.GenerateResponseId(requestPackage.Packet?.PacketId ?? Guid.NewGuid().ToString()),
                Direction = PacketDirection.Response,
                SessionId = requestPackage.Packet?.SessionId,
                Status = PacketStatus.Error,
                Extensions = new Dictionary<string, object>
                {
                    ["ErrorCode"] = errorCode.Code,
                    ["ErrorMessage"] = errorCode.Message,
                    ["Success"] = false
                }
            };

            // 如果请求包中包含RequestId，则在响应包中保留它，以便客户端匹配请求和响应
            if (requestPackage.Packet?.Extensions?.TryGetValue("RequestId", out var requestId) == true)
            {
                errorResponse.Extensions["RequestId"] = requestId;
            }

            await SendResponseAsync(session, errorResponse, cancellationToken);
        }

        /// <summary>
        /// 序列化数据包
        /// </summary>
        /// <param name="package">数据包</param>
        /// <returns>序列化后的字节数组</returns>
        protected virtual byte[] SerializePacket(PacketModel package)
        {
            // 使用统一的序列化方法
            return UnifiedSerializationService.SerializeWithMessagePack(package);
        }

        /// <summary>
        /// 从响应结果中提取错误代码信息
        /// </summary>
        /// <param name="result">响应结果</param>
        /// <returns>错误代码对象</returns>
        protected virtual ErrorCode ExtractErrorCodeFromResponse(ResponseBase result)
        {
            if (result == null)
            {
                return UnifiedErrorCodes.System_InternalError;
            }

            // 优先使用响应中的元数据提取更详细的错误信息
            string detailedMessage = result.Message;

            if (result.Metadata != null)
            {
                // 尝试获取更详细的错误信息
                if (result.Metadata.TryGetValue("Exception", out var exceptionObj))
                {
                    detailedMessage = $"{result.Message} | Exception: {exceptionObj}";
                }
            }

            // 直接使用响应中的错误代码创建错误代码对象
            return new ErrorCode(result.Code, detailedMessage);
        }

        /// <summary>
        /// 发送增强的错误响应，包含命令处理结果中的所有错误信息
        /// </summary>
        /// <param name="session">SuperSocket会话</param>
        /// <param name="requestPackage">请求数据包</param>
        /// <param name="result">命令处理结果</param>
        /// <param name="errorCode">错误代码</param>
        /// <param name="cancellationToken">取消令牌</param>
        /// <returns>发送结果任务</returns>
        protected virtual async ValueTask SendEnhancedErrorResponseAsync(
            TAppSession session,
            ServerPackageInfo requestPackage,
            ResponseBase result,
            ErrorCode errorCode,
            CancellationToken cancellationToken)
        {
            var errorResponse = new PacketModel
            {
                PacketId = IdGenerator.GenerateResponseId(requestPackage.Packet?.PacketId ?? Guid.NewGuid().ToString()),
                Direction = PacketDirection.Response,
                SessionId = requestPackage.Packet?.SessionId,
                Status = PacketStatus.Error,
                Extensions = new Dictionary<string, object>
                {
                    ["ErrorCode"] = errorCode.Code,
                    ["ErrorMessage"] = errorCode.Message,
                    ["Success"] = false,
                    ["TimestampUtc"] = result.TimestampUtc,
                    ["OriginalMessage"] = result.Message,
                    ["OriginalCode"] = result.Code
                }
            };

           

            // 添加请求标识
            if (!string.IsNullOrEmpty(result.RequestId))
            {
                errorResponse.Extensions["RequestId"] = result.RequestId;
            }

            // 添加元数据中的所有错误信息
            if (result.Metadata != null && result.Metadata.Count > 0)
            {
                foreach (var metadata in result.Metadata)
                {
                    // 避免重复添加已经存在的键
                    if (!errorResponse.Extensions.ContainsKey(metadata.Key))
                    {
                        errorResponse.Extensions[metadata.Key] = metadata.Value;
                    }
                }
            }

            // 如果请求包中包含RequestId，则在响应包中保留它，以便客户端匹配请求和响应
            if (requestPackage.Packet?.Extensions?.TryGetValue("RequestId", out var requestId) == true)
            {
                errorResponse.Extensions["RequestId"] = requestId;
            }

            // 记录详细的错误信息用于调试
            _logger?.LogWarning("发送增强错误响应: ErrorCode={ErrorCode}, ErrorMessage={ErrorMessage}, OriginalCode={OriginalCode}, MetadataKeys=[{MetadataKeys}]",
                errorCode.Code, errorCode.Message, result.Code, 
                result.Metadata != null ? string.Join(", ", result.Metadata.Keys) : "none");

            await SendResponseAsync(session, errorResponse, cancellationToken);
        }


    }

    /// <summary>
    /// 非泛型版本的统一SuperSocket命令适配器，便于在不需要指定会话类型的场景中使用
    /// </summary>
    [Command(Key = "SuperSocketCommandAdapter")]
    public class SuperSocketCommandAdapter : SuperSocketCommandAdapter<IAppSession>
    {
        public SuperSocketCommandAdapter(
            CommandDispatcher commandDispatcher,
            CommandPacketAdapter _packetAdapter,
            ICommandFactory commandFactory,
            ILogger<SuperSocketCommandAdapter> logger = null)
            : base(commandDispatcher, _packetAdapter, commandFactory, logger)
        { }
    }
}