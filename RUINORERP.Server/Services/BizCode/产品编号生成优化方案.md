# 产品编号生成优化方案

## 概述

本文档详细说明了对产品相关编号生成的优化，核心需求是：**产品类目名称的前几个中文首字母作为标识，产品编号基于这个标识独立递增，而不是所有产品统一递增**。

## 核心改进

### 1. 类目独立序列体系

#### 原有方式（全局递增）
- 所有产品共用同一个序列
- 无法区分哪些产品属于同一类目
- 序列号可能会很大，不便于管理

#### 优化方式（类目独立）
- 每个产品类目有独立的序列
- 序列键格式：`DB:类目代码/格式`
- 示例：`DB:CZ/0000` 表示车载（CZ）类目的产品编号

## 实现详情

### 1. ProductSKUCodeGenerator 优化

#### 新增方法：GetProductBaseCodeByCategoryAsync

```csharp
/// <summary>
/// 获取基于类目的产品基础码（4-6位）
/// 同一类目下的产品编号独立递增，支持按类目分类管理
/// </summary>
private string GetProductBaseCodeByCategoryAsync(tb_Prod prod, string categoryCode)
{
    try
    {
        // 生成基于类目的序列键
        // 格式: {categoryCode}/0000 - 每个类目有独立的序列
        string rule = $"{{DB:{categoryCode}/0000}}";
        string baseCode = _bnrFactory.Create(rule);
        
        // 确保生成的代码为4-6位
        if (baseCode.Length > 6)
        {
            baseCode = baseCode.Substring(0, 6);
        }
        else if (baseCode.Length < 4)
        {
            baseCode = baseCode.PadLeft(4, '0');
        }
        
        return baseCode;
    }
    catch (Exception ex)
    {
        // 降级处理：使用全局序列
        return GetProductBaseCode(prod);
    }
}
```

#### 修改方法：GenerateSKUCodeAsync

```csharp
// 原方式
string productBaseCode = GetProductBaseCode(prod);

// 优化后
string productBaseCode = GetProductBaseCodeByCategoryAsync(prod, categoryCode);
```

### 2. 产品编号（ProductNo）格式优化

#### 格式对比

**原格式**
```
[分类代码] - [产品类型] - [年月] - [流水号]
示例: ELEC - PHON - 2305 - 0012
```

**优化格式**
```
[类目代码][产品序号]
示例: CZ0001（车载，第1个产品）
     HC0001（家居，第1个产品）
```

#### GenerateProdNoAsync 实现

```csharp
public string GenerateProdNoAsync(tb_Prod prod)
{
    try
    {
        // 获取类目代码（如：CZ、HC、YX等）
        string categoryCode = GetCategoryCode(prod);
        
        // 基于类目的产品编号规则
        // {categoryCode}/000000 确保每个类目有独立的产品编号序列
        string rule = $"{{DB:{categoryCode}/000000}}";
        string productSequence = _bnrFactory.Create(rule);
        
        string prodNo = $"{categoryCode}{productSequence}";
        return prodNo;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "生成产品编号失败");
        // 降级方案：使用时间戳保证唯一性
        return $"PROD-{DateTime.Now:yyyyMMddHHmmss}-{new Random().Next(100, 999)}";
    }
}
```

### 3. SKU 编号优化

#### 格式

```
[类目缩写][类目序列号][属性代码]
示例: CZ0001C-W（车载，第1个产品，颜色白色）
```

#### 生成流程

```
1. GetCategoryCode(prod)          → 获取类目缩写（CZ、HC等）
2. GetProductBaseCodeByCategoryAsync → 获取类目内的序列号（0001、0002等）
3. GetAttributeCombinationCode(prod) → 获取属性代码（C-W等）
4. 组合成最终SKU编号
```

## 数据库序列存储

### 序列键格式

所有产品类目的序列都存储在 `SequenceNumbers` 表中：

```sql
-- 示例记录
SequenceKey = "SEQ_CZ"        -- 车载类目
CurrentValue = 5              -- 已生成5个产品
BusinessType = "ProductNo"    -- 业务类型

SequenceKey = "SEQ_HC"        -- 家居类目
CurrentValue = 3              -- 已生成3个产品
BusinessType = "ProductNo"    -- 业务类型
```

## 规则配置

### 配置规则支持类目独立序列

可在 `tb_sys_BillNoRule` 表中配置产品编号规则，使用基于类目的序列：

```csharp
var ruleConfig = new tb_sys_BillNoRule
{
    RuleName = "产品编号规则-基于类目独立序列",
    BizType = (int)BaseInfoType.ProductNo,
    RulePattern = "{CN:类目名称前3字}{DB:类目代码/000000}",  // 支持动态类目代码
    RuleType = (int)RuleType.基础信息编号,
    IsActive = true,
    Description = "每个产品类目有独立的产品编号序列"
};
```

## 使用示例

### 1. 生成产品编号

```csharp
var product = new tb_Prod
{
    ProductNo = null,
    Category_ID = 1,  // 车载类目
    tb_prodcategories = new tb_ProdCategories { Category_name = "车载设备" }
};

var generator = new ProductSKUCodeGenerator(logger, bnrFactory, db);
string prodNo = generator.GenerateProdNoAsync(product);
// 结果: CZ000001
```

### 2. 生成SKU编号（带属性）

```csharp
var sku = generator.GenerateSKUCodeAsync(product);
// 结果: CZ000001  (不含属性时)
```

### 3. 生成短码

```csharp
var shortCode = generator.GenerateShortCodeAsync(product);
// 结果: 根据规则生成
```

## 降级策略

### 当基于类目的序列失败时

1. **首先尝试** - 使用类目代码作为序列键
2. **降级为** - 使用全局序列（GetProductBaseCode）
3. **最后降级** - 使用时间戳确保唯一性

```csharp
try
{
    return GetProductBaseCodeByCategoryAsync(prod, categoryCode);
}
catch
{
    return GetProductBaseCode(prod);  // 降级到全局序列
}
```

## 类目代码提取

### 工作原理

使用 `ChineseSpellCodeParameter` 提取类目名称的首字母：

```
输入：产品类目 = "车载设备"
处理：NPinyin 提取首字母 → C（车）Z（载）
结果：类目代码 = "CZ"

输入：产品类目 = "家居照明"
处理：NPinyin 提取首字母 → J（家）J（居）Z（照）M（明）
截取前3个：JJZ
结果：类目代码 = "JJZ"
```

### GetCategoryCode 方法

```csharp
private string GetCategoryCode(tb_Prod prod)
{
    if (prod.tb_prodcategories == null)
        return "UNC";  // Unknown Category

    string categoryName = prod.tb_prodcategories.Category_name;
    // 取类目名称的前3个字符
    string shortCategoryName = categoryName.Substring(0, Math.Min(3, categoryName.Length));
    // 使用BNRFactory提取首字母
    string categoryCode = _bnrFactory.Create("{CN:" + shortCategoryName + "}");
    
    return categoryCode.ToUpper();
}
```

## 配置修改检查清单

- [ ] **DatabaseSequenceService** 已启用，支持数据库序列
- [ ] **BNRFactory** 已注册 DatabaseSequenceParameter
- [ ] **ChineseSpellCodeParameter** 已正确配置处理中文首字母
- [ ] **ProductSKUCodeGenerator** 已注入 BNRFactory
- [ ] **序列表** SequenceNumbers 已创建或同步结构

## 功能验证

### 1. 单个产品编号生成

```
产品1（车载）  → 类目代码CZ → 序列号0001 → 编号CZ0001
产品2（车载）  → 类目代码CZ → 序列号0002 → 编号CZ0002
产品3（家居）  → 类目代码HC → 序列号0001 → 编号HC0001
```

### 2. 数据库验证

```sql
-- 查询车载类目的序列
SELECT * FROM SequenceNumbers WHERE SequenceKey LIKE '%CZ%'
-- 结果: CurrentValue = 2（已生成2个车载产品）

-- 查询家居类目的序列
SELECT * FROM SequenceNumbers WHERE SequenceKey LIKE '%HC%'
-- 结果: CurrentValue = 1（已生成1个家居产品）
```

## 性能优化建议

1. **序列缓存** - DatabaseSequenceService 已实现内存缓存机制
2. **批量操作** - 批量生成时，序列更新会被聚合写入数据库
3. **类目缓存** - 建议缓存类目信息，避免重复数据库查询

## 注意事项

1. **类目名称格式** - 确保产品类目名称包含中文字符
2. **序列键唯一性** - 不同类目的序列键必须唯一
3. **并发控制** - DatabaseSequenceService 已支持高并发场景
4. **数据迁移** - 如果要应用到现有系统，需要考虑现有产品编号的迁移策略

## 扩展方案

### 支持多级类目序列

如果需要支持二级、三级类目的独立序列：

```csharp
// 二级类目
string rule = $"{{DB:{categoryCode1}_{categoryCode2}/0000}}";

// 三级类目
string rule = $"{{DB:{categoryCode1}_{categoryCode2}_{categoryCode3}/0000}}";
```

## 与原有规则系统的兼容性

- 完全兼容 BNRFactory 和规则生成体系
- 可与其他参数处理器（{S:}、{D:}、{Hex:} 等）组合使用
- 支持通过 tb_sys_BillNoRule 配置动态规则
