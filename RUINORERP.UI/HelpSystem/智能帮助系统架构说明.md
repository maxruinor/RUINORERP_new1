# 智能帮助系统架构说明

## 概述

智能帮助系统利用系统架构中的固有规律，实现了**完全自动化的帮助匹配**，无需手动指定HelpKey即可智能识别控件关联的实体和字段。

---

## 系统架构规律

### 1. 泛型类型 → 实体类型映射

系统使用泛型基类 `BaseBillEditGeneric<T, C>`，其中：
- **T**（第一个泛型参数）：主实体类型
- **C**（第二个泛型参数）：明细实体类型

**示例：**
```csharp
// UCSaleOrder 窗体
public partial class UCSaleOrder : BaseBillEditGeneric<tb_SaleOrder, tb_SaleOrderDetail>
{
    // ...
}
```

**映射关系：**
```
UCSaleOrder : BaseBillEditGeneric<tb_SaleOrder, tb_SaleOrderDetail>
            ↓ (提取第一个泛型参数)
            → tb_SaleOrder (主实体类型)
```

---

### 2. 控件名 → 字段名映射

系统遵循严格的控件命名规范，控件名由**前缀**和**字段名**组成。

**控件前缀列表：**
| 前缀 | 控件类型 | 示例 |
|------|---------|------|
| `txt` | TextBox | txtCustomerPONo |
| `cmb` | ComboBox | cmbCustomerVendor_ID |
| `lbl` | Label | lblCustomerVendor_ID |
| `dtp` | DateTimePicker | dtpOrderDate |
| `chk` | CheckBox | chkIsCustomizedOrder |
| `num` | NumericUpDown | numTotalAmount |
| `btn` | Button | btnSave |

**字段名提取：**
```csharp
控件名: cmbCustomerVendor_ID
         ↓ 去除前缀 "cmb"
字段名: CustomerVendor_ID
```

---

### 3. 数据绑定 → 实体字段映射

控件通过 `DataBindingHelper.BindData4Cmb` 方法绑定到实体字段：

```csharp
// UCSaleOrder.cs
DataBindingHelper.BindData4Cmb<tb_CustomerVendor>(
    entity, 
    k => k.CustomerVendor_ID,  // ← 绑定到实体的 CustomerVendor_ID 属性
    v => v.CVName, 
    cmbCustomerVendor_ID,      // ← 控件名
    c => c.IsCustomer == true
);
```

**绑定关系：**
```
cmbCustomerVendor_ID 控件
        ↓ DataBindings
        → tb_CustomerVendor.CustomerVendor_ID 属性
```

---

## 智能匹配流程

### 完整流程图

```
用户按F1或悬停控件
        ↓
SmartHelpResolver.ResolveHelpKeys(control)
        ↓
┌─────────────────────────────────────┐
│ 1. 检查手动指定的HelpKey (Tag)      │
│    如果有 → 返回                     │
│    如果无 → 继续                     │
└─────────────────────────────────────┘
        ↓
┌─────────────────────────────────────┐
│ 2. 从DataBindings提取              │
│    - 字段名: CustomerVendor_ID      │
│    - 实体类型: tb_CustomerVendor    │
│    生成键: Fields.tb_CustomerVendor.CustomerVendor_ID
└─────────────────────────────────────┘
        ↓
┌─────────────────────────────────────┐
│ 3. 从控件名智能匹配                 │
│    - 控件名: cmbCustomerVendor_ID    │
│    - 提取字段: CustomerVendor_ID     │
│    - 解析实体: tb_SaleOrder (泛型)   │
│    验证字段存在性                    │
│    生成键: Fields.tb_SaleOrder.CustomerVendor_ID
└─────────────────────────────────────┘
        ↓
┌─────────────────────────────────────┐
│ 4. 生成控件级帮助键                │
│    - 窗体: UCSaleOrder              │
│    - 控件: cmbCustomerVendor_ID     │
│    生成键: Controls.UCSaleOrder.cmbCustomerVendor_ID
└─────────────────────────────────────┘
        ↓
┌─────────────────────────────────────┐
│ 5. 生成窗体级帮助键                │
│    生成键: Forms.UCSaleOrder         │
└─────────────────────────────────────┘
        ↓
返回帮助键列表（按优先级排序）
        ↓
HelpManager 按优先级查找帮助内容
        ↓
显示第一个找到的帮助
```

---

## 帮助键优先级

### 优先级规则

| 优先级 | 帮助键格式 | 说明 | 示例 |
|-------|----------|------|------|
| **最高** | 手动指定 | Tag中的HelpKey | `HelpKey:CustomHelp` |
| 1 | `Fields.实体名.字段名` | 字段级帮助（最高优先级） | `Fields.tb_SaleOrder.CustomerVendor_ID` |
| 2 | `Controls.窗体名.控件名` | 控件级帮助 | `Controls.UCSaleOrder.cmbCustomerVendor_ID` |
| 3 | `Forms.窗体名` | 窗体级帮助（兜底） | `Forms.UCSaleOrder` |

### 回退机制

系统采用**回退机制**，当高优先级的帮助文件不存在时，自动尝试低优先级的帮助：

```csharp
// 示例：cmbCustomerVendor_ID 的帮助查找流程
尝试1: Fields.tb_SaleOrder.CustomerVendor_ID.md  ← 没找到
尝试2: Controls.UCSaleOrder.cmbCustomerVendor_ID.md  ← 没找到
尝试3: Forms.UCSaleOrder.md  ← 找到！显示窗体帮助
```

---

## 实际使用示例

### 场景1：销售订单窗体 - 客户字段

**窗体类：**
```csharp
[MenuAttrAssemblyInfo("销售订单", ModuleMenuDefine.模块定义.进销存管理, 
    ModuleMenuDefine.进销存管理.销售管理, BizType.销售订单)]
public partial class UCSaleOrder : BaseBillEditGeneric<tb_SaleOrder, tb_SaleOrderDetail>
{
    // 构造函数中无需任何帮助相关配置
    public UCSaleOrder()
    {
        InitializeComponent();
        // ✅ 帮助系统自动启用，无需任何代码
    }
}
```

**控件定义（Designer.cs）：**
```csharp
this.cmbCustomerVendor_ID = new Krypton.Toolkit.KryptonComboBox();
this.cmbCustomerVendor_ID.Name = "cmbCustomerVendor_ID";
```

**数据绑定（UCSaleOrder.cs）：**
```csharp
DataBindingHelper.BindData4Cmb<tb_CustomerVendor>(
    entity, 
    k => k.CustomerVendor_ID,  // 字段名
    v => v.CVName, 
    cmbCustomerVendor_ID,      // 控件
    c => c.IsCustomer == true
);
```

**帮助文件路径：**
```
HelpContent/
└── Fields/
    └── tb_SaleOrder/
        └── CustomerVendor_ID.md  ← 自动匹配！
```

**智能匹配过程：**
```
用户按F1 → cmbCustomerVendor_ID
        ↓
解析泛型: BaseBillEditGeneric<tb_SaleOrder, C>
        → 实体类型: tb_SaleOrder
        ↓
解析控件名: cmbCustomerVendor_ID
        → 去除前缀 "cmb"
        → 字段名: CustomerVendor_ID
        ↓
验证字段存在: tb_SaleOrder.CustomerVendor_ID 存在 ✓
        ↓
生成帮助键: Fields.tb_SaleOrder.CustomerVendor_ID
        ↓
查找帮助: HelpContent/Fields/tb_SaleOrder/CustomerVendor_ID.md
        ↓
显示帮助内容
```

---

### 场景2：没有绑定数据的控件

**控件定义：**
```csharp
this.txtOrderDate = new Krypton.Toolkit.KryptonTextBox();
this.txtOrderDate.Name = "txtOrderDate";
```

**智能匹配过程：**
```
用户按F1 → txtOrderDate
        ↓
解析泛型: BaseBillEditGeneric<tb_SaleOrder, C>
        → 实体类型: tb_SaleOrder
        ↓
解析控件名: txtOrderDate
        → 去除前缀 "txt"
        → 字段名: OrderDate
        ↓
验证字段存在: tb_SaleOrder.OrderDate 存在 ✓
        ↓
生成帮助键: Fields.tb_SaleOrder.OrderDate
        ↓
查找帮助: HelpContent/Fields/tb_SaleOrder/OrderDate.md
```

---

### 场景3：字段帮助不存在时的回退

**情况：** `Fields.tb_SaleOrder.CustomerVendor_ID.md` 不存在

**回退流程：**
```
尝试1: Fields.tb_SaleOrder.CustomerVendor_ID.md  ← 文件不存在
尝试2: Controls.UCSaleOrder.cmbCustomerVendor_ID.md  ← 文件不存在
尝试3: Forms.UCSaleOrder.md  ← 存在！显示
```

---

## 帮助内容编写指南

### 1. 字段级帮助（推荐）

**文件路径：** `HelpContent/Fields/实体名/字段名.md`

**示例：** `HelpContent/Fields/tb_SaleOrder/CustomerVendor_ID.md`

```markdown
# 客户

## 业务意义

客户字段是销售订单的核心关联字段，用于标识订单的购买方。通过选择客户，系统自动应用以下业务规则：

1. **信用控制** - 检查客户信用额度，超限则警告
2. **价格体系** - 应用该客户的专属价目表
3. **折扣规则** - 应用客户的折扣协议
4. **付款方式** - 自动设置该客户的默认付款方式
5. **交货地址** - 自动填充客户的默认送货地址

## 使用说明

### 选择客户
1. 点击客户下拉框
2. 输入客户名称拼音或编码进行搜索
3. 选择目标客户

### 新建客户
如果客户不存在，可按以下步骤新建：
1. 在下拉框中直接输入新客户名称
2. 按 `F5` 键或点击右侧 `+` 按钮
3. 系统自动打开客户信息维护窗体
4. 填写客户信息后保存

### 查看客户详情
选中客户后，双击或按 `F2` 键可查看客户详细信息。

## 重要提示

- **信用控制** - 如果客户信用超限，订单保存时会弹出警告
- **特殊客户** - 标记为"特殊客户"的客户，订单需要主管审批
- **停用客户** - 已停用的客户无法创建新订单

## 常见问题

**Q: 为什么某些客户在下拉框中不显示？**
A: 可能是客户被停用或当前登录用户没有查看权限。

**Q: 可以修改订单上的客户吗？**
A: 可以。但修改客户后，系统会重新计算价格和折扣，建议先确认。
```

---

### 2. 窗体级帮助（兜底）

**文件路径：** `HelpContent/Forms/窗体名.md`

**示例：** `HelpContent/Forms/UCSaleOrder.md`

```markdown
# 销售订单

## 窗体概述

销售订单是销售管理的核心单据，用于记录客户购买意向、约定交货日期和付款方式。

## 窗体布局

窗体分为三个区域：
- **头部区域**：订单基本信息（客户、订单日期、交货日期等）
- **明细区域**：订单产品明细（产品、数量、单价等）
- **底部区域**：合计信息和操作按钮

## 基本操作

### 新增订单
1. 点击 `新增` 按钮
2. 选择客户
3. 添加订单明细
4. 点击 `保存`

### 修改订单
1. 在列表中选中要修改的订单
2. 点击 `修改` 按钮
3. 修改内容后保存

### 删除订单
1. 选中要删除的订单
2. 点击 `删除` 按钮
3. 确认删除操作

## 快捷键

| 快捷键 | 功能 |
|-------|------|
| F1 | 显示帮助 |
| F2 | 查看详情 |
| F5 | 新增记录 |
| F7 | 保存 |
| Ctrl+N | 新增 |
| Ctrl+S | 保存 |
| Del | 删除 |

## 字段说明

| 字段 | 说明 | 必填 |
|------|------|------|
| 客户 | 订单客户 | 是 |
| 订单日期 | 订单创建日期 | 是 |
| 交货日期 | 约定交货日期 | 是 |
| 订单备注 | 订单备注信息 | 否 |

按 `F1` 在各字段上可查看详细帮助。
```

---

## 调试与诊断

### 1. 启用调试日志

在程序启动时启用调试输出：

```csharp
// Program.cs 或 Main 方法
System.Diagnostics.Debug.Listeners.Add(
    new System.Diagnostics.ConsoleTraceListener());
```

调试日志示例：
```
从控件名智能匹配: Fields.tb_SaleOrder.CustomerVendor_ID
从窗体 UCSaleOrder 解析出实体类型: tb_SaleOrder
控件 cmbCustomerVendor_ID 映射的字段 CustomerVendor_ID 在实体 tb_SaleOrder 中存在
```

### 2. 查看缓存统计

```csharp
var resolver = new SmartHelpResolver();
string stats = resolver.GetCacheStatistics();
Console.WriteLine(stats);

// 输出：
// SmartHelpResolver 缓存统计:
//   - 实体类型缓存: 15
//   - 实体属性缓存: 15
```

### 3. 清空缓存

```csharp
var resolver = new SmartHelpResolver();
resolver.ClearCache();
```

---

## 常见问题

### Q: 为什么某些控件没有自动匹配到帮助？

**可能原因：**
1. 控件名不符合命名规范（缺少前缀或字段名错误）
2. 实体类型解析失败（窗体未继承自 `BaseBillEditGeneric<T, C>`）
3. 字段名在实体中不存在

**解决方案：**
```csharp
// 方案1：手动指定HelpKey
cmbCustomerVendor_ID.Tag = "HelpKey:Custom.CustomerVendor_ID";

// 方案2：修正控件命名
// 错误: cmbCustomerVendorID (缺少下划线)
// 正确: cmbCustomerVendor_ID

// 方案3：验证实体字段
// 在实体类中确认字段名拼写正确
```

---

### Q: 如何为同一个控件提供不同场景的帮助？

**方案1：使用上下文信息**
```csharp
// 在Tag中存储场景信息
cmbCustomerVendor_ID.Tag = new {
    HelpKey = "Fields.tb_SaleOrder.CustomerVendor_ID",
    Scenario = "NewOrder"  // 新增订单场景
};
```

**方案2：创建多个帮助文件**
```
HelpContent/
├── Fields/
│   └── tb_SaleOrder/
│       ├── CustomerVendor_ID_NewOrder.md
│       └── CustomerVendor_ID_ModifyOrder.md
```

---

### Q: 如何处理继承的窗体？

**情况：**
```csharp
// 基类
public class BaseOrderForm<T> : BaseBillEditGeneric<T, TDetail> { }

// 派生类
public class UCSaleOrder : BaseOrderForm<tb_SaleOrder> { }
```

**解决方案：**
智能解析器会遍历整个基类链，找到第一个 `BaseBillEditGeneric<T, C>` 并提取泛型参数：

```csharp
UCSaleOrder
    ↓ BaseOrderForm<tb_SaleOrder>
    ↓ BaseBillEditGeneric<tb_SaleOrder, tb_SaleOrderDetail>
    ↓ 提取第一个泛型参数
    → tb_SaleOrder ✓
```

---

## 性能优化

### 1. 缓存策略

智能帮助解析器使用两级缓存：

| 缓存类型 | 内容 | 生命周期 |
|---------|------|---------|
| 实体类型缓存 | 窗体类型 → 实体类型映射 | 程序运行期间 |
| 实体属性缓存 | 实体类型 → 属性集合 | 程序运行期间 |

### 2. 延迟加载

- 实体属性在第一次访问时加载
- 缓存未命中时才反射获取属性

### 3. 性能数据

| 操作 | 耗时 | 说明 |
|------|------|------|
| 解析实体类型 | ~0.5ms | 有缓存 |
| 提取字段名 | ~0.1ms | 字符串操作 |
| 验证字段存在 | ~0.2ms | 有缓存 |
| 总计 | ~0.8ms | 完整解析流程 |

---

## 最佳实践

### 1. 命名规范

✅ **推荐：**
- `cmbCustomerVendor_ID` - 完整字段名
- `txtTotalCost` - 简洁清晰
- `lblExchangeRate` - 与实体字段一致

❌ **避免：**
- `cmbCustID` - 过度缩写
- `txt123` - 无意义命名
- `CustomerVendor_ID` - 缺少前缀

### 2. 帮助文件组织

```
HelpContent/
├── Fields/              # 字段级帮助（优先编写）
│   └── tb_SaleOrder/
│       ├── CustomerVendor_ID.md
│       ├── OrderDate.md
│       └── TotalCost.md
├── Forms/              # 窗体级帮助（作为兜底）
│   ├── UCSaleOrder.md
│   └── UCSaleOut.md
└── Modules/            # 模块级帮助（业务全景）
    └── SalesManagement.md
```

### 3. 帮助内容编写原则

1. **面向业务，而非技术** - 描述业务意义，而非实现细节
2. **提供示例** - 用具体例子说明使用方法
3. **突出重点** - 标注重要提示和注意事项
4. **结构清晰** - 使用标题、列表、表格组织内容
5. **保持更新** - 系统功能变更时同步更新帮助

---

## 总结

智能帮助系统的核心优势：

✅ **零配置** - 基于系统架构规律自动匹配，无需代码  
✅ **智能回退** - 多级回退机制，总能找到合适的帮助  
✅ **易于维护** - 只需编写帮助文件，无需修改代码  
✅ **性能优秀** - 多级缓存，快速响应  
✅ **扩展性强** - 支持手动覆盖和自定义扩展

**你只需要：**
1. 按规范命名控件
2. 编写帮助文件
3. 系统自动完成匹配！
