# 客户端命令处理架构优化设计文档

## 1. 当前架构分析

### 1.1 现有问题

1. **手动注册问题**：当前在 `ClientCommandHandlerRegistry.cs` 中需要手动编写每个命令处理器的注册代码，扩展性差
2. **处理器创建限制**：现有的 `ScanAndRegisterHandlersAsync()` 方法仅支持无参构造函数创建实例，无法处理带依赖的处理器
3. **命令映射不灵活**：无法在特性中直接定义处理器支持的命令列表
4. **扫描范围局限**：仅扫描当前程序集，无法发现其他程序集中的处理器
5. **处理器与命令的关系不够明确**：没有明确的方式表示一个处理器可以处理多个命令

### 1.2 当前关键组件

- **ClientCommandHandlerRegistry.cs**：负责手动注册命令处理器
- **ClientCommandDispatcher.cs**：包含扫描注册方法但未被调用
- **ClientCommandHandlerAttribute.cs**：仅包含名称和优先级信息
- **IClientCommandHandler.cs**：定义处理器接口，包含支持的命令列表
- **ClientCommandHandlerSystemInitializer.cs**：初始化系统，但只调用手动注册方法

## 2. 优化目标

1. **实现自动扫描注册**：通过接口扫描程序集，自动发现和注册命令处理器
2. **支持依赖注入**：利用现有 Autofac 容器创建处理器实例，支持构造函数注入
3. **灵活的命令映射**：在特性中直接定义处理器支持的命令列表，实现一个处理器对应多个指令
4. **多程序集扫描**：支持扫描指定的多个程序集，提高扩展性
5. **以指令为key的映射**：优化命令到处理器的映射机制

## 3. 具体优化方案

### 3.1 修改 ClientCommandHandlerAttribute.cs

```csharp
using System;

namespace RUINORERP.UI.Network.ClientCommandHandlers
{
    /// <summary>
    /// 客户端命令处理器特性
    /// 用于标记类为客户端命令处理器，并设置名称、优先级和支持的命令
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public class ClientCommandHandlerAttribute : Attribute
    {
        /// <summary>
        /// 处理器名称
        /// </summary>
        public string Name { get; }

        /// <summary>
        /// 处理器优先级，数值越大优先级越高
        /// </summary>
        public int Priority { get; }
        
        /// <summary>
        /// 处理器支持的命令ID列表
        /// </summary>
        public string[] SupportedCommandIds { get; }

        /// <summary>
        /// 构造函数
        /// </summary>
        /// <param name="name">处理器名称</param>
        /// <param name="priority">优先级，默认为50</param>
        /// <param name="supportedCommandIds">支持的命令ID列表</param>
        public ClientCommandHandlerAttribute(string name, int priority = 50, params string[] supportedCommandIds)
        {
            Name = name ?? throw new ArgumentNullException(nameof(name));
            Priority = priority;
            SupportedCommandIds = supportedCommandIds;
        }
    }
}
```

### 3.2 修改 ClientCommandDispatcher.cs

```csharp
// 扩展现有的ScanAndRegisterHandlersAsync方法
public virtual async Task<int> ScanAndRegisterHandlersAsync(IEnumerable<Assembly> assemblies = null, ILifetimeScope lifetimeScope = null)
{
    int registeredCount = 0;

    try
    {
        // 如果没有指定程序集，使用当前程序集
        if (assemblies == null)
        {
            assemblies = new[] { Assembly.GetExecutingAssembly() };
        }

        List<Type> handlerTypes = new List<Type>();
        
        // 扫描所有指定的程序集
        foreach (var assembly in assemblies)
        {
            var types = assembly.GetTypes()
                .Where(t => typeof(IClientCommandHandler).IsAssignableFrom(t) && !t.IsInterface && !t.IsAbstract
                            && t.GetCustomAttribute<ClientCommandHandlerAttribute>() != null)
                .ToList();
            
            handlerTypes.AddRange(types);
        }

        LogInfo($"从{assemblies.Count()}个程序集中扫描到 {handlerTypes.Count} 个命令处理器类型");

        // 创建并注册每个处理器
        foreach (var type in handlerTypes)
        {
            try
            {
                IClientCommandHandler handler;
                
                // 优先使用依赖注入容器创建实例
                if (lifetimeScope != null && lifetimeScope.IsRegistered(type))
                {
                    handler = (IClientCommandHandler)lifetimeScope.Resolve(type);
                    LogInfo($"通过依赖注入创建处理器 {type.Name}");
                }
                else
                {
                    // 尝试通过无参构造函数创建
                    handler = (IClientCommandHandler)Activator.CreateInstance(type);
                    LogInfo($"通过无参构造函数创建处理器 {type.Name}");
                }
                
                if (handler != null)
                {
                    // 从特性中获取优先级
                    var attribute = type.GetCustomAttribute<ClientCommandHandlerAttribute>();
                    if (attribute != null)
                    {
                        handler.Priority = attribute.Priority;
                    }
                    
                    bool success = await RegisterHandlerAsync(handler);
                    if (success)
                    {
                        registeredCount++;
                    }
                }
            }
            catch (Exception ex)
            {
                LogError($"创建处理器 {type.Name} 实例时出错: {ex.Message}", ex);
            }
        }

        LogInfo($"成功注册 {registeredCount} 个命令处理器");
    }
    catch (Exception ex)
    {
        LogError($"扫描程序集时出错: {ex.Message}", ex);
    }

    return registeredCount;
}
```

### 3.3 修改 ClientCommandHandlerRegistry.cs

```csharp
/// <summary>
/// 注册所有内置命令处理器
/// </summary>
/// <returns>注册的处理器数量</returns>
public async Task<int> RegisterAllHandlersAsync()
{
    int registeredCount = 0;
    
    try
    {
        // 首先调用自动扫描注册方法
        int scannedCount = await _commandDispatcher.ScanAndRegisterHandlersAsync(null, _lifetimeScope);
        registeredCount += scannedCount;
        
        // 保留手动注册作为补充
        if (await RegisterConfigCommandHandlerAsync())
        {
            registeredCount++;
        }

        if (await RegisterMessageCommandHandlerAsync())
        {
            registeredCount++;
        }
    }
    catch (Exception ex)
    {
        System.Diagnostics.Debug.WriteLine($"注册命令处理器失败: {ex.Message}");
    }

    return registeredCount;
}
```

### 3.4 创建 BaseClientCommandHandler 基类

```csharp
using RUINORERP.PacketSpec.Commands;
using RUINORERP.PacketSpec.Enums.Core;
using RUINORERP.PacketSpec.Models.Core;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;

namespace RUINORERP.UI.Network.ClientCommandHandlers
{
    /// <summary>
    /// 客户端命令处理器基类
    /// 提供通用功能实现
    /// </summary>
    public abstract class BaseClientCommandHandler : IClientCommandHandler
    {
        private readonly List<CommandId> _supportedCommands = new List<CommandId>();
        
        public string HandlerId { get; } = System.Guid.NewGuid().ToString();
        
        public string Name { get; }
        
        public int Priority { get; set; } = 50;
        
        public IReadOnlyList<CommandId> SupportedCommands => _supportedCommands;
        
        public ClientHandlerStatus Status { get; protected set; } = ClientHandlerStatus.Uninitialized;
        
        public BaseClientCommandHandler()
        {
            // 从特性中获取信息
            var attribute = this.GetType().GetCustomAttribute<ClientCommandHandlerAttribute>();
            if (attribute != null)
            {
                Name = attribute.Name;
                Priority = attribute.Priority;
                
                // 从特性中解析支持的命令ID
                foreach (var commandIdStr in attribute.SupportedCommandIds)
                {
                    if (!string.IsNullOrEmpty(commandIdStr))
                    {
                        // 解析命令ID字符串为CommandId对象
                        var parts = commandIdStr.Split('.');
                        if (parts.Length >= 2)
                        {
                            _supportedCommands.Add(new CommandId { ModuleId = parts[0], CommandCode = parts[1] });
                        }
                    }
                }
            }
        }
        
        public virtual Task<bool> InitializeAsync()
        {
            Status = ClientHandlerStatus.Initialized;
            return Task.FromResult(true);
        }
        
        public virtual Task<bool> StartAsync()
        {
            Status = ClientHandlerStatus.Running;
            return Task.FromResult(true);
        }
        
        public virtual Task<bool> StopAsync()
        {
            Status = ClientHandlerStatus.Stopped;
            return Task.FromResult(true);
        }
        
        public virtual bool CanHandle(PacketModel packet)
        {
            if (packet == null || packet.CommandId == null)
                return false;
                
            // 检查是否支持该命令
            return SupportedCommands.Any(cmd => 
                cmd.ModuleId == packet.CommandId.ModuleId && 
                cmd.CommandCode == packet.CommandId.CommandCode);
        }
        
        public abstract Task HandleAsync(PacketModel packet);
    }
}
```

### 3.5 修改 ConfigCommandHandler.cs 和 MessageCommandHandler.cs 示例

```csharp
// ConfigCommandHandler.cs 示例
[ClientCommandHandler("配置命令处理器", 60, "Config.Update", "Config.Get")]
public class ConfigCommandHandler : BaseClientCommandHandler
{
    private readonly OptionsMonitorConfigManager _configManager;
    
    // 通过构造函数注入依赖
    public ConfigCommandHandler(OptionsMonitorConfigManager configManager)
        : base()
    {
        _configManager = configManager;
    }
    
    public override async Task HandleAsync(PacketModel packet)
    {
        // 处理逻辑
        if (packet.CommandId.CommandCode == "Update")
        {
            // 处理配置更新
        }
        else if (packet.CommandId.CommandCode == "Get")
        {
            // 处理配置获取
        }
    }
}

// MessageCommandHandler.cs 示例
[ClientCommandHandler("消息命令处理器", 70, "Message.Receive", "Message.Send")]
public class MessageCommandHandler : BaseClientCommandHandler
{
    private readonly MessageService _messageService;
    
    public MessageCommandHandler(MessageService messageService)
        : base()
    {
        _messageService = messageService;
    }
    
    public override async Task HandleAsync(PacketModel packet)
    {
        // 处理逻辑
    }
}
```

## 4. 实现步骤

### 4.1 步骤一：修改特性定义
- 更新 `ClientCommandHandlerAttribute.cs`，添加 `SupportedCommandIds` 参数

### 4.2 步骤二：创建基类
- 实现 `BaseClientCommandHandler.cs`，提供通用功能

### 4.3 步骤三：优化扫描注册
- 修改 `ClientCommandDispatcher.cs` 中的 `ScanAndRegisterHandlersAsync` 方法
- 支持多程序集扫描和依赖注入

### 4.4 步骤四：更新注册器
- 修改 `ClientCommandHandlerRegistry.cs`，优先使用自动扫描注册

### 4.5 步骤五：更新处理器实现
- 修改现有处理器，继承自基类并使用特性定义支持的命令

### 4.6 步骤六：修改初始化器（可选）
- 如需直接使用自动扫描而不通过Registry，可修改 `ClientCommandHandlerSystemInitializer.cs`

## 5. 依赖注入配置

在应用程序启动时，需要确保所有的命令处理器都注册到Autofac容器中：

```csharp
// 在Autofac配置中添加
containerBuilder.RegisterAssemblyTypes(Assembly.GetExecutingAssembly())
    .Where(t => typeof(IClientCommandHandler).IsAssignableFrom(t) && !t.IsInterface && !t.IsAbstract)
    .AsImplementedInterfaces()
    .SingleInstance();
```

## 6. 优势与改进

1. **提高可扩展性**：添加新的命令处理器只需创建新类并添加特性，无需修改注册代码
2. **依赖注入支持**：充分利用现有依赖注入框架，便于单元测试和维护
3. **灵活的命令映射**：一个处理器可以处理多个命令，提高代码复用性
4. **自动发现**：系统自动发现所有实现了接口并带有特性的处理器
5. **以指令为key**：命令到处理器的映射更加明确，查找更高效

## 7. 注意事项

1. 确保新添加的处理器类继承自 `BaseClientCommandHandler` 并添加 `ClientCommandHandler` 特性
2. 命令ID格式需要遵循 "ModuleId.CommandCode" 的格式
3. 对于有特殊依赖的处理器，确保在Autofac容器中正确注册
4. 优先级设置会影响命令处理器的执行顺序，优先级高的处理器会优先被选择

## 8. 迁移计划

1. **第一阶段**：实现基础组件修改
   - 修改特性定义
   - 创建基类
   - 优化扫描注册方法

2. **第二阶段**：迁移现有处理器
   - 逐步修改现有处理器，继承自基类并使用特性
   - 确保每个处理器的功能正常

3. **第三阶段**：全面启用自动注册
   - 修改 `ClientCommandHandlerRegistry.cs`，全面启用自动扫描注册
   - 移除冗余的手动注册代码

4. **第四阶段**：测试与验证
   - 确保所有命令处理器正常工作
   - 验证新的处理器添加方式是否正常