# 客户端命令处理架构设计文档

## 1. 架构概述

本文档描述了RUINORERP系统中的客户端命令处理架构设计。该架构采用了松耦合、可扩展的命令模式设计，用于处理客户端与服务器之间的各类命令通信，支持灵活的命令分发和处理。

### 1.1 设计目标

- **可扩展性**：支持轻松添加新的命令处理服务，无需修改核心通信组件
- **模块化**：各命令处理器独立封装，职责单一，便于维护
- **优先级机制**：支持命令处理器按优先级排序，确保重要命令优先处理
- **异步处理**：全面支持异步操作，提高系统响应性能
- **依赖注入友好**：与Autofac深度集成，便于服务注册和管理

## 2. 核心组件

### 2.1 命令处理器特性

**文件**：`ClientCommandHandlerAttribute.cs`

用于标记命令处理器类，设置处理器名称和优先级。

```csharp
/// <summary>
/// 客户端命令处理器特性
/// 用于标记命令处理器类并设置相关属性
/// </summary>
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
public class ClientCommandHandlerAttribute : Attribute
{
    /// <summary>
    /// 处理器名称
    /// </summary>
    public string Name { get; set; }

    /// <summary>
    /// 处理器优先级（数字越小优先级越高）
    /// </summary>
    public int Priority { get; set; }

    /// <summary>
    /// 构造函数
    /// </summary>
    /// <param name="name">处理器名称</param>
    /// <param name="priority">处理器优先级，默认50</param>
    public ClientCommandHandlerAttribute(string name, int priority = 50)
    {
        Name = name;
        Priority = priority;
    }
}
```

### 2.2 命令处理器接口

**文件**：`IClientCommandHandler.cs`

定义命令处理器的标准接口，所有命令处理器必须实现此接口。

```csharp
/// <summary>
/// 客户端命令处理器接口
/// 定义命令处理器的标准行为
/// </summary>
public interface IClientCommandHandler
{
    /// <summary>
    /// 处理器唯一标识
    /// </summary>
    string HandlerId { get; }

    /// <summary>
    /// 处理器名称
    /// </summary>
    string Name { get; }

    /// <summary>
    /// 处理器优先级
    /// </summary>
    int Priority { get; }

    /// <summary>
    /// 处理器当前状态
    /// </summary>
    ClientHandlerStatus Status { get; }

    /// <summary>
    /// 支持的命令列表
    /// </summary>
    IReadOnlyList<string> SupportedCommands { get; }

    /// <summary>
    /// 初始化处理器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>初始化任务</returns>
    Task InitializeAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// 启动处理器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>启动任务</returns>
    Task StartAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// 停止处理器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>停止任务</returns>
    Task StopAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// 处理命令
    /// </summary>
    /// <param name="commandName">命令名称</param>
    /// <param name="commandData">命令数据</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>处理结果</returns>
    Task<object> HandleAsync(string commandName, object commandData, CancellationToken cancellationToken = default);

    /// <summary>
    /// 检查是否支持指定命令
    /// </summary>
    /// <param name="commandName">命令名称</param>
    /// <returns>是否支持</returns>
    bool CanHandle(string commandName);
}

/// <summary>
/// 客户端处理器状态枚举
/// </summary>
public enum ClientHandlerStatus
{
    /// <summary>
    /// 未初始化
    /// </summary>
    Uninitialized,
    /// <summary>
    /// 已初始化
    /// </summary>
    Initialized,
    /// <summary>
    /// 正在启动
    /// </summary>
    Starting,
    /// <summary>
    /// 已启动
    /// </summary>
    Started,
    /// <summary>
    /// 正在停止
    /// </summary>
    Stopping,
    /// <summary>
    /// 已停止
    /// </summary>
    Stopped,
    /// <summary>
    /// 出错
    /// </summary>
    Error
}
```

### 2.3 命令处理器基类

**文件**：`BaseClientCommandHandler.cs`

提供命令处理器的通用实现，简化具体处理器的开发。

```csharp
/// <summary>
/// 客户端命令处理器基类
/// 提供命令处理器的通用实现
/// </summary>
public abstract class BaseClientCommandHandler : IClientCommandHandler
{
    private readonly List<string> _supportedCommands = new List<string>();
    private ClientHandlerStatus _status = ClientHandlerStatus.Uninitialized;
    private readonly ILog _logger;

    /// <summary>
    /// 处理器唯一标识
    /// </summary>
    public string HandlerId { get; } = Guid.NewGuid().ToString();

    /// <summary>
    /// 处理器名称
    /// </summary>
    public string Name { get; private set; }

    /// <summary>
    /// 处理器优先级
    /// </summary>
    public int Priority { get; private set; }

    /// <summary>
    /// 处理器当前状态
    /// </summary>
    public ClientHandlerStatus Status
    {
        get => _status;
        protected set
        {
            _status = value;
            OnStatusChanged();
        }
    }

    /// <summary>
    /// 支持的命令列表
    /// </summary>
    public IReadOnlyList<string> SupportedCommands => _supportedCommands.AsReadOnly();

    /// <summary>
    /// 构造函数
    /// </summary>
    protected BaseClientCommandHandler()
    {
        _logger = LogManager.GetLogger(GetType());
        InitializeFromAttribute();
    }

    /// <summary>
    /// 从特性初始化处理器信息
    /// </summary>
    private void InitializeFromAttribute()
    {
        var attribute = GetType().GetCustomAttribute<ClientCommandHandlerAttribute>();
        if (attribute != null)
        {
            Name = attribute.Name;
            Priority = attribute.Priority;
        }
        else
        {
            Name = GetType().Name;
            Priority = 50; // 默认优先级
        }
    }

    /// <summary>
    /// 添加支持的命令
    /// </summary>
    /// <param name="commandName">命令名称</param>
    protected void AddSupportedCommand(string commandName)
    {
        if (!_supportedCommands.Contains(commandName))
        {
            _supportedCommands.Add(commandName);
        }
    }

    /// <summary>
    /// 添加多个支持的命令
    /// </summary>
    /// <param name="commandNames">命令名称列表</param>
    protected void AddSupportedCommands(IEnumerable<string> commandNames)
    {
        foreach (var commandName in commandNames)
        {
            AddSupportedCommand(commandName);
        }
    }

    /// <summary>
    /// 初始化处理器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>初始化任务</returns>
    public virtual Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            Status = ClientHandlerStatus.Initialized;
            _logger.Info($"命令处理器 '{Name}' 初始化完成");
            return Task.CompletedTask;
        }
        catch (Exception ex)
        {
            _logger.Error($"命令处理器 '{Name}' 初始化失败: {ex.Message}", ex);
            Status = ClientHandlerStatus.Error;
            throw;
        }
    }

    /// <summary>
    /// 启动处理器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>启动任务</returns>
    public virtual Task StartAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            Status = ClientHandlerStatus.Started;
            _logger.Info($"命令处理器 '{Name}' 启动完成");
            return Task.CompletedTask;
        }
        catch (Exception ex)
        {
            _logger.Error($"命令处理器 '{Name}' 启动失败: {ex.Message}", ex);
            Status = ClientHandlerStatus.Error;
            throw;
        }
    }

    /// <summary>
    /// 停止处理器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>停止任务</returns>
    public virtual Task StopAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            Status = ClientHandlerStatus.Stopped;
            _logger.Info($"命令处理器 '{Name}' 停止完成");
            return Task.CompletedTask;
        }
        catch (Exception ex)
        {
            _logger.Error($"命令处理器 '{Name}' 停止失败: {ex.Message}", ex);
            throw;
        }
    }

    /// <summary>
    /// 处理命令
    /// </summary>
    /// <param name="commandName">命令名称</param>
    /// <param name="commandData">命令数据</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>处理结果</returns>
    public abstract Task<object> HandleAsync(string commandName, object commandData, CancellationToken cancellationToken = default);

    /// <summary>
    /// 检查是否支持指定命令
    /// </summary>
    /// <param name="commandName">命令名称</param>
    /// <returns>是否支持</returns>
    public bool CanHandle(string commandName)
    {
        return _supportedCommands.Contains(commandName);
    }

    /// <summary>
    /// 状态变更时触发
    /// </summary>
    protected virtual void OnStatusChanged()
    {
        // 可由子类重写以处理状态变更事件
    }

    /// <summary>
    /// 记录命令处理日志
    /// </summary>
    /// <param name="commandName">命令名称</param>
    /// <param name="success">是否成功</param>
    /// <param name="message">日志消息</param>
    protected void LogCommandHandling(string commandName, bool success, string message = null)
    {
        if (success)
        {
            _logger.Info($"处理器 '{Name}' 成功处理命令 '{commandName}'{(string.IsNullOrEmpty(message) ? "" : $": {message}")}");
        }
        else
        {
            _logger.Error($"处理器 '{Name}' 处理命令 '{commandName}' 失败{(string.IsNullOrEmpty(message) ? "" : $": {message}")}");
        }
    }
}
```

### 2.4 命令调度器接口

**文件**：`IClientCommandDispatcher.cs`

定义命令调度器的标准接口，负责命令的分发和处理。

```csharp
/// <summary>
/// 客户端命令调度器接口
/// 负责命令的分发和处理
/// </summary>
public interface IClientCommandDispatcher
{
    /// <summary>
    /// 调度器状态
    /// </summary>
    ClientHandlerStatus Status { get; }

    /// <summary>
    /// 已注册的处理器列表
    /// </summary>
    IReadOnlyList<IClientCommandHandler> Handlers { get; }

    /// <summary>
    /// 初始化调度器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>初始化任务</returns>
    Task InitializeAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// 启动调度器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>启动任务</returns>
    Task StartAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// 停止调度器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>停止任务</returns>
    Task StopAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// 注册命令处理器
    /// </summary>
    /// <param name="handler">命令处理器</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>注册任务</returns>
    Task RegisterHandlerAsync(IClientCommandHandler handler, CancellationToken cancellationToken = default);

    /// <summary>
    /// 取消注册命令处理器
    /// </summary>
    /// <param name="handlerId">处理器ID</param>
    /// <returns>是否取消成功</returns>
    bool UnregisterHandler(string handlerId);

    /// <summary>
    /// 扫描并注册程序集中的命令处理器
    /// </summary>
    /// <param name="assembly">要扫描的程序集</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>注册的处理器数量</returns>
    Task<int> ScanAndRegisterHandlersAsync(Assembly assembly, CancellationToken cancellationToken = default);

    /// <summary>
    /// 分发并处理命令
    /// </summary>
    /// <param name="commandName">命令名称</param>
    /// <param name="commandData">命令数据</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>处理结果</returns>
    Task<object> DispatchCommandAsync(string commandName, object commandData, CancellationToken cancellationToken = default);

    /// <summary>
    /// 查找能够处理指定命令的处理器
    /// </summary>
    /// <param name="commandName">命令名称</param>
    /// <returns>命令处理器列表（按优先级排序）</returns>
    IReadOnlyList<IClientCommandHandler> FindHandlersForCommand(string commandName);

    /// <summary>
    /// 查找指定ID的处理器
    /// </summary>
    /// <param name="handlerId">处理器ID</param>
    /// <returns>命令处理器，如果不存在则返回null</returns>
    IClientCommandHandler FindHandlerById(string handlerId);
}
```

### 2.5 命令调度器实现

**文件**：`ClientCommandDispatcher.cs`

实现命令调度器接口，提供命令分发和处理的核心逻辑。

```csharp
/// <summary>
/// 客户端命令调度器实现
/// 负责命令的分发和处理
/// </summary>
public class ClientCommandDispatcher : IClientCommandDispatcher
{
    private readonly List<IClientCommandHandler> _handlers = new List<IClientCommandHandler>();
    private readonly Dictionary<string, List<IClientCommandHandler>> _commandHandlersMap = new Dictionary<string, List<IClientCommandHandler>>();
    private ClientHandlerStatus _status = ClientHandlerStatus.Uninitialized;
    private readonly ILog _logger;
    private readonly object _lock = new object();

    /// <summary>
    /// 调度器状态
    /// </summary>
    public ClientHandlerStatus Status => _status;

    /// <summary>
    /// 已注册的处理器列表
    /// </summary>
    public IReadOnlyList<IClientCommandHandler> Handlers => _handlers.AsReadOnly();

    /// <summary>
    /// 构造函数
    /// </summary>
    public ClientCommandDispatcher()
    {
        _logger = LogManager.GetLogger(typeof(ClientCommandDispatcher));
    }

    /// <summary>
    /// 初始化调度器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>初始化任务</returns>
    public async Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.Info("客户端命令调度器正在初始化...");
            _status = ClientHandlerStatus.Initializing;

            // 初始化所有已注册的处理器
            foreach (var handler in _handlers.ToList())
            {
                await handler.InitializeAsync(cancellationToken);
            }

            _status = ClientHandlerStatus.Initialized;
            _logger.Info("客户端命令调度器初始化完成");
        }
        catch (Exception ex)
        {
            _logger.Error("客户端命令调度器初始化失败: " + ex.Message, ex);
            _status = ClientHandlerStatus.Error;
            throw;
        }
    }

    /// <summary>
    /// 启动调度器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>启动任务</returns>
    public async Task StartAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.Info("客户端命令调度器正在启动...");
            _status = ClientHandlerStatus.Starting;

            // 启动所有已注册的处理器
            foreach (var handler in _handlers.ToList())
            {
                if (handler.Status == ClientHandlerStatus.Initialized)
                {
                    await handler.StartAsync(cancellationToken);
                }
            }

            _status = ClientHandlerStatus.Started;
            _logger.Info("客户端命令调度器启动完成");
        }
        catch (Exception ex)
        {
            _logger.Error("客户端命令调度器启动失败: " + ex.Message, ex);
            _status = ClientHandlerStatus.Error;
            throw;
        }
    }

    /// <summary>
    /// 停止调度器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>停止任务</returns>
    public async Task StopAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.Info("客户端命令调度器正在停止...");
            _status = ClientHandlerStatus.Stopping;

            // 停止所有已注册的处理器
            foreach (var handler in _handlers.ToList())
            {
                if (handler.Status == ClientHandlerStatus.Started)
                {
                    await handler.StopAsync(cancellationToken);
                }
            }

            _status = ClientHandlerStatus.Stopped;
            _logger.Info("客户端命令调度器停止完成");
        }
        catch (Exception ex)
        {
            _logger.Error("客户端命令调度器停止失败: " + ex.Message, ex);
            throw;
        }
    }

    /// <summary>
    /// 注册命令处理器
    /// </summary>
    /// <param name="handler">命令处理器</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>注册任务</returns>
    public async Task RegisterHandlerAsync(IClientCommandHandler handler, CancellationToken cancellationToken = default)
    {
        if (handler == null)
        {
            throw new ArgumentNullException(nameof(handler));
        }

        lock (_lock)
        {
            // 检查是否已注册
            if (_handlers.Any(h => h.HandlerId == handler.HandlerId))
            {
                _logger.Warn($"命令处理器 '{handler.Name}' (ID: {handler.HandlerId}) 已注册，跳过");
                return;
            }

            _handlers.Add(handler);

            // 更新命令到处理器的映射
            foreach (var command in handler.SupportedCommands)
            {
                if (!_commandHandlersMap.TryGetValue(command, out var commandHandlers))
                {
                    commandHandlers = new List<IClientCommandHandler>();
                    _commandHandlersMap[command] = commandHandlers;
                }
                commandHandlers.Add(handler);

                // 按优先级排序
                commandHandlers.Sort((h1, h2) => h1.Priority.CompareTo(h2.Priority));
            }
        }

        _logger.Info($"命令处理器 '{handler.Name}' (ID: {handler.HandlerId}) 注册成功，支持的命令数: {handler.SupportedCommands.Count}");

        // 如果调度器已初始化或启动，则初始化并启动新处理器
        if (_status >= ClientHandlerStatus.Initialized)
        {
            await handler.InitializeAsync(cancellationToken);
        }

        if (_status >= ClientHandlerStatus.Started)
        {
            await handler.StartAsync(cancellationToken);
        }
    }

    /// <summary>
    /// 取消注册命令处理器
    /// </summary>
    /// <param name="handlerId">处理器ID</param>
    /// <returns>是否取消成功</returns>
    public bool UnregisterHandler(string handlerId)
    {
        if (string.IsNullOrEmpty(handlerId))
        {
            throw new ArgumentNullException(nameof(handlerId));
        }

        lock (_lock)
        {
            var handler = _handlers.FirstOrDefault(h => h.HandlerId == handlerId);
            if (handler == null)
            {
                _logger.Warn($"未找到ID为 '{handlerId}' 的命令处理器，取消注册失败");
                return false;
            }

            _handlers.Remove(handler);

            // 更新命令到处理器的映射
            foreach (var command in handler.SupportedCommands)
            {
                if (_commandHandlersMap.TryGetValue(command, out var commandHandlers))
                {
                    commandHandlers.Remove(handler);
                    if (commandHandlers.Count == 0)
                    {
                        _commandHandlersMap.Remove(command);
                    }
                }
            }
        }

        _logger.Info($"命令处理器 (ID: {handlerId}) 取消注册成功");
        return true;
    }

    /// <summary>
    /// 扫描并注册程序集中的命令处理器
    /// </summary>
    /// <param name="assembly">要扫描的程序集</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>注册的处理器数量</returns>
    public async Task<int> ScanAndRegisterHandlersAsync(Assembly assembly, CancellationToken cancellationToken = default)
    {
        if (assembly == null)
        {
            throw new ArgumentNullException(nameof(assembly));
        }

        _logger.Info($"正在扫描程序集 '{assembly.GetName().Name}' 中的命令处理器...");

        var handlerTypes = assembly.GetTypes()
            .Where(t => typeof(IClientCommandHandler).IsAssignableFrom(t) && t.IsClass && !t.IsAbstract && !t.IsInterface)
            .ToList();

        _logger.Info($"找到 {handlerTypes.Count} 个命令处理器类型");

        int registeredCount = 0;
        foreach (var handlerType in handlerTypes)
        {
            try
            {
                var handler = (IClientCommandHandler)Activator.CreateInstance(handlerType);
                await RegisterHandlerAsync(handler, cancellationToken);
                registeredCount++;
            }
            catch (Exception ex)
            {
                _logger.Error($"创建并注册命令处理器 '{handlerType.FullName}' 失败: {ex.Message}", ex);
            }
        }

        _logger.Info($"程序集 '{assembly.GetName().Name}' 中的命令处理器扫描完成，成功注册 {registeredCount} 个");
        return registeredCount;
    }

    /// <summary>
    /// 分发并处理命令
    /// </summary>
    /// <param name="commandName">命令名称</param>
    /// <param name="commandData">命令数据</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>处理结果</returns>
    public async Task<object> DispatchCommandAsync(string commandName, object commandData, CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrEmpty(commandName))
        {
            throw new ArgumentNullException(nameof(commandName));
        }

        if (_status != ClientHandlerStatus.Started)
        {
            throw new InvalidOperationException($"命令调度器状态为 '{_status}'，无法处理命令");
        }

        _logger.Info($"开始分发命令 '{commandName}'");

        var handlers = FindHandlersForCommand(commandName);
        if (handlers.Count == 0)
        {
            _logger.Warn($"未找到能够处理命令 '{commandName}' 的处理器");
            return null;
        }

        // 按优先级顺序尝试处理命令
        foreach (var handler in handlers)
        {
            try
            {
                _logger.Debug($"尝试使用处理器 '{handler.Name}' (优先级: {handler.Priority}) 处理命令 '{commandName}'");
                var result = await handler.HandleAsync(commandName, commandData, cancellationToken);
                _logger.Info($"命令 '{commandName}' 已由处理器 '{handler.Name}' 成功处理");
                return result;
            }
            catch (Exception ex)
            {
                _logger.Error($"处理器 '{handler.Name}' 处理命令 '{commandName}' 时发生错误: {ex.Message}", ex);
                // 可以选择继续尝试下一个处理器，或者直接抛出异常
                // 这里选择继续尝试下一个处理器
            }
        }

        throw new Exception($"所有能够处理命令 '{commandName}' 的处理器都处理失败");
    }

    /// <summary>
    /// 查找能够处理指定命令的处理器
    /// </summary>
    /// <param name="commandName">命令名称</param>
    /// <returns>命令处理器列表（按优先级排序）</returns>
    public IReadOnlyList<IClientCommandHandler> FindHandlersForCommand(string commandName)
    {
        if (string.IsNullOrEmpty(commandName))
        {
            throw new ArgumentNullException(nameof(commandName));
        }

        lock (_lock)
        {
            if (_commandHandlersMap.TryGetValue(commandName, out var handlers))
            {
                return handlers.AsReadOnly();
            }
            return new List<IClientCommandHandler>().AsReadOnly();
        }
    }

    /// <summary>
    /// 查找指定ID的处理器
    /// </summary>
    /// <param name="handlerId">处理器ID</param>
    /// <returns>命令处理器，如果不存在则返回null</returns>
    public IClientCommandHandler FindHandlerById(string handlerId)
    {
        if (string.IsNullOrEmpty(handlerId))
        {
            throw new ArgumentNullException(nameof(handlerId));
        }

        return _handlers.FirstOrDefault(h => h.HandlerId == handlerId);
    }
}
```

## 3. 具体命令处理器示例

### 3.1 配置命令处理器

**文件**：`ConfigCommandHandler.cs`

处理配置同步命令的具体实现。

```csharp
/// <summary>
/// 配置命令处理器
/// 负责处理与配置相关的命令
/// </summary>
[ClientCommandHandler("配置命令处理器", 20)]
public class ConfigCommandHandler : BaseClientCommandHandler
{
    private readonly OptionsMonitorConfigManager _configManager;

    /// <summary>
    /// 构造函数
    /// </summary>
    /// <param name="configManager">配置管理器</param>
    public ConfigCommandHandler(OptionsMonitorConfigManager configManager)
    {
        _configManager = configManager ?? throw new ArgumentNullException(nameof(configManager));
        
        // 添加支持的命令
        AddSupportedCommand(GeneralCommands.ConfigSync);
    }

    /// <summary>
    /// 初始化处理器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>初始化任务</returns>
    public override Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        LogCommandHandling("初始化", true, "配置命令处理器初始化完成");
        return base.InitializeAsync(cancellationToken);
    }

    /// <summary>
    /// 处理命令
    /// </summary>
    /// <param name="commandName">命令名称</param>
    /// <param name="commandData">命令数据</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>处理结果</returns>
    public override async Task<object> HandleAsync(string commandName, object commandData, CancellationToken cancellationToken = default)
    {
        switch (commandName)
        {
            case GeneralCommands.ConfigSync:
                return await HandleConfigSyncCommandAsync(commandData, cancellationToken);
            default:
                throw new NotSupportedException($"不支持的命令: {commandName}");
        }
    }

    /// <summary>
    /// 处理配置同步命令
    /// </summary>
    /// <param name="commandData">命令数据</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>处理结果</returns>
    private async Task<object> HandleConfigSyncCommandAsync(object commandData, CancellationToken cancellationToken = default)
    {
        try
        {
            // 确保命令数据是字典类型
            if (commandData is Dictionary<string, object> configData)
            {
                // 提取配置类型
                if (configData.TryGetValue("ConfigType", out var configTypeObj) && configTypeObj is string configType)
                {
                    // 提取配置数据
                    if (configData.TryGetValue("ConfigData", out var configDataObj))
                    {
                        // 序列化配置数据为JSON字符串
                        var configJson = JsonConvert.SerializeObject(configDataObj);
                        
                        // 调用配置管理器处理配置同步
                        bool success = _configManager.HandleConfigSync(configType, configJson);
                        
                        if (success)
                        {
                            LogCommandHandling(GeneralCommands.ConfigSync, true, $"配置类型 '{configType}' 同步成功");
                            return new { Success = true, ConfigType = configType };
                        }
                        else
                        {
                            LogCommandHandling(GeneralCommands.ConfigSync, false, $"配置类型 '{configType}' 同步失败");
                            return new { Success = false, ConfigType = configType, Error = "配置同步处理失败" };
                        }
                    }
                }
            }
            
            LogCommandHandling(GeneralCommands.ConfigSync, false, "命令数据格式错误");
            return new { Success = false, Error = "命令数据格式错误" };
        }
        catch (Exception ex)
        {
            LogCommandHandling(GeneralCommands.ConfigSync, false, ex.Message);
            return new { Success = false, Error = ex.Message };
        }
    }
}
```

### 3.2 消息命令处理器

**文件**：`MessageCommandHandler.cs`

处理消息相关命令的具体实现。

```csharp
/// <summary>
/// 消息命令处理器
/// 负责处理与消息相关的命令
/// </summary>
[ClientCommandHandler("消息命令处理器", 30)]
public class MessageCommandHandler : BaseClientCommandHandler
{
    /// <summary>
    /// 构造函数
    /// </summary>
    public MessageCommandHandler()
    {
        // 添加支持的命令
        AddSupportedCommands(new[]
        {
            "ShowMessage",
            "ShowNotification",
            "ShowSystemMessage"
        });
    }

    /// <summary>
    /// 初始化处理器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>初始化任务</returns>
    public override Task InitializeAsync(CancellationToken cancellationToken = default)
    {
        LogCommandHandling("初始化", true, "消息命令处理器初始化完成");
        return base.InitializeAsync(cancellationToken);
    }

    /// <summary>
    /// 处理命令
    /// </summary>
    /// <param name="commandName">命令名称</param>
    /// <param name="commandData">命令数据</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>处理结果</returns>
    public override async Task<object> HandleAsync(string commandName, object commandData, CancellationToken cancellationToken = default)
    {
        switch (commandName)
        {
            case "ShowMessage":
                return await HandleShowMessageCommandAsync(commandData, cancellationToken);
            case "ShowNotification":
                return await HandleShowNotificationCommandAsync(commandData, cancellationToken);
            case "ShowSystemMessage":
                return await HandleShowSystemMessageCommandAsync(commandData, cancellationToken);
            default:
                throw new NotSupportedException($"不支持的命令: {commandName}");
        }
    }

    /// <summary>
    /// 处理显示消息命令
    /// </summary>
    /// <param name="commandData">命令数据</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>处理结果</returns>
    private Task<object> HandleShowMessageCommandAsync(object commandData, CancellationToken cancellationToken = default)
    {
        try
        {
            if (commandData is Dictionary<string, object> messageData)
            {
                string message = messageData.TryGetValue("Message", out var msgObj) ? msgObj.ToString() : "";
                string title = messageData.TryGetValue("Title", out var titleObj) ? titleObj.ToString() : "系统消息";
                
                // 在UI线程显示消息框
                Application.Current.Dispatcher.Invoke(() =>
                {
                    MessageBox.Show(message, title, MessageBoxButton.OK, MessageBoxImage.Information);
                });
                
                LogCommandHandling("ShowMessage", true, "消息显示成功");
                return Task.FromResult<object>(new { Success = true });
            }
            
            LogCommandHandling("ShowMessage", false, "命令数据格式错误");
            return Task.FromResult<object>(new { Success = false, Error = "命令数据格式错误" });
        }
        catch (Exception ex)
        {
            LogCommandHandling("ShowMessage", false, ex.Message);
            return Task.FromResult<object>(new { Success = false, Error = ex.Message });
        }
    }

    /// <summary>
    /// 处理显示通知命令
    /// </summary>
    /// <param name="commandData">命令数据</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>处理结果</returns>
    private Task<object> HandleShowNotificationCommandAsync(object commandData, CancellationToken cancellationToken = default)
    {
        try
        {
            // 通知处理逻辑
            LogCommandHandling("ShowNotification", true, "通知处理成功");
            return Task.FromResult<object>(new { Success = true });
        }
        catch (Exception ex)
        {
            LogCommandHandling("ShowNotification", false, ex.Message);
            return Task.FromResult<object>(new { Success = false, Error = ex.Message });
        }
    }

    /// <summary>
    /// 处理显示系统消息命令
    /// </summary>
    /// <param name="commandData">命令数据</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>处理结果</returns>
    private Task<object> HandleShowSystemMessageCommandAsync(object commandData, CancellationToken cancellationToken = default)
    {
        try
        {
            // 系统消息处理逻辑
            LogCommandHandling("ShowSystemMessage", true, "系统消息处理成功");
            return Task.FromResult<object>(new { Success = true });
        }
        catch (Exception ex)
        {
            LogCommandHandling("ShowSystemMessage", false, ex.Message);
            return Task.FromResult<object>(new { Success = false, Error = ex.Message });
        }
    }
}
```

## 4. 服务注册和依赖注入

### 4.1 命令处理器注册器

**文件**：`ClientCommandHandlerRegistry.cs`

负责注册所有客户端命令处理器到调度器。

```csharp
/// <summary>
/// 客户端命令处理器注册器
/// 负责注册所有客户端命令处理器到调度器
/// </summary>
public class ClientCommandHandlerRegistry
{
    private readonly IClientCommandDispatcher _commandDispatcher;
    private readonly ILifetimeScope _scope;
    private readonly ILog _logger;

    /// <summary>
    /// 构造函数
    /// </summary>
    /// <param name="commandDispatcher">命令调度器</param>
    /// <param name="scope">Autofac生命周期作用域</param>
    public ClientCommandHandlerRegistry(IClientCommandDispatcher commandDispatcher, ILifetimeScope scope)
    {
        _commandDispatcher = commandDispatcher ?? throw new ArgumentNullException(nameof(commandDispatcher));
        _scope = scope ?? throw new ArgumentNullException(nameof(scope));
        _logger = LogManager.GetLogger(typeof(ClientCommandHandlerRegistry));
    }

    /// <summary>
    /// 注册所有命令处理器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>注册任务</returns>
    public async Task RegisterAllHandlersAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.Info("开始注册客户端命令处理器...");

            // 注册配置命令处理器
            await RegisterConfigCommandHandlerAsync(cancellationToken);

            // 注册消息命令处理器
            await RegisterMessageCommandHandlerAsync(cancellationToken);

            // 可以在这里添加更多处理器的注册

            _logger.Info("客户端命令处理器注册完成");
        }
        catch (Exception ex)
        {
            _logger.Error("注册客户端命令处理器失败: " + ex.Message, ex);
            throw;
        }
    }

    /// <summary>
    /// 注册配置命令处理器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>注册任务</returns>
    private async Task RegisterConfigCommandHandlerAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            // 从容器中解析配置命令处理器
            var handler = _scope.Resolve<ConfigCommandHandler>();
            await _commandDispatcher.RegisterHandlerAsync(handler, cancellationToken);
            _logger.Info("配置命令处理器注册成功");
        }
        catch (Exception ex)
        {
            _logger.Error("注册配置命令处理器失败: " + ex.Message, ex);
            throw;
        }
    }

    /// <summary>
    /// 注册消息命令处理器
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>注册任务</returns>
    private async Task RegisterMessageCommandHandlerAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            // 从容器中解析消息命令处理器
            var handler = _scope.Resolve<MessageCommandHandler>();
            await _commandDispatcher.RegisterHandlerAsync(handler, cancellationToken);
            _logger.Info("消息命令处理器注册成功");
        }
        catch (Exception ex)
        {
            _logger.Error("注册消息命令处理器失败: " + ex.Message, ex);
            throw;
        }
    }
}
```

### 4.2 Autofac模块

**文件**：`ClientCommandHandlerModule.cs`

用于注册客户端命令处理相关组件到依赖注入容器。

```csharp
/// <summary>
/// 客户端命令处理器Autofac模块
/// 负责注册所有客户端命令处理相关组件到依赖注入容器
/// </summary>
public class ClientCommandHandlerModule : Module
{
    /// <summary>
    /// 加载模块，注册服务
    /// </summary>
    /// <param name="builder">Autofac容器构建器</param>
    protected override void Load(ContainerBuilder builder)
    {
        // 注册客户端命令调度器
        builder.RegisterType<ClientCommandDispatcher>()
            .As<IClientCommandDispatcher>()
            .SingleInstance()
            .InstancePerLifetimeScope();

        // 注册命令处理器注册器
        builder.RegisterType<ClientCommandHandlerRegistry>()
            .AsSelf()
            .InstancePerLifetimeScope();

        // 注册命令处理器
        builder.RegisterType<ConfigCommandHandler>()
            .AsSelf()
            .InstancePerLifetimeScope();

        builder.RegisterType<MessageCommandHandler>()
            .AsSelf()
            .InstancePerLifetimeScope();

        // 在容器构建完成后初始化命令调度器并注册所有命令处理器
        builder.RegisterBuildCallback(scope =>
        {
            try
            {
                // 解析命令调度器
                var commandDispatcher = scope.Resolve<IClientCommandDispatcher>();
                
                // 初始化调度器
                commandDispatcher.InitializeAsync().Wait();
                
                // 注册所有命令处理器
                var registry = scope.Resolve<ClientCommandHandlerRegistry>();
                registry.RegisterAllHandlersAsync().Wait();
                
                // 启动调度器
                commandDispatcher.StartAsync().Wait();
            }
            catch (Exception ex)
            {
                var logger = LogManager.GetLogger(typeof(ClientCommandHandlerModule));
                logger.Error("初始化客户端命令调度器失败: " + ex.Message, ex);
                throw;
            }
        });
    }
}
```

## 5. 与现有系统集成

### 5.1 修改ClientCommunicationService

**文件**：`ClientCommunicationService.cs`

更新ClientCommunicationService，使其使用新的命令调度器处理命令。

```csharp
// 添加命名空间引用
using RUINORERP.UI.Network.ClientCommandHandlers;

public class ClientCommunicationService : IClientCommunicationService
{
    // 添加命令调度器字段
    private readonly IClientCommandDispatcher _clientCommandDispatcher;
    private readonly OptionsMonitorConfigManager _optionsMonitorConfigManager;
    // 其他字段...

    // 更新构造函数，注入命令调度器
    public ClientCommunicationService(
        ISocketClient socketClient,
        ICommandDispatcher commandDispatcher,
        IClientCommandDispatcher clientCommandDispatcher,
        OptionsMonitorConfigManager optionsMonitorConfigManager,
        // 其他依赖...
        )
    {
        // 初始化其他字段...
        _clientCommandDispatcher = clientCommandDispatcher;
        _optionsMonitorConfigManager = optionsMonitorConfigManager;
        
        // 初始化客户端命令调度器
        InitializeClientCommandDispatcher();
    }

    // 初始化客户端命令调度器
    private void InitializeClientCommandDispatcher()
    {
        try
        {
            // 确保调度器已初始化和启动
            if (_clientCommandDispatcher.Status < ClientHandlerStatus.Initialized)
            {
                _clientCommandDispatcher.InitializeAsync().Wait();
            }
            
            if (_clientCommandDispatcher.Status < ClientHandlerStatus.Started)
            {
                _clientCommandDispatcher.StartAsync().Wait();
            }
        }
        catch (Exception ex)
        {
            // 记录错误但不中断初始化
            var logger = LogManager.GetLogger(typeof(ClientCommunicationService));
            logger.Error("初始化客户端命令调度器失败: " + ex.Message, ex);
        }
    }

    // 更新ProcessCommandAsync方法，优先使用客户端命令调度器
    public async Task ProcessCommandAsync(BaseCommand command)
    {
        // 检查命令是否为null
        if (command == null)
        {
            return;
        }

        try
        {
            // 优先尝试使用客户端命令调度器处理命令
            if (_clientCommandDispatcher.Status == ClientHandlerStatus.Started)
            {
                var result = await _clientCommandDispatcher.DispatchCommandAsync(
                    command.CommandName,
                    command.CommandData ?? new Dictionary<string, object>(),
                    CancellationToken.None);
                
                // 如果命令被成功处理，则直接返回
                if (result != null && result is IDictionary<string, object> resultDict && 
                    resultDict.TryGetValue("Success", out var successObj) && successObj is bool success && success)
                {
                    return;
                }
            }

            // 如果客户端命令调度器未处理，使用原有的处理逻辑
            switch (command.CommandCategory)
            {
                case CommandCategory.System:
                    await ProcessSystemCommandAsync(command);
                    break;
                case CommandCategory.Cache:
                    await ProcessCacheCommandAsync(command);
                    break;
                case CommandCategory.Authentication:
                    await ProcessAuthenticationCommandAsync(command);
                    break;
                // 移除Config类别，由客户端命令调度器处理
                // case CommandCategory.Config:
                //     await ProcessConfigCommandAsync(command);
                //     break;
                default:
                    await commandDispatcher.DispatchAsync(command);
                    break;
            }
        }
        catch (Exception ex)
        {
            // 错误处理...
        }
    }

    // 其他方法...
}
```

### 5.2 在Startup中注册模块

**文件**：`RUINORERP.UI\Startup.cs`

在RegisterProjectModuleServices方法中注册ClientCommandHandlerModule。

```csharp
private static void RegisterProjectModuleServices(ContainerBuilder builder)
{
    try
    {
        // 配置各项目的依赖注入
        BusinessDIConfig.ConfigureContainer(builder);      // Business项目
        ServicesDIConfig.ConfigureContainer(builder);      // Services项目
        RepositoryDIConfig.ConfigureContainer(builder);    // Repository项目
        IServicesDIConfig.ConfigureContainer(builder);     // IServices项目
        
        // 注册客户端命令处理模块
        builder.RegisterModule(new RUINORERP.UI.Network.ClientCommandHandlers.ClientCommandHandlerModule());
    }
    catch (Exception ex)
    {
        // 错误处理...
    }
}
```

## 6. 架构工作流程

### 6.1 初始化流程

1. **容器初始化**：应用程序启动时，Autofac容器初始化并加载ClientCommandHandlerModule
2. **组件注册**：ClientCommandHandlerModule注册ClientCommandDispatcher、ClientCommandHandlerRegistry和所有具体的命令处理器
3. **调度器初始化**：容器构建完成后，自动初始化ClientCommandDispatcher
4. **处理器注册**：ClientCommandHandlerRegistry注册所有命令处理器到调度器
5. **调度器启动**：ClientCommandDispatcher启动并准备处理命令

### 6.2 命令处理流程

1. **命令接收**：ClientCommunicationService接收来自服务器的命令
2. **命令分发**：ClientCommunicationService将命令传递给ClientCommandDispatcher
3. **处理器查找**：ClientCommandDispatcher根据命令名称查找能够处理该命令的处理器（按优先级排序）
4. **命令执行**：找到的处理器执行命令处理逻辑
5. **结果返回**：处理结果返回给ClientCommunicationService

## 7. 扩展架构

要添加新的命令处理器，只需遵循以下步骤：

1. 创建一个新的命令处理器类，继承自BaseClientCommandHandler
2. 使用ClientCommandHandler特性标记类，并设置名称和优先级
3. 在构造函数中添加支持的命令
4. 实现HandleAsync方法处理具体命令
5. 在ClientCommandHandlerRegistry中注册新的处理器
6. 在ClientCommandHandlerModule中注册处理器类型到Autofac容器

## 8. 最佳实践

- **单一职责**：每个命令处理器应专注于处理特定类型的命令
- **优先级设置**：根据命令重要性设置适当的优先级
- **错误处理**：每个处理器应包含完善的错误处理逻辑
- **日志记录**：使用LogCommandHandling方法记录命令处理过程
- **异步处理**：优先使用异步方法处理命令，提高系统响应性能
- **依赖注入**：通过构造函数注入依赖，避免硬编码依赖关系

## 9. 故障排除

### 9.1 常见问题

1. **命令未被处理**
   - 检查命令名称是否正确
   - 确保命令处理器已正确注册
   - 验证处理器的CanHandle方法返回true

2. **处理器未注册**
   - 检查ClientCommandHandlerRegistry中是否注册了处理器
   - 确认处理器类型已在ClientCommandHandlerModule中注册
   - 检查处理器构造函数依赖是否已在容器中注册

3. **调度器未启动**
   - 检查ClientCommandHandlerModule中的初始化逻辑
   - 验证ClientCommunicationService中的初始化方法
   - 查看日志文件了解详细错误信息

## 10. 总结

本客户端命令处理架构提供了一个灵活、可扩展的框架，用于处理客户端与服务器之间的各类命令通信。通过采用命令模式和依赖注入，实现了松耦合、模块化的设计，便于未来扩展和维护。