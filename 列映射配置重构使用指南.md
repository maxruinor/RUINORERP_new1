# 列映射配置重构使用指南

## 重构概述

本次重构将原本分离的中英文属性整合为统一的`SerializableKeyValuePair`键值对数据结构，实现了以下目标：

### 1. 新增数据结构（位于RUINORERP.Common项目）

#### SerializableKeyValuePair<TKey, TValue>（双泛型版本）
```csharp
[XmlRoot("KeyValue")]
public class SerializableKeyValuePair<TKey, TValue>
{
    [XmlAttribute("Key")]
    public TKey Key { get; set; }           // 键（用于代码操作）

    [XmlAttribute("Value")]
    public TValue Value { get; set; }       // 值（用于UI展示或存储）
}
```

**XML序列化格式：**
```xml
<KeyValue Key="PID" Value="父类ID" />
```

#### SerializableKeyValuePair<TValue>（单泛型版本）
Key固定为string，最常用的版本。
```csharp
[XmlRoot("KeyValue")]
public class SerializableKeyValuePair<TValue> : SerializableKeyValuePair<string, TValue>
{
    // Key固定为string
    // Value可以是任意类型
}
```

#### SerializableKeyValuePair（非泛型版本）
Key和Value都是string，向后兼容版本。
```csharp
[XmlRoot("KeyValue")]
public class SerializableKeyValuePair : SerializableKeyValuePair<string>
{
    // Key和Value都是string
}
```

### 2. ColumnMapping类属性变更

#### 变更前（旧结构）
```csharp
public string SystemField { get; set; }              // 英文字段名
public string SystemFieldDisplayName { get; set; }   // 中文名
public string RelatedTableName { get; set; }        // 英文表名
public string RelatedTableField { get; set; }        // 中文名
public string RelatedTableFieldName { get; set; }   // 英文字段名
public string SelfReferenceFieldName { get; set; }   // 英文字段名
public string SelfReferenceFieldDisplayName { get; set; } // 中文名
```

#### 变更后（新结构）
```csharp
public FieldReference SystemField { get; set; }           // 系统字段引用
public TableReference TargetTable { get; set; }           // 目标表引用
public TableReference ForeignKeyTable { get; set; }       // 外键表引用
public FieldReference ForeignKeyField { get; set; }       // 外键字段引用
public FieldReference SelfReferenceField { get; set; }     // 自身引用字段
```

### 3. 向后兼容属性

为保持向后兼容，提供了以下属性：
```csharp
// SystemField向后兼容
[XmlIgnore]
public string SystemField => SystemField?.Key;

// EntityType向后兼容
[XmlIgnore]
public string EntityType
{
    get => TargetTable?.Key;
    set => TargetTable = new TableReference(value, GetTableDisplayName(value));
}

// RelatedTableName向后兼容
[XmlIgnore]
public string RelatedTableName
{
    get => ForeignKeyTable?.Key;
    set => ForeignKeyTable = new TableReference(value, GetTableDisplayName(value));
}
```

## 使用示例

### 1. 创建字段映射（代码层）
```csharp
// 方法一：使用构造函数
var mapping = new ColumnMapping
{
    SystemField = new FieldReference("PID", "父类ID"),
    TargetTable = new TableReference("tb_ProdCategories", "产品类目表"),
    ForeignKeyTable = new TableReference("tb_Prod", "产品表"),
    ForeignKeyField = new FieldReference("PID", "父类ID")
};

// 方法二：使用隐式转换
var mapping = new ColumnMapping
{
    SystemField = new KeyValuePair<string, string>("PID", "父类ID"),
    TargetTable = ("tb_ProdCategories", "产品类目表")
};

// 方法三：链式赋值
mapping.SystemField.Key = "PID";
mapping.SystemField.DisplayName = "父类ID";
```

### 2. UI层显示
```csharp
// 显示中文名称给用户
lblField.Text = mapping.SystemField?.DisplayName ?? "未设置";
lblTable.Text = mapping.TargetTable?.DisplayName ?? "未设置";

// 显示外键信息
if (mapping.IsForeignKey)
{
    lblForeignKey.Text = $"关联表：{mapping.ForeignKeyTable?.DisplayName}，" +
                        $"关联字段：{mapping.ForeignKeyField?.DisplayName}";
}
```

### 3. 代码层操作
```csharp
// 使用Key进行数据库操作
string fieldName = mapping.SystemField?.Key;
string tableName = mapping.TargetTable?.Key;

// 查询示例
var records = db.Queryable<tb_ProdCategories>()
    .Where(p => p.PID == someValue)
    .Select(p => new { p.PID, p.CategoryName })
    .ToList();
```

### 4. XML序列化

#### 保存配置
```csharp
var mappings = new ColumnMappingCollection
{
    new ColumnMapping
    {
        Id = 1,
        ExcelColumn = "A",
        SystemField = new FieldReference("CategoryID", "类别ID"),
        TargetTable = new TableReference("tb_ProdCategories", "产品类目表"),
        DataSourceType = DataSourceType.Excel
    }
};

// 序列化为XML
var serializer = new XmlSerializer(typeof(ColumnMappingCollection));
using (var writer = new StreamWriter("ColumnMapping.xml"))
{
    serializer.Serialize(writer, mappings);
}
```

#### XML输出格式
```xml
<?xml version="1.0" encoding="utf-8"?>
<ArrayOfColumnMapping xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <ColumnMapping>
    <Id>1</Id>
    <ExcelColumn>A</ExcelColumn>
    <SystemField Key="CategoryID" DisplayName="类别ID" />
    <TargetTable Key="tb_ProdCategories" DisplayName="产品类目表" />
    <DataSourceType>Excel</DataSourceType>
  </ColumnMapping>
</ArrayOfColumnMapping>
```

#### 读取配置
```csharp
var serializer = new XmlSerializer(typeof(ColumnMappingCollection));
using (var reader = new StreamReader("ColumnMapping.xml"))
{
    var mappings = (ColumnMappingCollection)serializer.Deserialize(reader);

    foreach (var mapping in mappings)
    {
        Console.WriteLine($"Excel列: {mapping.ExcelColumn}");
        Console.WriteLine($"系统字段: {mapping.SystemField?.DisplayName} ({mapping.SystemField?.Key})");
        Console.WriteLine($"目标表: {mapping.TargetTable?.DisplayName} ({mapping.TargetTable?.Key})");
    }
}
```

## 四组属性使用场景

### 1. 目标表（TargetTable）
```csharp
// 场景：标识数据导入的目标表
mapping.TargetTable = new TableReference("tb_ProdCategories", "产品类目表");

// UI显示：产品类目表
// 代码操作：tb_ProdCategories
Type entityType = Type.GetType($"RUINORERP.Model.{mapping.TargetTable?.Key}");
```

### 2. 系统字段（SystemField）
```csharp
// 场景：Excel列映射到目标表的哪个字段
mapping.SystemField = new FieldReference("CategoryName", "类别名称");

// UI显示：类别名称
// 代码操作：CategoryName（用于属性赋值、查询等）
```

### 3. 来源字段（ExcelColumn / DataSourceType）
```csharp
// 场景A：Excel列作为数据源
mapping.ExcelColumn = "A";
mapping.DataSourceType = DataSourceType.Excel;

// 场景B：外键关联作为数据源
mapping.DataSourceType = DataSourceType.ForeignKey;
mapping.ForeignKeyTable = new TableReference("tb_Prod", "产品表");
mapping.ForeignKeyField = new FieldReference("CategoryID", "类别ID");

// 场景C：自身字段引用作为数据源
mapping.DataSourceType = DataSourceType.SelfReference;
mapping.SelfReferenceField = new FieldReference("ID", "主键ID");
```

### 4. 外键字段（ForeignKeyTable / ForeignKeyField）
```csharp
// 场景：配置外键关联关系
mapping.ForeignKeyTable = new TableReference("tb_Prod", "产品表");
mapping.ForeignKeyField = new FieldReference("CategoryID", "类别ID");

// UI显示：关联表：产品表，关联字段：类别ID
// 代码操作：使用ForeignKeyTable.Key和ForeignKeyField.Key进行关联查询
```

## 特性优势

### 1. 数据整合
- ✅ 中英文属性统一存储为单一对象
- ✅ 避免属性分离导致的数据不一致
- ✅ 简化属性管理

### 2. XML序列化
- ✅ 完美支持XML序列化/反序列化
- ✅ 自定义XmlAttribute控制序列化格式
- ✅ 兼容现有配置文件系统

### 3. 类型安全
- ✅ 强类型（FieldReference vs TableReference）
- ✅ 编译时类型检查
- ✅ IDE智能提示支持

### 4. 向后兼容
- ✅ 保留旧属性作为计算属性
- ✅ 现有代码无需大量修改
- ✅ 平滑迁移路径

### 5. UI友好
- ✅ DisplayName用于UI显示（中文）
- ✅ Key用于代码操作（英文）
- ✅ ToString()返回友好的显示格式

## 迁移建议

### 逐步迁移方案

1. **第一阶段**：ColumnMapping类内部重构（已完成）
   - 引入FieldReference和TableReference
   - 保留向后兼容属性
   - 更新InitializeFromMetadata方法

2. **第二阶段**：更新引用属性的地方（进行中）
   - FrmColumnPropertyConfig.cs
   - frmColumnMappingConfig.cs
   - UCBasicDataImport.cs
   - DynamicImporter.cs

3. **第三阶段**：移除向后兼容属性（可选）
   - 当所有代码都迁移到新结构后
   - 移除旧的string属性
   - 简化代码

### 迁移检查清单

- [x] ColumnMapping.cs重构完成
- [ ] FrmColumnPropertyConfig.cs更新
- [ ] frmColumnMappingConfig.cs更新
- [ ] UCBasicDataImport.cs更新
- [ ] DynamicImporter.cs更新
- [ ] 测试XML序列化
- [ ] 测试功能完整性
- [ ] 移除向后兼容属性（可选）

## 常见问题

### Q1: 如何判断FieldReference是否为空？
```csharp
if (mapping.SystemField?.IsEmpty() == true)
{
    // 字段引用为空
}
```

### Q2: 如何同时获取Key和DisplayName？
```csharp
string key = mapping.SystemField?.Key;
string displayName = mapping.SystemField?.DisplayName;
string fullText = mapping.SystemField?.ToString(); // 返回"中文 (英文)"格式
```

### Q3: 旧代码如何兼容？
```csharp
// 方式一：使用向后兼容属性
string fieldName = mapping.SystemField;  // 实际调用mapping.SystemField?.Key

// 方式二：逐步迁移
string fieldName = mapping.SystemField?.Key ?? mapping.SystemField;
```

### Q4: XML序列化后如何读取？
```csharp
// XML中存储为： <SystemField Key="PID" DisplayName="父类ID" />
// 反序列化后自动恢复为FieldReference对象
```

## 总结

本次重构通过引入`FieldReference`和`TableReference`统一的数据结构，实现了：
1. ✅ 中英文属性的统一管理
2. ✅ 完美的XML序列化支持
3. ✅ 类型安全和编译时检查
4. ✅ 向后兼容和平滑迁移
5. ✅ UI友好和代码清晰

这种结构设计符合现代C#最佳实践，提高了代码的可维护性和可扩展性。
