# 单据图片处理方案设计文档

## 1. 需求分析

### 1.1 功能需求
- **新建单据场景**：用户在创建新单据时，通过粘贴、拖入或双击上传图片
- **未保存更新场景**：在单据未保存到数据库的情况下，用户更换或添加图片
- **已保存更新场景**：在单据已保存到数据库后，用户更新或删除图片

### 1.2 技术依赖
- MagicPictureBox自定义控件
- ImageInfo类用于图片信息管理
- 业务单据与图片的关联管理

## 2. MagicPictureBox控件分析

### 2.1 核心功能
- 多图片支持与管理
- 图片变更跟踪（只上传变更图片）
- 图片哈希值计算用于唯一性验证
- 丰富的图片操作（裁剪、缩放、旋转等）
- 完整的图片元数据管理

### 2.2 关键属性与方法
- **核心属性**：
  - `MultiImageSupport`：是否启用多图片支持
  - `ImagePaths`：图片路径字符串，多图片模式下使用分号分隔

- **关键方法**：
  - 图片加载：`LoadImagesFromBytes`, `LoadImagesFromFileStorageInfos`
  - 图片操作：`AddImage`, `DeleteCurrentImage`, `ClearImage`, `RotateImage`, `StartCrop`
  - 状态管理：`GetUpdatedImageBytesWithInfo`, `ResetAllImageUpdateStatuses`
  - 哈希计算：`CalculateImageHash`, `AreImagesEqual`

## 3. 图片信息管理机制

### 3.1 ImageInfo类结构
- `OriginalFileName`：存储原始文件名
- `FileSize`：文件大小（字节）
- `HashValue`：SHA256哈希值，用于图片唯一性验证
- `IsUpdated`：标记图片是否已更新，关键状态字段
- `FileId`：文件ID，用于版本控制
- 其他元数据：`CreateTime`, `FileType`, `Width`, `Height`等

### 3.2 更新状态管理
- 从服务器加载的图片初始状态：`IsUpdated = false`
- 用户手动添加/修改的图片状态：`IsUpdated = true`
- 上传成功后应重置状态：`ResetAllImageUpdateStatuses()`

## 4. 设计方案

### 4.1 总体架构

```
单据界面 <--> MagicPictureBox <--> 图片数据管理 <--> 服务器交互
     |               |                   |
     |               v                   v
  业务逻辑 <---> ImageInfo <---> 图片更新管理器(ImageUpdateManager)
```

### 4.2 场景实现方案

#### 4.2.1 新建单据场景

1. **初始化控件**：
   ```csharp
   magicPictureBox.MultiImageSupport = true; // 启用多图片支持
   magicPictureBox.SizeMode = PictureBoxSizeMode.Zoom;
   ```

2. **用户添加图片**：
   - 通过粘贴、拖入或双击上传图片
   - 控件自动处理图片添加并标记`IsUpdated = true`

3. **保存单据**：
   ```csharp
   private async Task SaveNewDocumentAsync()
   {
       try
       {
           // 1. 保存单据基本信息到数据库，获取单据ID
           long documentId = await SaveDocumentBasicInfoAsync();
           
           // 2. 获取所有图片（新建场景下所有图片都需要上传）
           var imagesToUpload = magicPictureBox.GetAllImageBytesWithInfo();
           
           // 3. 上传图片到服务器
           if (imagesToUpload.Count > 0)
           {
               await UploadImagesToServerAsync(imagesToUpload, documentId);
               
               // 4. 上传成功后重置更新状态
               magicPictureBox.ResetAllImageUpdateStatuses();
           }
           
           MessageBox.Show("单据保存成功！", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
       }
       catch (Exception ex)
       {
           MessageBox.Show($"保存失败: {ex.Message}", "错误", MessageBoxButtons.OK, MessageBoxIcon.Error);
       }
   }
   ```

#### 4.2.2 未保存更新场景

1. **更换图片**：
   - 用户可以通过相同的方式（粘贴、拖入、双击）添加新图片
   - 单图片模式下，新图片会替换现有图片
   - 多图片模式下，新图片会添加到图片列表中

2. **添加多张图片**：
   - 确保`MultiImageSupport = true`
   - 每次添加都会创建新的ImageInfo对象，标记`IsUpdated = true`

3. **保存前处理**：
   ```csharp
   private void ValidateImagesBeforeSave()
   {
       // 检查是否有重复图片（可选）
       var duplicateImages = FindDuplicateImages();
       if (duplicateImages.Count > 0)
       {
           DialogResult result = MessageBox.Show(
               "检测到重复图片，是否继续保存？", 
               "提示", 
               MessageBoxButtons.YesNo, 
               MessageBoxIcon.Warning);
           
           if (result == DialogResult.No)
           {
               return; // 取消保存
           }
       }
   }
   ```

#### 4.2.3 已保存更新场景

1. **加载已有图片**：
   ```csharp
   private async Task LoadDocumentWithImagesAsync(long documentId)
   {
       try
       {
           // 1. 加载单据基本信息
           var document = await LoadDocumentInfoAsync(documentId);
           
           // 2. 加载关联的图片信息
           var imageInfos = await LoadDocumentImageInfosAsync(documentId);
           
           // 3. 从服务器加载图片数据
           List<byte[]> imageBytesList = new List<byte[]>();
           List<string> fileNamesList = new List<string>();
           
           foreach (var info in imageInfos)
           {
               byte[] imageBytes = await DownloadImageFromServerAsync(info.FileId);
               imageBytesList.Add(imageBytes);
               fileNamesList.Add(info.OriginalFileName);
           }
           
           // 4. 使用isFromServer=true加载图片，确保IsUpdated=false
           magicPictureBox.LoadImagesFromBytes(imageBytesList, fileNamesList, isFromServer: true);
       }
       catch (Exception ex)
       {
           MessageBox.Show($"加载失败: {ex.Message}", "错误", MessageBoxButtons.OK, MessageBoxIcon.Error);
       }
   }
   ```

2. **更新/删除图片**：
   - **更新图片**：用户修改图片后，控件自动设置`IsUpdated = true`
   - **删除图片**：使用`DeleteCurrentImage()`方法删除当前显示的图片

3. **保存更新**：
   ```csharp
   private async Task UpdateDocumentWithImagesAsync(long documentId)
   {
       try
       {
           // 1. 更新单据基本信息
           await UpdateDocumentBasicInfoAsync(documentId);
           
           // 2. 获取需要更新的图片（只包含变更的图片）
           var imagesToUpdate = magicPictureBox.GetUpdatedImageBytesWithInfo();
           
           // 3. 获取被删除的图片信息（需要维护一个删除列表）
           var imagesToDelete = GetDeletedImageInfos();
           
           // 4. 处理图片变更
           if (imagesToUpdate.Count > 0 || imagesToDelete.Count > 0)
           {
               await ProcessImageChangesAsync(documentId, imagesToUpdate, imagesToDelete);
               
               // 5. 更新成功后重置状态
               magicPictureBox.ResetAllImageUpdateStatuses();
               ClearDeletedImagesList();
           }
           
           MessageBox.Show("单据更新成功！", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
       }
       catch (Exception ex)
       {
           MessageBox.Show($"更新失败: {ex.Message}", "错误", MessageBoxButtons.OK, MessageBoxIcon.Error);
       }
   }
   ```

### 4.3 删除图片管理

由于MagicPictureBox没有直接提供跟踪已删除图片的机制，我们需要在业务层实现：

```csharp
// 保存已删除的图片信息
private List<ImageInfo> deletedImageInfos = new List<ImageInfo>();

// 处理删除操作
private void HandleImageDeletion()
{
    // 在删除前保存被删除图片的信息
    ImageInfo currentInfo = magicPictureBox.GetCurrentImageInfo();
    if (currentInfo != null && currentInfo.FileId > 0) // 只跟踪已保存到服务器的图片
    {
        deletedImageInfos.Add(currentInfo);
    }
    
    // 执行删除操作
    magicPictureBox.DeleteCurrentImage();
}

// 获取被删除的图片信息
private List<ImageInfo> GetDeletedImageInfos()
{
    return deletedImageInfos;
}

// 清除删除列表
private void ClearDeletedImagesList()
{
    deletedImageInfos.Clear();
}
```

## 5. 图片变更处理策略

### 5.1 新增图片
- 生成新的FileId
- 计算图片哈希值
- 上传完整图片数据

### 5.2 更新图片
- 使用现有FileId
- 重新计算哈希值
- 上传更新后的图片数据

### 5.3 删除图片
- 根据FileId从服务器删除
- 从数据库中移除关联

## 6. 图片唯一性验证

使用MagicPictureBox内置的哈希计算功能，避免重复上传相同内容的图片：

```csharp
private List<ImageInfo> FindDuplicateImages()
{
    List<ImageInfo> duplicateImages = new List<ImageInfo>();
    Dictionary<string, ImageInfo> hashMap = new Dictionary<string, ImageInfo>();
    
    // 获取所有图片信息
    var allImagesWithInfo = magicPictureBox.GetAllImageBytesWithInfo();
    
    foreach (var (bytes, info) in allImagesWithInfo)
    {
        // 使用控件的哈希计算方法
        string hash = magicPictureBox.CalculateImageHash(bytes);
        
        if (hashMap.ContainsKey(hash))
        {
            // 找到重复图片
            duplicateImages.Add(info);
        }
        else
        {
            hashMap.Add(hash, info);
        }
    }
    
    return duplicateImages;
}
```

## 7. 性能优化建议

1. **懒加载**：对于多张图片，考虑实现懒加载机制
2. **图片压缩**：上传前对大图片进行压缩
3. **批量处理**：优化批量图片的上传和更新逻辑
4. **内存管理**：及时释放不再需要的图片资源
5. **异步操作**：所有IO操作（加载、保存、上传）使用异步方式

## 8. 实现注意事项

1. **正确设置更新状态**：
   - 从服务器加载时，设置`isFromServer = true`
   - 上传成功后调用`ResetAllImageUpdateStatuses()`

2. **状态持久化**：
   - 确保图片状态在应用重启或网络中断后能够正确恢复

3. **错误处理**：
   - 添加完整的异常处理
   - 实现上传失败的重试机制

4. **事务处理**：
   - 确保单据保存和图片上传在同一个事务中
   - 实现回滚机制，保证数据一致性

## 9. 代码优化建议

1. **封装业务逻辑**：创建专门的图片业务处理器类
2. **统一错误处理**：使用统一的异常处理策略
3. **状态管理**：优化图片更新状态的跟踪机制
4. **可扩展性**：设计灵活的接口，支持未来功能扩展

## 10. 未来功能规划

1. **图片预览**：增强预览功能，支持缩略图查看
2. **批量操作**：批量上传、删除、旋转等操作
3. **图片标记**：支持在图片上添加标记、注释
4. **OCR集成**：集成文字识别功能
5. **云端同步**：支持与云存储服务同步