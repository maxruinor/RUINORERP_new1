# 图片删除逻辑设计优化方案

## 一、现状分析

### 1. 数据表结构
- **tb_FS_FileStorageInfo** (文件表)
  - `isdeleted` - 逻辑删除标记
  - `FileStatus` - 文件状态（Active/Expired/Orphaned/Deleted）

- **tb_FS_BusinessRelation** (业务关联表)
  - `isdeleted` - 逻辑删除标记

### 2. 当前删除逻辑
```
删除图片时：
  - tb_FS_BusinessRelation.isdeleted = true ✓
  - tb_FS_FileStorageInfo.isdeleted = false (未修改)
  - tb_FS_FileStorageInfo.FileStatus = Deleted (仅当无其他引用时)

问题：
  - 两个表的 isdeleted 语义不一致
  - 查询"已删除图片"时结果不完整
  - 数据一致性难以保证
```

## 二、优化方案

### 方案A：统一以关联表 isdeleted 为准（推荐）

#### 设计原则
- **tb_FS_BusinessRelation.isdeleted** = 关联关系是否有效（用户可见）
- **tb_FS_FileStorageInfo.isdeleted** = 文件记录是否存在于数据库中（内部管理）
- **tb_FS_FileStorageInfo.FileStatus** = 文件的实际状态（Active/Deleted 等）

如果没有任何有效关联tb_FS_BusinessRelation，则tb_FS_FileStorageInfo文件被视为可删除。

#### 删除逻辑
```
用户删除图片时：
  1. tb_FS_BusinessRelation.isdeleted = true
  2. 检查文件是否还有其他有效关联
  3. 如果无其他关联：
     - tb_FS_FileStorageInfo.FileStatus = Deleted
     - tb_FS_FileStorageInfo.isdeleted = true (可选，仅用于物理删除前标记)
```

#### 查询逻辑
```
查询"已删除图片"：
  SELECT * FROM tb_FS_BusinessRelation r
  WHERE r.isdeleted = true

关联查询文件信息：
  JOIN tb_FS_FileStorageInfo f ON r.FileId = f.FileId
  WHERE f.isdeleted = false (仅查询未被物理删除的文件)
```

#### 优点
- ✅ 用户视角清晰：关联被删除 = 图片被删除
- ✅ 支持文件共享：同一文件可被多个业务引用
- ✅ 查询逻辑简单，结果准确

#### 缺点
- ⚠️ 需要修改多处查询逻辑



## 三、最终推荐方案（方案A变体）

### 设计原则
1. **用户删除图片** = 删除业务关联（`tb_FS_BusinessRelation.isdeleted = true`）
2. **文件共享机制** = 同一物理文件可被多个业务引用
3. **文件清理** = 无任何有效关联时才标记文件为已删除

### 具体实现

#### 3.1 删除流程
```
用户删除图片：
  ↓
检查关联数量
  ↓
【场景1：仅此一个关联】
  - tb_FS_BusinessRelation.isdeleted = true
  - tb_FS_FileStorageInfo.FileStatus = Deleted
  - tb_FS_FileStorageInfo.Modified_at = now
  ↓
【场景2：多个关联中一个】
  - tb_FS_BusinessRelation.isdeleted = true
  - tb_FS_FileStorageInfo 不修改（文件仍有效）
```

#### 3.2 查询已删除文件
```csharp
// 查询已删除的业务关联（包括文件信息）
public async Task<List<DeletedFileInfo>> GetDeletedFilesAsync()
{
    var db = _unitOfWorkManage.GetDbClient();

    var result = await db.Queryable<tb_FS_BusinessRelation>()
        .InnerJoin<tb_FS_FileStorageInfo>((r, f) => r.FileId == f.FileId)
        .Where((r, f) => r.isdeleted == true)  // 关键：以关联表为准
        .Where((r, f) => f.isdeleted == false)   // 排除已物理删除的文件
        .OrderByDescending((r, f) => r.Modified_at)
        .Select((r, f) => new DeletedFileInfo
        {
            RelationId = r.RelationId,
            FileId = r.FileId,
            OriginalFileName = f.OriginalFileName,
            FileSize = f.FileSize,
            BusinessNo = r.BusinessNo,
            // ... 其他字段
        })
        .ToListAsync();

    return result;
}
```

#### 3.3 恢复已删除文件
```csharp
// 恢复业务关联
public async Task<bool> RestoreDeletedFileAsync(long relationId)
{
    var db = _unitOfWorkManage.GetDbClient();

    var relation = await db.Queryable<tb_FS_BusinessRelation>()
        .FirstAsync(r => r.RelationId == relationId && r.isdeleted == true);

    if (relation == null) return false;

    // 恢复关联
    relation.isdeleted = false;
    relation.Modified_at = DateTime.Now;

    var updateResult = await db.Updateable(relation).ExecuteCommandAsync();

    // 如果文件状态为 Deleted，恢复文件状态
    var fileInfo = await db.Queryable<tb_FS_FileStorageInfo>()
        .FirstAsync(f => f.FileId == relation.FileId);

    if (fileInfo != null && fileInfo.FileStatus == (int)FileStatus.Deleted)
    {
        fileInfo.FileStatus = (int)FileStatus.Active;
        fileInfo.Modified_at = DateTime.Now;
        await db.Updateable(fileInfo).ExecuteCommandAsync();
    }

    return updateResult > 0;
}
```

#### 3.4 物理删除已删除文件
```csharp
// 物理删除（永久删除）
public async Task<int> PhysicalDeleteDeletedFilesAsync(List<long> relationIds)
{
    var db = _unitOfWorkManage.GetDbClient();

    // 查询要删除的关联
    var relations = await db.Queryable<tb_FS_BusinessRelation>()
        .Where(r => relationIds.Contains(r.RelationId))
        .Where(r => r.isdeleted == true)
        .ToListAsync();

    var fileIds = relations.Select(r => r.FileId).Distinct().ToList();

    // 检查这些文件是否还有其他有效关联
    var stillReferencedFileIds = await db.Queryable<tb_FS_BusinessRelation>()
        .Where(r => fileIds.Contains(r.FileId))
        .Where(r => r.isdeleted == false)  // 只查询未删除的关联
        .Select(r => r.FileId)
        .Distinct()
        .ToListAsync();

    // 找出可以物理删除的文件
    var filesToDelete = fileIds.Except(stillReferencedFileIds).ToList();

    // 执行物理删除
    foreach (var fileId in filesToDelete)
    {
        var fileInfo = await db.Queryable<tb_FS_FileStorageInfo>()
            .FirstAsync(f => f.FileId == fileId);

        if (fileInfo != null)
        {
            // 删除物理文件
            var filePath = FileStorageHelper.ResolveToAbsolutePath(fileInfo.StoragePath);
            if (File.Exists(filePath))
            {
                File.Delete(filePath);
            }

            // 标记文件记录为已删除
            fileInfo.isdeleted = true;
            fileInfo.FileStatus = (int)FileStatus.Deleted;
            await db.Updateable(fileInfo).ExecuteCommandAsync();
        }
    }

    // 删除关联记录
    await db.Deleteable<tb_FS_BusinessRelation>()
        .Where(r => relationIds.Contains(r.RelationId))
        .ExecuteCommandAsync();

    return filesToDelete.Count;
}
```

---

## 四、需要修改的文件清单

### 4.1 文件修改
1. **FileCommandHandler.cs**
   - 统一删除逻辑，确保只标记关联表 isdeleted
   - 仅在无其他引用时才修改文件表 FileStatus

2. **FileCleanupService.cs**
   - 修改 GetDeletedFilesAsync() 以关联表 isdeleted 为准查询
   - 修改 PhysicalDeleteDeletedFilesAsync() 和 RestoreDeletedFilesAsync()

3. **FileManagementControl.cs**
   - 更新查询逻辑，确保能显示所有已删除的关联

### 4.2 数据清理
```sql
-- 清理不一致的数据
-- 统一：关联表 isdeleted = true 的记录，视为已删除
```

---

## 五、总结

### 推荐方案：**方案A变体**
- ✅ 以 **tb_FS_BusinessRelation.isdeleted** 为用户删除的准据
- ✅ 支持文件共享机制
- ✅ 查询逻辑清晰，结果准确
- ✅ 易于理解和维护

### 关键点
1. **用户删除** = 删除业务关联
2. **文件删除** = 无任何有效关联时才标记为删除
3. **查询已删除** = 查询关联表 isdeleted = true 的记录
4. **恢复删除** = 将关联表 isdeleted 改回 false

---

## 六、实施步骤

1. 修改 FileCommandHandler.cs 删除逻辑
2. 修改 FileCleanupService.cs 查询逻辑
3. 测试删除、查询、恢复功能
4. 清理历史不一致数据
5. 更新文档和使用说明
