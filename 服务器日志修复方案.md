# 服务器端日志无法保存到数据库问题分析与修复方案

## 一、问题概述

客户端和服务器端都引用了相同的公共日志类（`RUINORERP.Common.Log4Net`），客户端可以正常保存日志到数据库，但服务器端无法保存日志到数据库。

## 二、根本原因分析

### 2.1 关键发现

通过对比分析客户端（`RUINORERP.UI`）和服务器端（`RUINORERP.Server`）的日志配置，发现了以下关键差异：

#### 1. **配置文件名称不一致**

**服务器端（Startup.cs 254行）：**
```csharp
logBuilder.AddProvider(new Log4NetProviderByCustomeDb("Log4net_db.config", newconn, Program.AppContextData));
```

**客户端（Startup.cs 258行）：**
```csharp
logBuilder.AddProvider(new RUINORERP.Common.Log4Net.Log4NetProviderByCustomeDb("log4net.config", newconn, Program.AppContextData));
```

#### 2. **Log4NetLoggerByDb 实现中的硬编码问题**

在 `RUINORERP.Common/Log4Net/Log4NetLoggerByDb.cs` 的 `CreateLoggerRepository` 方法中（第363行）：

```csharp
// 使用frmMainNew中设置的动态BufferSize值
adoNetAppender.BufferSize = 1;// RUINORERP.Server.frmMainNew.GetLogBufferSize(); // 批量写入日志
```

这行代码存在两个问题：
1. `BufferSize` 被硬编码为 1，导致日志无法批量写入
2. 注释掉的代码引用了 `RUINORERP.Server.frmMainNew.GetLogBufferSize()`，但在初始化阶段（Startup）此时尚未可用

#### 3. **日志仓库重复创建问题**

在 `Log4NetLoggerByDb` 构造函数中（第42-57行），每次创建 logger 实例时都会调用 `CreateLoggerRepository`，但该方法使用双重检查锁定模式来创建单例仓库，这可能导致在多线程环境下出现竞态条件。

#### 4. **ApplicationContext 初始化时机问题**

**服务器端初始化（Program.cs 498-510行）：**
```csharp
public static void InitAppcontextValue(ApplicationContext AppContextData)
{
    AppContextData.Status = "init";
    if (AppContextData.log == null)
    {
        AppContextData.log = new Logs();
    }
    AppContextData.log.IP = "server";  // 硬编码为 "server"
    AppContextData.log.MachineName = System.Environment.MachineName + "-" + System.Environment.UserName;
    AppContextData.SysConfig = new tb_SystemConfig();
}
```

**客户端初始化（Program.cs 698-707行）：**
```csharp
public static void InitAppcontextValue(ApplicationContext AppContextData)
{
    AppContextData.Status = "init";
    if (AppContextData.log == null)
    {
        AppContextData.log = new Logs();
    }
    AppContextData.log.IP = HLH.Lib.Net.IpAddressHelper.GetLocIP();  // 获取本地IP
    AppContextData.SysConfig = new tb_SystemConfig();
}
```

客户端使用真实的IP地址，而服务器端硬编码为 "server"，这可能在某些场景下导致问题。

#### 5. **数据库表结构与配置不匹配**

**服务器配置文件（Log4net_db.config 第12行）：**
```xml
<commandText value="INSERT INTO LogDetails ([LogDate],[LogThread],[LogLevel],[LogLogger],[LogActionClick],[LogMessage],[UserName],[UserIP]) VALUES (@log_date, @thread, @log_level, @logger, @ActionsClick, @message,@UserName,@UserIP)" />
```

这里插入的表是 `LogDetails`，但实际的模型类定义的表名是 `Logs`（`Logs.cs` 第25行）。

**Log4NetLoggerByDb 代码中（第393行）：**
```csharp
adoNetAppender.CommandText = "INSERT INTO Logs ([Date],[Level],[Logger],[Message],[Exception],[Operator],[ModName],[Path],[ActionName],[IP],[MAC],[MachineName],[User_ID]) VALUES (@log_date, @log_level, @logger, @Message, @Exception, @Operator, @ModName, @Path, @ActionName, @IP, @MAC, @MachineName, @User_ID)";
```

代码中使用的是 `Logs` 表，但配置文件中使用的是 `LogDetails` 表，这是一个明显的表名不一致问题。

#### 6. **日志提供者实现中的配置文件处理逻辑问题**

在 `Log4NetProviderByCustomeDb.Parselog4NetConfigFile` 方法中（第54-117行），配置文件的处理逻辑如下：

```csharp
private static XmlElement Parselog4NetConfigFile(string filename, string connectionString)
{
    XmlDocument log4netConfig = new XmlDocument();

    // 检查文件是否存在，如果不存在则使用默认配置
    if (File.Exists(filename))
    {
        log4netConfig.Load(File.OpenRead(filename));
    }
    else
    {
        // 如果指定的配置文件不存在，尝试加载默认的log4net.config
        string defaultConfigFile = "log4net.config";
        if (File.Exists(defaultConfigFile))
        {
            log4netConfig.Load(File.OpenRead(defaultConfigFile));
            System.Diagnostics.Debug.WriteLine($"警告：未找到配置文件 {filename}，使用默认配置文件 {defaultConfigFile}");
        }
        else
        {
            // 如果都不存在，创建一个基本的配置
            System.Diagnostics.Debug.WriteLine($"警告：未找到配置文件 {filename} 和 {defaultConfigFile}，使用基本配置");
            XmlElement log4netElement = log4netConfig.CreateElement("log4net");
            log4netConfig.AppendChild(log4netElement);
        }
    }

    // ... 替换连接字符串的逻辑 ...
}
```

这个逻辑存在问题：当传入 `"Log4net_db.config"` 时，如果该文件不存在，会尝试加载 `"log4net.config"`，但这两个文件的表结构和字段定义可能不同。

### 2.2 问题总结

综合以上分析，服务器端日志无法保存到数据库的主要原因是：

1. **配置文件表名不匹配**：`Log4net_db.config` 中使用 `LogDetails` 表，但代码中期望使用 `Logs` 表
2. **BufferSize 设置不当**：硬编码为 1，导致日志无法批量写入，可能影响性能
3. **配置文件路径不一致**：服务器端使用 `Log4net_db.config`，客户端使用 `log4net.config`
4. **ApplicationContext.log 字段不完整**：服务器端只设置了 IP 和 MachineName，缺少其他必要的字段（如 User_ID, ModName, ActionName 等）

## 三、修复方案

### 3.1 修复步骤

#### 步骤1：统一日志表名和配置文件

修改 `RUINORERP.Server/Log4net_db.config` 文件，将表名从 `LogDetails` 改为 `Logs`，并调整字段顺序和定义以匹配模型类：

```xml
<?xml version="1.0" encoding="utf-8" ?>

<log4net debug="false">
    <!-- name属性指定其名称,type则是log4net.Appender命名空间的一个类的名称,意思是,指定使用哪种介质-->
    <appender name="ADONetAppender" type="log4net.Appender.ADONetAppender">
        <!--日志缓存写入条数 设置为0时只要有一条就立刻写到数据库，建议使用10进行批量写入-->
        <bufferSize value="10" />
        <!--日志数据库连接串-->
        <connectionType value="System.Data.SqlClient.SqlConnection, System.Data, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
        <connectionString value="${ConnectionString}" />
        <!--日志数据库脚本-->
        <commandText value="INSERT INTO Logs ([Date],[Level],[Logger],[Message],[Exception],[Operator],[ModName],[Path],[ActionName],[IP],[MAC],[MachineName],[User_ID]) VALUES (@log_date, @log_level, @logger, @Message, @Exception, @Operator, @ModName, @Path, @ActionName, @IP, @MAC, @MachineName, @User_ID)" />
        <!--日志时间Date -->
        <parameter>
            <parameterName value="@log_date" />
            <dbType value="DateTime" />
            <layout type="log4net.Layout.RawTimeStampLayout" />
        </parameter>
        <!--日志类型Level -->
        <parameter>
            <parameterName value="@log_level" />
            <dbType value="String" />
            <size value="50" />
            <layout type="log4net.Layout.PatternLayout">
                <conversionPattern value="%level" />
            </layout>
        </parameter>
        <!--日志名称-->
        <parameter>
            <parameterName value="@logger" />
            <dbType value="String" />
            <size value="500" />
            <layout type="log4net.Layout.PatternLayout">
                <conversionPattern value="%logger" />
            </layout>
        </parameter>
        <!--消息Message -->
        <parameter>
            <parameterName value="@Message" />
            <dbType value="String" />
            <size value="2147483647" />
            <layout type="RUINORERP.Common.Log4Net.EnhancedCustomLayout">
                <conversionPattern value="%property{Message}" />
            </layout>
        </parameter>
        <!--异常Exception -->
        <parameter>
            <parameterName value="@Exception" />
            <dbType value="String" />
            <size value="2147483647" />
            <layout type="RUINORERP.Common.Log4Net.EnhancedCustomLayout">
                <conversionPattern value="%property{Exception}" />
            </layout>
        </parameter>
        <!--操作者Operator -->
        <parameter>
            <parameterName value="@Operator" />
            <dbType value="String" />
            <size value="200" />
            <layout type="RUINORERP.Common.Log4Net.EnhancedCustomLayout" >
                <conversionPattern value="%property{Operator}"/>
            </layout>
        </parameter>
        <!--模块名ModName -->
        <parameter>
            <parameterName value="@ModName" />
            <dbType value="String" />
            <size value="200" />
            <layout type="RUINORERP.Common.Log4Net.EnhancedCustomLayout" >
                <conversionPattern value="%property{ModName}"/>
            </layout>
        </parameter>
        <!--路径Path -->
        <parameter>
            <parameterName value="@Path" />
            <dbType value="String" />
            <size value="500" />
            <layout type="RUINORERP.Common.Log4Net.EnhancedCustomLayout" >
                <conversionPattern value="%property{Path}"/>
            </layout>
        </parameter>
        <!--动作ActionName -->
        <parameter>
            <parameterName value="@ActionName" />
            <dbType value="String" />
            <size value="100" />
            <layout type="RUINORERP.Common.Log4Net.EnhancedCustomLayout" >
                <conversionPattern value="%property{ActionName}"/>
            </layout>
        </parameter>
        <!--网络地址IP -->
        <parameter>
            <parameterName value="@IP" />
            <dbType value="String" />
            <size value="100" />
            <layout type="RUINORERP.Common.Log4Net.EnhancedCustomLayout" >
                <conversionPattern value="%property{IP}"/>
            </layout>
        </parameter>
        <!--物理地址MAC -->
        <parameter>
            <parameterName value="@MAC" />
            <dbType value="String" />
            <size value="100" />
            <layout type="RUINORERP.Common.Log4Net.EnhancedCustomLayout" >
                <conversionPattern value="%property{MAC}"/>
            </layout>
        </parameter>
        <!--电脑名MachineName -->
        <parameter>
            <parameterName value="@MachineName" />
            <dbType value="String" />
            <size value="100" />
            <layout type="RUINORERP.Common.Log4Net.EnhancedCustomLayout" >
                <conversionPattern value="%property{MachineName}"/>
            </layout>
        </parameter>
        <!--用户User_ID -->
        <parameter>
            <parameterName value="@User_ID" />
            <dbType value="Int64" />
            <size value="8" />
            <layout type="RUINORERP.Common.Log4Net.EnhancedCustomLayout" >
                <conversionPattern value="%property{User_ID}"/>
            </layout>
        </parameter>
    </appender>
    <!-- setup root category, add appenders and set default level -->
    <root>
        <level value="DEBUG"/>
        <appender-ref ref="ADONetAppender" />
    </root>
</log4net>
```

#### 步骤2：修复 Log4NetLoggerByDb.cs 中的 BufferSize 问题

修改 `RUINORERP.Common/Log4Net/Log4NetLoggerByDb.cs` 第363行，将硬编码的 BufferSize 改为使用配置文件中的值或动态获取：

```csharp
// 修改前：
adoNetAppender.BufferSize = 1;// RUINORERP.Server.frmMainNew.GetLogBufferSize(); // 批量写入日志

// 修改后：
// 从配置中读取BufferSize，默认使用10进行批量写入以提高性能
int bufferSize = 10;
try
{
    // 如果xmlElement不为空，尝试从配置中读取BufferSize
    var bufferSizeNode = _xmlElement?.SelectSingleNode("//appender/bufferSize[@value]");
    if (bufferSizeNode != null && int.TryParse(bufferSizeNode.Attributes["value"]?.Value, out int configuredSize))
    {
        bufferSize = configuredSize;
        System.Diagnostics.Debug.WriteLine($"从配置文件读取BufferSize: {bufferSize}");
    }
}
catch (Exception ex)
{
    System.Diagnostics.Debug.WriteLine($"读取BufferSize配置失败，使用默认值10: {ex.Message}");
}
adoNetAppender.BufferSize = bufferSize;
adoNetAppender.Lossy = false; // 确保不丢失日志
```

#### 步骤3：修改服务器端 Startup.cs 的 ApplicationContext 初始化

修改 `RUINORERP.Server/Program.cs` 的 `InitAppcontextValue` 方法，确保日志对象初始化完整：

```csharp
public static void InitAppcontextValue(ApplicationContext AppContextData)
{
    AppContextData.Status = "init";
    if (AppContextData.log == null)
    {
        AppContextData.log = new Logs();
    }
    // 使用真实的服务器IP地址而不是硬编码的"server"
    try
    {
        AppContextData.log.IP = HLH.Lib.Net.IpAddressHelper.GetLocIP();
    }
    catch
    {
        // 如果获取IP失败，使用服务器机器名作为备用
        AppContextData.log.IP = "server-" + System.Environment.MachineName;
    }
    AppContextData.log.MachineName = System.Environment.MachineName + "-" + System.Environment.UserName;

    // 初始化其他必要的日志字段，避免空值
    if (string.IsNullOrEmpty(AppContextData.log.Operator))
    {
        AppContextData.log.Operator = "系统服务";
    }
    if (string.IsNullOrEmpty(AppContextData.log.ModName))
    {
        AppContextData.log.ModName = "Server";
    }
    if (string.IsNullOrEmpty(AppContextData.log.ActionName))
    {
        AppContextData.log.ActionName = "初始化";
    }

    AppContextData.SysConfig = new tb_SystemConfig();
}
```

#### 步骤4：验证配置文件路径

确认服务器端项目中存在 `Log4net_db.config` 文件，并且该文件已设置为"始终复制"或"如果较新则复制"，确保在编译时能够正确部署到输出目录。

## 四、测试验证

完成以上修复后，需要进行以下测试：

1. **启动服务器**：观察启动过程中是否有日志相关的错误信息
2. **查看Debug输出**：检查是否有"从配置文件读取BufferSize"或"读取BufferSize配置失败"的输出
3. **数据库验证**：查询 `Logs` 表，确认日志记录是否正常写入
4. **日志完整性**：检查日志记录中的各个字段（Message, Exception, Operator, ModName, Path, ActionName, IP, MAC, MachineName, User_ID）是否都有值
5. **性能测试**：确认 BufferSize 设置为 10 后，批量写入功能正常工作

## 五、注意事项

1. **备份数据**：在修改配置前，请备份现有的 `Log4net_db.config` 文件
2. **数据库兼容性**：确保数据库中存在 `Logs` 表，并且表结构与 `Logs.cs` 模型类定义一致
3. **日志级别**：确认配置文件中的日志级别设置合理，避免产生过多的调试日志
4. **错误监控**：修改后需要持续监控一段时间，确保日志系统稳定运行
5. **客户端兼容性**：此修改只影响服务器端日志，客户端日志系统不受影响

## 六、相关文件清单

需要修改的文件：
- `RUINORERP.Server/Log4net_db.config` - 统一表名和字段定义
- `RUINORERP.Common/Log4Net/Log4NetLoggerByDb.cs` - 修复 BufferSize 硬编码问题
- `RUINORERP.Server/Program.cs` - 完善 ApplicationContext 初始化

需要检查的文件：
- `RUINORERP.Server/Startup.cs` - 确认日志提供者注册正确
- `RUINORERP.Model/Logs.cs` - 确认模型定义正确
