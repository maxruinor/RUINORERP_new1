# 服务器日志调试指南

## 问题现状
服务器端日志已初始化成功，Logger 和 Repository 都正常，但日志仍未写入数据库表 `Logs` 中。

## 已添加的调试信息

### 1. CreateLoggerRepository 方法中的调试输出
在创建日志仓库时，现在会输出以下关键信息：
- ✅ 传入的连接字符串状态
- ✅ 日志仓库名称
- ✅ BufferSize 配置值
- ✅ 最终使用的连接字符串
- ✅ SQL 命令
- ✅ 参数添加情况
- ✅ Appender 配置完成状态
- ✅ 附加到 Repository 的 Appender 列表

### 2. Log 方法中的调试输出
在每次记录日志时，现在会输出以下关键信息：
- ✅ 日志级别
- ✅ 消息内容（前100字符）
- ✅ Logger 名称和类型
- ✅ Logger 的 Appender 数量和类型
- ✅ 各个日志级别的启用状态
- ✅ 实际调用的日志方法

## 调试步骤

### 第一步：查看日志仓库创建信息

1. 在 Visual Studio 的"输出"窗口中，选择"调试"
2. 启动服务器
3. 查找以下标记的输出：

```
========== 开始创建日志仓库 ==========
```

**关键检查点：**
- [ ] 传入的连接字符串是否为空？
- [ ] BufferSize 是否正确读取为 10？
- [ ] 最终的连接字符串是什么？
- [ ] SQL 命令是否正确？
- [ ] 参数数量是否为 13 个（3个标准参数 + 10个自定义参数）？
- [ ] 附加的 Appender 数量是否为 1？
- [ ] Appender 类型是否为 `AdoNetAppender`？

### 第二步：查看日志记录信息

当有日志产生时，查找以下标记的输出：

```
========== 准备记录日志 ==========
```

**关键检查点：**
- [ ] Logger 的 Appender 数量是否为 1？
- [ ] Logger 的 Appender 类型是否为 `AdoNetAppender`？
- [ ] 是否调用了正确的日志方法（如 `_log.Info()`）？
- [ ] 日志级别是否被启用？

### 第三步：检查日志仓库配置

根据你提供的调试信息：

```csharp
_log.Logger.Repository
{log4net.Repository.Hierarchy.Hierarchy}
    Name: "RUINORERP_Shared_LoggerRepository"
    Configured: true
```

这表明日志仓库已经配置成功。

**但需要检查：**
- [ ] Repository 的 Appenders 列表中是否包含 `AdoNetAppender`？
- [ ] AdoNetAppender 的配置是否完整？

### 第四步：验证 AdoNetAppender 配置

在断点处查看 `adoNetAppender` 对象的属性：

**关键属性：**
```csharp
adoNetAppender.ConnectionString  // 连接字符串是否正确？
adoNetAppender.CommandText         // SQL 命令是否正确？
adoNetAppender.Parameters.Count     // 参数数量是否为 13？
adoNetAppender.BufferSize          // BufferSize 是否为 10？
adoNetAppender.Lossy             // Lossy 是否为 false？
```

### 第五步：测试数据库连接

创建一个简单的测试方法来验证数据库连接是否正常：

```csharp
// 在服务器启动时调用此方法
public static bool TestLogDatabaseConnection()
{
    try
    {
        string conn = CryptoHelper.GetDecryptedConnectionString();
        using (SqlConnection connection = new SqlConnection(conn))
        {
            connection.Open();
            Console.WriteLine($"日志数据库连接成功，数据库: {connection.Database}");

            // 测试 Logs 表是否存在
            SqlCommand cmd = new SqlCommand(
                "SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Logs'",
                connection);
            int tableCount = (int)cmd.ExecuteScalar();
            Console.WriteLine($"Logs 表存在: {tableCount > 0}");

            // 测试表结构
            if (tableCount > 0)
            {
                cmd.CommandText = @"
                    SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH
                    FROM INFORMATION_SCHEMA.COLUMNS
                    WHERE TABLE_NAME = 'Logs'
                    ORDER BY ORDINAL_POSITION";
                using (SqlDataReader reader = cmd.ExecuteReader())
                {
                    Console.WriteLine("Logs 表结构:");
                    while (reader.Read())
                    {
                        Console.WriteLine($"  {reader["COLUMN_NAME"]}: {reader["DATA_TYPE"]}, Length: {reader["CHARACTER_MAXIMUM_LENGTH"]}");
                    }
                }
            }

            return true;
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine($"日志数据库连接失败: {ex.Message}");
        return false;
    }
}
```

### 第六步：手动测试日志写入

在服务器启动后，添加一个测试按钮或代码：

```csharp
// 测试日志写入
private void TestLogWrite()
{
    var logger = Startup.GetFromFac<ILogger<Startup>>();

    // 设置上下文信息
    Program.AppContextData.log = new Logs();
    Program.AppContextData.log.IP = HLH.Lib.Net.IpAddressHelper.GetLocIP();
    Program.AppContextData.log.MachineName = Environment.MachineName + "-" + Environment.UserName;
    Program.AppContextData.log.Operator = "测试用户";
    Program.AppContextData.log.ModName = "测试模块";
    Program.AppContextData.log.ActionName = "测试动作";
    Program.AppContextData.log.User_ID = 1;

    // 记录不同级别的日志
    logger.LogInformation("这是一条测试信息日志");
    logger.LogWarning("这是一条测试警告日志");
    logger.LogError("这是一条测试错误日志");

    Console.WriteLine("已发送测试日志，请检查数据库 Logs 表");
}
```

## 常见问题排查

### 问题 1：BufferSize 导致日志未刷新

**症状：** 日志未立即写入数据库

**原因：** BufferSize 设置为 10，需要积累 10 条日志才会写入数据库

**解决方法：**
- 临时将 BufferSize 设置为 1
- 或者在代码中手动刷新：`adoNetAppender.Flush();`

### 问题 2：连接字符串错误

**症状：** 日志系统初始化成功，但数据库没有写入任何日志

**原因：** 连接字符串不正确或数据库不可访问

**解决方法：**
- 在 `CreateLoggerRepository` 方法中添加断点
- 查看 `adoNetAppender.ConnectionString` 的值
- 使用该连接字符串手动测试数据库连接

### 问题 3：SQL 命令错误

**症状：** 日志记录时抛出异常

**原因：** SQL 命令或参数与数据库表结构不匹配

**解决方法：**
- 检查 SQL 命令的表名和字段名是否正确
- 检查参数数量和类型是否匹配
- 直接在数据库中测试 SQL 命令

### 问题 4：Appender 未正确附加

**症状：** Logger 存在，但没有 Appender

**原因：** AdoNetAppender 未正确附加到 Repository

**解决方法：**
- 检查 `BasicConfigurator.Configure()` 的调用
- 检查 `Repository.GetAppenders()` 的返回值
- 确保在配置完成后，Appender 已附加

### 问题 5：日志级别过滤

**症状：** 某些级别的日志没有被记录

**原因：** 日志级别设置过高，过滤掉了部分日志

**解决方法：**
- 检查配置文件中的 `<level value="..."/>` 设置
- 检查 Startup.cs 中的日志过滤器
- 将日志级别设置为 `DEBUG` 或 `ALL`

## 预期的调试输出

### 正常情况下的输出示例：

```
========== 开始创建日志仓库 ==========
传入的连接字符串: 有值
日志仓库名称: RUINORERP_Shared_LoggerRepository
从配置文件读取BufferSize: 10
BufferSize设置为: 10
已应用传入的连接字符串进行日志数据库连接，长度: 123
最终连接字符串: Server=xxx;Database=erpnew;...
SQL命令: INSERT INTO Logs ([Date],[Level],[Logger],[Message],[Exception],[Operator],[ModName],[Path],[ActionName],[IP],[MAC],[MachineName],[User_ID]) VALUES (@log_date, @log_level, @logger, @Message, @Exception, @Operator, @ModName, @Path, @ActionName, @IP, @MAC, @MachineName, @User_ID)
已添加标准参数: @log_date, @log_level, @logger
已添加自定义参数，参数总数: 13
AdoNetAppender.ActivateOptions() 已调用
日志仓库已成功创建并配置
附加的Appender数量: 1
  Appender: ADONetAppender, Type: AdoNetAppender
========== 日志仓库创建完成 ==========

========== 准备记录日志 ==========
日志级别: Information
消息: 服务器启动成功
Logger名称: RUINORERP.Server.Startup
Logger类型: LoggerImpl
Logger的Appender数量: 1
  Appender: ADONetAppender, Type: AdoNetAppender
IsDebugEnabled: True
IsInfoEnabled: True
IsWarnEnabled: True
IsErrorEnabled: True
调用 _log.Info()
========== 日志记录完成 ==========
```

## 调试工具

### 1. SQL Server Profiler
使用 SQL Server Profiler 监控数据库活动：
- 打开 SQL Server Profiler
- 连接到数据库服务器
- 设置过滤器：只监控 `INSERT INTO Logs` 命令
- 启动服务器并查看是否有相关的 SQL 命令执行

### 2. 数据库查询
实时查询 Logs 表：

```sql
-- 查询最近的日志记录
SELECT TOP 10 *
FROM Logs
ORDER BY Date DESC

-- 查询特定时间段的日志
SELECT *
FROM Logs
WHERE Date > DATEADD(MINUTE, -5, GETDATE())
ORDER BY Date DESC
```

### 3. DebugView
使用 DebugView 工具查看所有 Debug 输出：
- 下载并安装 DebugView
- 启动 DebugView
- 启动服务器
- 查看所有 Debug 输出信息

## 下一步行动

1. ✅ 重新编译并启动服务器
2. ✅ 查看"输出"窗口中的调试信息
3. ✅ 根据调试信息检查上述关键检查点
4. ✅ 使用 SQL Server Profiler 监控数据库活动
5. ✅ 执行手动测试日志写入
6. ✅ 如果发现问题，记录具体的调试输出
7. ✅ 根据问题类型参考上述"常见问题排查"章节

## 联系支持

如果以上步骤仍无法解决问题，请提供以下信息：
1. 启动时的完整调试输出（从"========== 开始创建日志仓库 ==========" 到"========== 日志仓库创建完成 =========="）
2. 记录日志时的完整调试输出（从"========== 准备记录日志 ==========" 到"========== 日志记录完成 =========="）
3. SQL Server Profiler 的监控结果（如果使用了）
4. 数据库 Logs 表的当前数据
5. 任何异常或错误信息
