# IEntityCacheManager 新增式更新功能说明

## 功能概述

`IEntityCacheManager` 接口中的 `UpdateEntity` 方法现已支持**新增式更新**功能。这意味着：

1. **如果实体存在于缓存列表中**：更新该实体的数据
2. **如果实体不存在于缓存列表中**：自动将新实体添加到列表末尾

无需使用专门的 `Add` 方法，一个 `UpdateEntity` 方法即可同时处理更新和新增操作。

## 方法签名

```csharp
// 泛型方法
void UpdateEntity<T>(T entity) where T : class;

// 非泛型方法（使用表名）
void UpdateEntity(string tableName, object entity);
```

## 使用示例

### 1. 更新现有实体

```csharp
// 假设缓存中已存在 ID = 1 的用户
var existingUser = new tb_Employee 
{ 
    EmployeeID = 1,
    EmployeeName = "张三",
    DepartmentID = 1
};

// 更新现有实体
cacheManager.UpdateEntity(existingUser);
```

### 2. 添加新实体（新增式更新）

```csharp
// 新用户，不存在于缓存中
var newUser = new tb_Employee 
{ 
    EmployeeID = 999,
    EmployeeName = "新员工",
    DepartmentID = 2
};

// 自动添加到缓存列表末尾
cacheManager.UpdateEntity(newUser);
```

### 3. 批量操作

```csharp
// 混合更新操作：既有更新也有新增
var employees = new List<tb_Employee>
{
    new tb_Employee { EmployeeID = 1, EmployeeName = "张三（已更新）" }, // 更新现有
    new tb_Employee { EmployeeID = 1001, EmployeeName = "新员工A" },     // 新增
    new tb_Employee { EmployeeID = 1002, EmployeeName = "新员工B" }      // 新增
};

foreach (var employee in employees)
{
    cacheManager.UpdateEntity(employee);
}
```

## 内部实现逻辑

### 支持的缓存类型

新增式更新功能支持以下缓存列表类型：

1. **JArray** (JSON 数组)
2. **List<ExpandoObject>** (动态对象列表)
3. **List<T>** (强类型泛型列表)

### 实现步骤

1. **查找现有实体**：根据主键值在缓存列表中查找匹配的实体
2. **更新或新增**：
   - 如果找到匹配实体：替换现有实体数据
   - 如果未找到匹配实体：添加到列表末尾
3. **类型兼容性检查**：
   - 支持相同类型实体
   - 支持类型转换（如果目标类型兼容）

### 日志记录

系统会自动记录详细日志：

```csharp
// 更新现有实体时的日志
"已成功更新表 {tableName} 中ID为 {entityId} 的实体缓存"

// 添加新实体时的日志  
"已将ID为 {entityId} 的新实体添加到表 {tableName} 的列表缓存中"
```

## 性能考虑

1. **查找效率**：O(n) 线性查找，适合中小型数据集
2. **内存管理**：添加新实体会增加缓存内存占用
3. **缓存一致性**：自动维护缓存同步元数据

## 注意事项

1. **主键要求**：实体必须包含正确配置的主键字段
2. **表结构信息**：确保表已通过 `InitializeTableSchema` 正确注册
3. **类型兼容**：添加新实体时注意类型兼容性问题
4. **缓存过滤**：只处理标记为 `IsCacheable = true` 的表

## 错误处理

系统具备完善的错误处理机制：

- 实体为 null：静默跳过
- 表不可缓存：记录调试日志并跳过
- 类型转换失败：记录警告日志并跳过
- 其他异常：记录错误日志但不影响系统运行

## 总结

新增式更新功能简化了缓存操作，使开发者无需区分更新和新增操作，提高了代码的简洁性和可维护性。此功能特别适用于：

- 批量数据同步场景
- 实时数据更新场景  
- 不确定数据存在性的场景
- 简化业务逻辑的场景