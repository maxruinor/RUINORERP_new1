# 统一单据业务状态管理体系架构设计方案

## 设计概述

本设计方案基于现有的状态管理系统，构建了一个统一的单据业务状态管理体系架构，重点解决了"提交后是否允许修改"的业务规则设计问题。方案支持两种业务场景模式：严格模式（提交后不允许修改）和灵活模式（提交后未审核状态下允许修改），并提供了完整的规则判断机制、全局配置方案、状态流转控制、权限控制实现以及与BaseEntity的集成方案。

### 架构组成

1. **规则定义层**：定义提交后修改规则模式枚举、配置结构和判断方法
2. **状态流转控制层**：根据不同模式控制状态转换逻辑
3. **权限检查层**：在UnifiedStateManager中实现差异化的权限检查
4. **实体集成层**：确保BaseEntity状态变更与权限控制的一致性
5. **全局配置层**：在GlobalStateRules中提供全局配置管理和持久化

## 1. 规则判断机制

### 1.1 模式定义

在系统中，我们定义两种业务规则模式：

```csharp
/// <summary>
/// 提交后修改规则模式枚举
/// </summary>
enum SubmitModifyRuleMode
{
    /// <summary>
    /// 严格模式 - 提交后不允许修改
    /// </summary>
    Strict,
    
    /// <summary>
    /// 灵活模式 - 提交后未审核状态下允许修改
    /// </summary>
    Flexible
}
```

### 1.2 规则配置结构

在GlobalStateRulesManager中添加模式配置存储：

```csharp
/// <summary>
/// 提交后修改规则模式配置字典
/// 键：实体类型或模块名称
/// 值：对应的模式配置
/// </summary>
private Dictionary<string, SubmitModifyRuleMode> _submitModifyRuleModes;

/// <summary>
/// 默认提交后修改规则模式
/// </summary>
private SubmitModifyRuleMode _defaultSubmitModifyRuleMode = SubmitModifyRuleMode.Strict; // 默认采用严格模式
```

### 1.3 规则判断方法

```csharp
/// <summary>
/// 获取指定实体类型的提交后修改规则模式
/// </summary>
/// <param name="entityType">实体类型</param>
/// <returns>提交后修改规则模式</returns>
public SubmitModifyRuleMode GetSubmitModifyRuleMode(Type entityType)
{
    if (entityType == null)
        return _defaultSubmitModifyRuleMode;
        
    string key = entityType.FullName;
    if (_submitModifyRuleModes.TryGetValue(key, out SubmitModifyRuleMode mode))
        return mode;
        
    // 尝试使用模块级别的配置
    string moduleKey = entityType.Namespace;
    if (_submitModifyRuleModes.TryGetValue(moduleKey, out mode))
        return mode;
        
    // 如果没有找到特定配置，返回默认模式
    return _defaultSubmitModifyRuleMode;
}
```

### 1.4 规则配置方法

```csharp
/// <summary>
/// 设置特定实体类型的提交后修改规则模式
/// </summary>
/// <param name="entityType">实体类型</param>
/// <param name="mode">提交后修改规则模式</param>
public void SetSubmitModifyRuleMode(Type entityType, SubmitModifyRuleMode mode)
{
    if (entityType == null)
        return;
        
    _submitModifyRuleModes[entityType.FullName] = mode;
}

/// <summary>
/// 设置模块级别的提交后修改规则模式
/// </summary>
/// <param name="moduleNamespace">模块命名空间</param>
/// <param name="mode">提交后修改规则模式</param>
public void SetModuleSubmitModifyRuleMode(string moduleNamespace, SubmitModifyRuleMode mode)
{
    if (string.IsNullOrEmpty(moduleNamespace))
        return;
        
    _submitModifyRuleModes[moduleNamespace] = mode;
}

/// <summary>
/// 设置默认的提交后修改规则模式
/// </summary>
/// <param name="mode">提交后修改规则模式</param>
public void SetDefaultSubmitModifyRuleMode(SubmitModifyRuleMode mode)
{
    _defaultSubmitModifyRuleMode = mode;
}

## 2. 状态流转控制逻辑

### 2.1 严格模式状态流转

在严格模式下，状态转换路径如下：

```csharp
/// <summary>
/// 初始化严格模式下的DataStatus状态转换规则
/// </summary>
private void InitializeStrictModeDataStatusTransitionRules()
{
    var statusType = typeof(DataStatus);
    _stateTransitionRules[statusType] = new Dictionary<object, List<object>>
    {
        [DataStatus.草稿] = new List<object> { DataStatus.确认, DataStatus.作废 },
        [DataStatus.确认] = new List<object> { DataStatus.提交, DataStatus.作废 },  // 确认 -> 提交
        [DataStatus.提交] = new List<object> { DataStatus.审核, DataStatus.作废 },  // 提交 -> 审核，不能返回确认
        [DataStatus.审核] = new List<object> { DataStatus.完结, DataStatus.作废 },
        [DataStatus.完结] = new List<object> { },
        [DataStatus.作废] = new List<object> { }
    };
}
```

### 2.2 灵活模式状态流转

在灵活模式下，状态转换路径如下：

```csharp
/// <summary>
/// 初始化灵活模式下的DataStatus状态转换规则
/// </summary>
private void InitializeFlexibleModeDataStatusTransitionRules()
{
    var statusType = typeof(DataStatus);
    _stateTransitionRules[statusType] = new Dictionary<object, List<object>>
    {
        [DataStatus.草稿] = new List<object> { DataStatus.确认, DataStatus.作废 },
        [DataStatus.确认] = new List<object> { DataStatus.提交, DataStatus.作废 },
        [DataStatus.提交] = new List<object> { DataStatus.审核, DataStatus.确认, DataStatus.作废 },  // 提交 -> 确认（允许修改）
        [DataStatus.审核] = new List<object> { DataStatus.完结, DataStatus.作废 },
        [DataStatus.完结] = new List<object> { },
        [DataStatus.作废] = new List<object> { }
    };
}
```

### 2.3 动态规则加载逻辑

```csharp
/// <summary>
/// 根据模式初始化数据状态转换规则
/// <summary>
/// <param name="mode">提交后修改规则模式</param>
public void InitializeDataStatusTransitionRulesByMode(SubmitModifyRuleMode mode)
{
    var statusType = typeof(DataStatus);
    
    switch (mode)
    {
        case SubmitModifyRuleMode.Strict:
            InitializeStrictModeDataStatusTransitionRules();
            break;
        case SubmitModifyRuleMode.Flexible:
            InitializeFlexibleModeDataStatusTransitionRules();
            break;
        default:
            InitializeStrictModeDataStatusTransitionRules(); // 默认严格模式
            break;
    }
}

/// <summary>
/// 根据实体类型动态获取状态转换规则
/// </summary>
/// <param name="entityType">实体类型</param>
/// <param name="fromStatus">源状态</param>
/// <returns>允许的目标状态列表</returns>
public List<object> GetAllowedTransitionStatuses(Type entityType, object fromStatus)
{
    // 检查是否是DataStatus类型
    if (fromStatus is DataStatus && entityType != null)
    {
        // 获取该实体类型的模式
        SubmitModifyRuleMode mode = GetSubmitModifyRuleMode(entityType);
        
        // 根据模式获取允许的状态转换
        if (mode == SubmitModifyRuleMode.Flexible && (DataStatus)fromStatus == DataStatus.提交)
        {
            // 灵活模式：提交状态可以转换到确认状态
            return new List<object> { DataStatus.审核, DataStatus.确认, DataStatus.作废 };
        }
    }
    
    // 使用默认规则
    Type statusType = fromStatus.GetType();
    if (_stateTransitionRules.TryGetValue(statusType, out var rules))
    {
        if (rules.TryGetValue(fromStatus, out var allowedStatuses))
        {
            return allowedStatuses;
        }
    }
    
    return new List<object>();
}

## 3. UnifiedStateManager中的差异化权限检查实现

### 3.1 扩展UnifiedStateManager构造函数

```csharp
/// <summary>
/// 构造函数
/// </summary>
/// <param name="logger">日志记录器</param>
public UnifiedStateManager(ILogger<UnifiedStateManager> logger)
{
    _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    _transitionRules = new Dictionary<Type, Dictionary<object, List<object>>>(GlobalStateRulesManager.Instance.StateTransitionRules.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToDictionary(innerKvp => innerKvp.Key, innerKvp => innerKvp.Value)));
    
    // 初始化权限检查相关逻辑
    InitializePermissionCheckLogic();
}

/// <summary>
/// 初始化权限检查逻辑
/// </summary>
private void InitializePermissionCheckLogic()
{
    // 初始化权限检查相关的缓存或配置
}
```

### 3.2 增强的权限检查方法

```csharp
/// <summary>
/// 检查是否可以执行指定操作，并返回详细消息
/// </summary>
/// <param name="entity">实体对象</param>
/// <param name="action">操作类型</param>
/// <returns>操作结果</returns>
public (bool CanExecute, string Message) CanExecuteActionWithMessage(BaseEntity entity, MenuItemEnums action)
{
    if (entity == null)
        return (false, "实体对象为空");
    
    // 获取实体的当前数据状态
    object statusValue = GetBusinessStatus(entity, typeof(DataStatus));
    if (statusValue == null)
        return (true, "实体无状态限制"); // 无状态限制时默认允许
    
    DataStatus currentStatus = (DataStatus)statusValue;
    
    // 特殊处理修改操作的权限检查
    if (action == MenuItemEnums.Modify)
    {
        return CheckModifyPermission(entity, currentStatus);
    }
    
    // 其他操作的权限检查逻辑保持不变
    // ...
    
    // 使用原有的权限检查逻辑
    var rulesManager = GlobalStateRulesManager.Instance;
    if (rulesManager.IsActionAllowed(entity.GetType(), currentStatus, action))
    {
        return (true, "允许执行操作");
    }
    else
    {
        return (false, $"当前状态 {currentStatus} 不允许执行 {action} 操作");
    }
}

/// <summary>
/// 根据提交后修改规则模式检查修改权限
/// </summary>
/// <param name="entity">实体对象</param>
/// <param name="currentStatus">当前数据状态</param>
/// <returns>操作结果</returns>
private (bool CanExecute, string Message) CheckModifyPermission(BaseEntity entity, DataStatus currentStatus)
{
    // 草稿和确认状态总是允许修改
    if (currentStatus == DataStatus.草稿 || currentStatus == DataStatus.确认)
    {
        return (true, "当前状态允许修改");
    }
    
    // 完结和作废状态总是不允许修改
    if (currentStatus == DataStatus.完结 || currentStatus == DataStatus.作废)
    {
        return (false, "当前状态不允许修改");
    }
    
    // 关键判断：提交状态下的修改权限
    if (currentStatus == DataStatus.提交)
    {
        // 获取该实体类型对应的提交后修改规则模式
        SubmitModifyRuleMode mode = GlobalStateRulesManager.Instance.GetSubmitModifyRuleMode(entity.GetType());
        
        if (mode == SubmitModifyRuleMode.Flexible)
        {
            // 灵活模式：提交状态下允许修改
            return (true, "当前模式下，提交状态允许修改");
        }
        else
        {
            // 严格模式：提交状态下不允许修改
            return (false, "当前模式下，提交状态不允许修改，请先撤回至确认状态");
        }
    }
    
    // 审核状态一般不允许修改，除非有特殊配置
    if (currentStatus == DataStatus.审核)
    {
        return (false, "审核状态下不允许修改");
    }
    
    return (true, "默认允许修改");
}
```

### 3.3 增强的状态转换验证方法

```csharp
/// <summary>
/// 验证业务状态转换是否合法（考虑提交后修改规则模式）
/// </summary>
/// <param name="entity">实体对象</param>
/// <param name="fromStatus">源状态</param>
/// <param name="toStatus">目标状态</param>
/// <returns>状态转换结果</returns>
public StateTransitionResult ValidateBusinessStatusTransitionWithMode(BaseEntity entity, DataStatus fromStatus, DataStatus toStatus)
{
    // 首先进行基本的状态转换验证
    StateTransitionResult baseResult = ValidateBusinessStatusTransitionAsync(fromStatus, toStatus);
    if (!baseResult.IsSuccess)
    {
        return baseResult;
    }
    
    // 如果实体不为空，考虑提交后修改规则模式的影响
    if (entity != null)
    {
        // 特殊处理：从提交状态转换到确认状态
        if (fromStatus == DataStatus.提交 && toStatus == DataStatus.确认)
        {
            // 获取该实体类型对应的模式
            SubmitModifyRuleMode mode = GlobalStateRulesManager.Instance.GetSubmitModifyRuleMode(entity.GetType());
            
            if (mode == SubmitModifyRuleMode.Strict)
            {
                // 严格模式：不允许从提交状态回到确认状态
                return StateTransitionResult.Denied("在严格模式下，提交后不允许撤回修改");
            }
            // 灵活模式：允许从提交状态回到确认状态
        }
    }
    
    return baseResult;
}
```

### 3.4 UI控件状态获取方法增强

```csharp
/// <summary>
/// 获取实体当前状态对应的UI控件状态
/// </summary>
/// <param name="entity">实体对象</param>
/// <returns>UI控件状态字典</returns>
public Dictionary<string, bool> GetUIControlStates(BaseEntity entity)
{
    if (entity == null)
        return new Dictionary<string, bool>();
    
    // 获取默认的UI控件状态
    Dictionary<string, bool> states = new Dictionary<string, bool>(GlobalStateRulesManager.Instance.GetUIButtonRules(entity.GetType(), entity.GetType().GetProperty("DataStatus")?.GetValue(entity)));
    
    // 获取当前数据状态
    object statusValue = GetBusinessStatus(entity, typeof(DataStatus));
    if (statusValue is DataStatus currentStatus && currentStatus == DataStatus.提交)
    {
        // 根据提交后修改规则模式调整UI控件状态
        SubmitModifyRuleMode mode = GlobalStateRulesManager.Instance.GetSubmitModifyRuleMode(entity.GetType());
        
        if (mode == SubmitModifyRuleMode.Flexible)
        {
            // 灵活模式：在提交状态下启用修改相关控件
            states["btnModify"] = true;
            states["btnEdit"] = true;
            // 允许从提交状态返回确认状态的按钮
            states["btnBackToConfirm"] = true;
        }
        else
        {
            // 严格模式：在提交状态下禁用修改相关控件
            states["btnModify"] = false;
            states["btnEdit"] = false;
            states["btnBackToConfirm"] = false;
        }
    }
    
    return states;
}

## 4. 与BaseEntity的集成方案

### 4.1 扩展BaseEntity类

```csharp
/// <summary>
/// 基础实体类扩展
/// </summary>
public partial class BaseEntity
{
    /// <summary>
    /// 实体的提交后修改规则模式
    /// </summary>
    [Browsable(false)]
    [NotMapped]
    public SubmitModifyRuleMode? EntitySubmitModifyRuleMode { get; private set; }
    
    /// <summary>
    /// 状态管理器实例
    /// </summary>
    [Browsable(false)]
    [NotMapped]
    private IUnifiedStateManager StateManager => ContainerManager.Container.Resolve<IUnifiedStateManager>();
    
    /// <summary>
    /// 设置实体的提交后修改规则模式（优先级高于全局设置）
    /// </summary>
    /// <param name="mode">规则模式</param>
    public void SetSubmitModifyRuleMode(SubmitModifyRuleMode mode)
    {
        EntitySubmitModifyRuleMode = mode;
    }
    
    /// <summary>
    /// 获取实体的提交后修改规则模式（先检查实体本地设置，再检查全局设置）
    /// </summary>
    /// <returns>规则模式</returns>
    public SubmitModifyRuleMode GetSubmitModifyRuleMode()
    {
        // 优先使用实体本地设置的模式
        if (EntitySubmitModifyRuleMode.HasValue)
        {
            return EntitySubmitModifyRuleMode.Value;
        }
        
        // 否则使用全局规则管理器中的配置
        return GlobalStateRulesManager.Instance.GetSubmitModifyRuleMode(this.GetType());
    }
    
    /// <summary>
    /// 检查当前实体是否允许修改
    /// </summary>
    /// <returns>是否允许修改及原因</returns>
    public (bool CanModify, string Reason) CheckCanModify()
    {
        // 获取当前数据状态
        var statusProperty = this.GetType().GetProperty("DataStatus");
        if (statusProperty == null || !(statusProperty.GetValue(this) is DataStatus currentStatus))
        {
            return (true, "实体无状态限制");
        }
        
        // 草稿和确认状态总是允许修改
        if (currentStatus == DataStatus.草稿 || currentStatus == DataStatus.确认)
        {
            return (true, "当前状态允许修改");
        }
        
        // 完结和作废状态总是不允许修改
        if (currentStatus == DataStatus.完结 || currentStatus == DataStatus.作废)
        {
            return (false, "当前状态不允许修改");
        }
        
        // 关键判断：提交状态下的修改权限
        if (currentStatus == DataStatus.提交)
        {
            SubmitModifyRuleMode mode = GetSubmitModifyRuleMode();
            
            if (mode == SubmitModifyRuleMode.Flexible)
            {
                return (true, "当前模式下，提交状态允许修改");
            }
            else
            {
                return (false, "当前模式下，提交状态不允许修改");
            }
        }
        
        // 其他状态（如审核）不允许修改
        return (false, $"当前状态 {currentStatus} 不允许修改");
    }
    
    /// <summary>
    /// 尝试修改实体，先检查权限
    /// </summary>
    /// <param name="action">修改操作委托</param>
    /// <returns>操作结果</returns>
    public ModifyEntityResult TryModify(Action action)
    {
        // 检查是否允许修改
        var (canModify, reason) = CheckCanModify();
        if (!canModify)
        {
            return ModifyEntityResult.Failed(reason);
        }
        
        try
        {
            // 执行修改操作
            action?.Invoke();
            return ModifyEntityResult.Success();
        }
        catch (Exception ex)
        {
            return ModifyEntityResult.Failed(ex.Message);
        }
    }
}

/// <summary>
/// 实体修改结果
/// </summary>
public class ModifyEntityResult
{
    /// <summary>
    /// 是否成功
    /// </summary>
    public bool IsSuccess { get; private set; }
    
    /// <summary>
    /// 消息
    /// </summary>
    public string Message { get; private set; }
    
    /// <summary>
    /// 创建成功结果
    /// </summary>
    public static ModifyEntityResult Success(string message = "修改成功")
    {
        return new ModifyEntityResult { IsSuccess = true, Message = message };
    }
    
    /// <summary>
    /// 创建失败结果
    /// </summary>
    public static ModifyEntityResult Failed(string message)
    {
        return new ModifyEntityResult { IsSuccess = false, Message = message };
    }
}
```

### 4.2 状态变更前的权限检查集成

```csharp
/// <summary>
/// 状态变更前的权限检查扩展方法
/// </summary>
public static class StateTransitionExtensions
{
    /// <summary>
    /// 安全地转换实体状态，包含权限检查
    /// </summary>
    /// <param name="entity">实体对象</param>
    /// <param name="toStatus">目标状态</param>
    /// <returns>状态转换结果</returns>
    public static StateTransitionResult SafeTransitionTo(this BaseEntity entity, DataStatus toStatus)
    {
        if (entity == null)
            return StateTransitionResult.Failed("实体对象为空");
        
        // 获取当前状态
        DataStatus fromStatus = DataStatus.草稿;
        var statusProperty = entity.GetType().GetProperty("DataStatus");
        if (statusProperty != null && statusProperty.GetValue(entity) is DataStatus currentStatus)
        {
            fromStatus = currentStatus;
        }
        
        // 获取状态管理器
        var stateManager = ContainerManager.Container.Resolve<IUnifiedStateManager>();
        
        // 验证状态转换（考虑提交后修改规则模式）
        StateTransitionResult result = stateManager.ValidateBusinessStatusTransitionWithMode(entity, fromStatus, toStatus);
        if (!result.IsSuccess)
        {
            return result;
        }
        
        // 触发状态变更前事件
        var beforeEvent = new StateTransitionEventArgs(entity, typeof(DataStatus), fromStatus, toStatus);
        entity.OnStatusChanging(beforeEvent);
        if (beforeEvent.Cancel)
        {
            return StateTransitionResult.Failed(beforeEvent.CancelReason);
        }
        
        try
        {
            // 执行状态变更
            statusProperty.SetValue(entity, toStatus);
            
            // 触发状态变更后事件
            var afterEvent = new StateTransitionEventArgs(entity, typeof(DataStatus), fromStatus, toStatus);
            entity.OnStatusChanged(afterEvent);
            
            return StateTransitionResult.Success();
        }
        catch (Exception ex)
        {
            // 触发状态变更失败事件
            var failedEvent = new StateTransitionFailedEventArgs(entity, typeof(DataStatus), fromStatus, toStatus, ex);
            entity.OnStatusTransitionFailed(failedEvent);
            
            return StateTransitionResult.Failed($"状态转换失败: {ex.Message}");
        }
    }
    
    /// <summary>
    /// 提交审核（根据当前规则模式决定是否允许后续修改）
    /// </summary>
    /// <param name="entity">实体对象</param>
    /// <returns>操作结果</returns>
    public static OperationResult SubmitForApproval(this BaseEntity entity)
    {
        // 转换到提交状态
        StateTransitionResult result = entity.SafeTransitionTo(DataStatus.提交);
        if (!result.IsSuccess)
        {
            return OperationResult.Failed(result.ErrorMessage);
        }
        
        // 记录操作日志
        LogHelper.Logger.Info($"实体 {entity.GetType().Name} 已提交审核，ID = {entity.ID}");
        
        return OperationResult.Success();
    }
    
    /// <summary>
    /// 撤回提交（仅在灵活模式下允许）
    /// </summary>
    /// <param name="entity">实体对象</param>
    /// <returns>操作结果</returns>
    public static OperationResult WithdrawSubmission(this BaseEntity entity)
    {
        // 检查当前状态
        DataStatus currentStatus = DataStatus.草稿;
        var statusProperty = entity.GetType().GetProperty("DataStatus");
        if (statusProperty != null && statusProperty.GetValue(entity) is DataStatus status)
        {
            currentStatus = status;
        }
        
        if (currentStatus != DataStatus.提交)
        {
            return OperationResult.Failed("只有已提交状态的实体才能撤回");
        }
        
        // 转换回确认状态
        StateTransitionResult result = entity.SafeTransitionTo(DataStatus.确认);
        if (!result.IsSuccess)
        {
            return OperationResult.Failed(result.ErrorMessage);
        }
        
        // 记录操作日志
        LogHelper.Logger.Info($"实体 {entity.GetType().Name} 已撤回提交，ID = {entity.ID}");
        
        return OperationResult.Success();
    }
}
```

### 4.3 实体级别的状态验证集成

```csharp
/// <summary>
/// 实体级别的状态验证集成
/// </summary>
public partial class BaseEntity
{
    /// <summary>
    /// 状态变更前事件
    /// </summary>
    [Browsable(false)]
    public event EventHandler<StateTransitionEventArgs> StatusChanging;
    
    /// <summary>
    /// 状态变更后事件
    /// </summary>
    [Browsable(false)]
    public event EventHandler<StateTransitionEventArgs> StatusChanged;
    
    /// <summary>
    /// 状态变更失败事件
    /// </summary>
    [Browsable(false)]
    public event EventHandler<StateTransitionFailedEventArgs> StatusTransitionFailed;
    
    /// <summary>
    /// 触发状态变更前事件
    /// </summary>
    /// <param name="e">事件参数</param>
    protected virtual void OnStatusChanging(StateTransitionEventArgs e)
    {
        StatusChanging?.Invoke(this, e);
    }
    
    /// <summary>
    /// 触发状态变更后事件
    /// </summary>
    /// <param name="e">事件参数</param>
    protected virtual void OnStatusChanged(StateTransitionEventArgs e)
    {
        StatusChanged?.Invoke(this, e);
        // 触发原有的StatusChanged事件以保持向后兼容
        OnStatusChanged();
    }
    
    /// <summary>
    /// 触发状态变更失败事件
    /// </summary>
    /// <param name="e">事件参数</param>
    protected virtual void OnStatusTransitionFailed(StateTransitionFailedEventArgs e)
    {
        StatusTransitionFailed?.Invoke(this, e);
    }
    
    /// <summary>
    /// 根据提交后修改规则模式获取UI操作权限
    /// </summary>
    /// <param name="action">操作类型</param>
    /// <returns>是否允许操作及原因</returns>
    public (bool Allowed, string Reason) GetActionPermission(MenuItemEnums action)
    {
        // 获取状态管理器
        var stateManager = ContainerManager.Container.Resolve<IUnifiedStateManager>();
        
        // 调用状态管理器的增强权限检查方法
        return stateManager.CanExecuteActionWithMessage(this, action);
    }
}

## 5. GlobalStateRules中的全局配置方案

### 5.1 扩展GlobalStateRulesManager类

```csharp
/// <summary>
/// 全局状态规则管理器
/// </summary>
public class GlobalStateRulesManager
{
    // 单例实例
    private static readonly Lazy<GlobalStateRulesManager> _instance = new Lazy<GlobalStateRulesManager>(() => new GlobalStateRulesManager(), LazyThreadSafetyMode.ExecutionAndPublication);
    
    // 存储状态转换规则的字典
    private readonly Dictionary<Type, Dictionary<object, List<object>> _stateTransitionRules;
    
    // 存储UI按钮规则的字典
    private readonly Dictionary<Type, Dictionary<object, Dictionary<string, bool>> _uiButtonRules;
    
    // 存储操作权限规则的字典
    private readonly Dictionary<Type, Dictionary<object, List<object>> _actionPermissionRules;
    
    /// <summary>
    /// 提交后修改规则模式字典（存储不同实体类型的规则模式）
    /// </summary>
    private readonly Dictionary<Type, SubmitModifyRuleMode> _submitModifyRuleModes;
    
    /// <summary>
    /// 默认提交后修改规则模式
    /// </summary>
    private SubmitModifyRuleMode _defaultSubmitModifyRuleMode = SubmitModifyRuleMode.Strict;
    
    /// <summary>
    /// 获取单例实例
    /// </summary>
    public static GlobalStateRulesManager Instance
    {
        get { return _instance.Value; }
    }
    
    /// <summary>
    /// 构造函数（私有，防止外部实例化）
    /// </summary>
    private GlobalStateRulesManager()
    {
        _stateTransitionRules = new Dictionary<Type, Dictionary<object, List<object>>();
        _uiButtonRules = new Dictionary<Type, Dictionary<object, Dictionary<string, bool>>();
        _actionPermissionRules = new Dictionary<Type, Dictionary<object, List<object>>();
        _submitModifyRuleModes = new Dictionary<Type, SubmitModifyRuleMode>();
        
        // 初始化默认规则
        InitializeDefaultRules();
    }
    
    // 原有属性和方法保持不变
    // ...
    
    /// <summary>
    /// 设置默认的提交后修改规则模式
    /// </summary>
    /// <param name="mode">规则模式</param>
    public void SetDefaultSubmitModifyRuleMode(SubmitModifyRuleMode mode)
    {
        _defaultSubmitModifyRuleMode = mode;
        
        // 记录配置变更日志
        LogHelper.Logger.Info($"默认提交后修改规则模式已设置为: {mode}");
    }
    
    /// <summary>
    /// 为特定实体类型设置提交后修改规则模式
    /// </summary>
    /// <param name="entityType">实体类型</param>
    /// <param name="mode">规则模式</param>
    public void SetEntitySubmitModifyRuleMode(Type entityType, SubmitModifyRuleMode mode)
    {
        if (entityType == null)
            throw new ArgumentNullException(nameof(entityType));
        
        if (!typeof(BaseEntity).IsAssignableFrom(entityType))
            throw new ArgumentException($"类型 {entityType.Name} 不是 BaseEntity 的子类");
        
        // 存储实体类型的规则模式
        _submitModifyRuleModes[entityType] = mode;
        
        // 记录配置变更日志
        LogHelper.Logger.Info($"实体类型 {entityType.Name} 的提交后修改规则模式已设置为: {mode}");
    }
    
    /// <summary>
    /// 批量设置实体类型的提交后修改规则模式
    /// </summary>
    /// <param name="entityRules">实体类型和规则模式的映射字典</param>
    public void SetBatchEntitySubmitModifyRuleModes(Dictionary<Type, SubmitModifyRuleMode> entityRules)
    {
        if (entityRules == null)
            throw new ArgumentNullException(nameof(entityRules));
        
        foreach (var kvp in entityRules)
        {
            SetEntitySubmitModifyRuleMode(kvp.Key, kvp.Value);
        }
    }
    
    /// <summary>
    /// 获取指定实体类型的提交后修改规则模式
    /// </summary>
    /// <param name="entityType">实体类型</param>
    /// <returns>规则模式</returns>
    public SubmitModifyRuleMode GetSubmitModifyRuleMode(Type entityType)
    {
        if (entityType == null)
            throw new ArgumentNullException(nameof(entityType));
        
        // 如果实体类型有特定配置，返回该配置
        if (_submitModifyRuleModes.TryGetValue(entityType, out SubmitModifyRuleMode mode))
        {
            return mode;
        }
        
        // 否则返回默认配置
        return _defaultSubmitModifyRuleMode;
    }
    
    /// <summary>
    /// 移除指定实体类型的提交后修改规则模式配置（将使用默认配置）
    /// </summary>
    /// <param name="entityType">实体类型</param>
    /// <returns>是否成功移除</returns>
    public bool RemoveEntitySubmitModifyRuleMode(Type entityType)
    {
        if (entityType == null)
            throw new ArgumentNullException(nameof(entityType));
        
        bool removed = _submitModifyRuleModes.Remove(entityType);
        
        if (removed)
        {
            LogHelper.Logger.Info($"已移除实体类型 {entityType.Name} 的提交后修改规则模式特定配置，将使用默认配置");
        }
        
        return removed;
    }
    
    /// <summary>
    /// 获取所有实体类型的提交后修改规则模式配置
    /// </summary>
    /// <returns>实体类型和规则模式的映射字典副本</returns>
    public Dictionary<Type, SubmitModifyRuleMode> GetAllEntitySubmitModifyRuleModes()
    {
        // 返回副本以防止外部修改
        return new Dictionary<Type, SubmitModifyRuleMode>(_submitModifyRuleModes);
    }
}
```

### 5.2 配置初始化与加载机制

```csharp
/// <summary>
/// 全局状态规则初始化器扩展
/// </summary>
public static class GlobalStateRulesInitializerExtensions
{
    /// <summary>
    /// 初始化全局规则（包含提交后修改规则模式）
    /// </summary>
    /// <param name="services">服务集合</param>
    /// <param name="configureModes">提交后修改规则模式配置委托</param>
    /// <returns>服务集合</returns>
    public static IServiceCollection InitializeGlobalRules(
        this IServiceCollection services,
        Action<SubmitModifyRuleModeConfiguration> configureModes = null)
    {
        // 注册状态管理器
        services.AddSingleton<IUnifiedStateManager, UnifiedStateManager>();
        
        // 获取规则管理器实例
        var rulesManager = GlobalStateRulesManager.Instance;
        
        // 应用提交后修改规则模式配置
        if (configureModes != null)
        {
            var config = new SubmitModifyRuleModeConfiguration(rulesManager);
            configureModes(config);
        }
        
        return services;
    }
}

/// <summary>
/// 提交后修改规则模式配置器
/// <summary>
public class SubmitModifyRuleModeConfiguration
{
    private readonly GlobalStateRulesManager _rulesManager;
    
    /// <summary>
    /// 构造函数
    /// <summary>
    /// <param name="rulesManager">规则管理器实例</param>
    public SubmitModifyRuleModeConfiguration(GlobalStateRulesManager rulesManager)
    {
        _rulesManager = rulesManager ?? throw new ArgumentNullException(nameof(rulesManager));
    }
    
    /// <summary>
    /// 设置默认提交后修改规则模式
    /// <summary>
    /// <param name="mode">规则模式</param>
    public SubmitModifyRuleModeConfiguration WithDefaultMode(SubmitModifyRuleMode mode)
    {
        _rulesManager.SetDefaultSubmitModifyRuleMode(mode);
        return this;
    }
    
    /// <summary>
    /// 为特定实体类型设置提交后修改规则模式
    /// <summary>
    /// <param name="entityType">实体类型</param>
    /// <param name="mode">规则模式</param>
    public SubmitModifyRuleModeConfiguration WithEntityMode(Type entityType, SubmitModifyRuleMode mode)
    {
        _rulesManager.SetEntitySubmitModifyRuleMode(entityType, mode);
        return this;
    }
    
    /// <summary>
    /// 为多个实体类型批量设置提交后修改规则模式
    /// <summary>
    /// <param name="entityModes">实体类型和规则模式的映射字典</param>
    public SubmitModifyRuleModeConfiguration WithEntityModes(IEnumerable<Tuple<Type, SubmitModifyRuleMode>> entityModes)
    {
        if (entityModes == null)
            throw new ArgumentNullException(nameof(entityModes));
        
        Dictionary<Type, SubmitModifyRuleMode> modesDict = new Dictionary<Type, SubmitModifyRuleMode>();
        foreach (var item in entityModes)
        {
            modesDict[item.Item1] = item.Item2;
        }
        
        _rulesManager.SetBatchEntitySubmitModifyRuleModes(modesDict);
        return this;
    }
}
```

### 5.3 配置持久化与动态加载

```csharp
/// <summary>
/// 提交后修改规则模式配置服务
/// <summary>
public class SubmitModifyRuleModeConfigService : ISubmitModifyRuleModeConfigService
{
    private readonly IConfiguration _configuration;
    private readonly GlobalStateRulesManager _rulesManager;
    
    /// <summary>
    /// 构造函数
    /// <summary>
    /// <param name="configuration">配置对象</param>
    public SubmitModifyRuleModeConfigService(IConfiguration configuration)
    {
        _configuration = configuration;
        _rulesManager = GlobalStateRulesManager.Instance;
    }
    
    /// <summary>
    /// 从配置文件加载提交后修改规则模式
    /// <summary>
    public void LoadFromConfiguration()
    {
        try
        {
            // 从配置文件读取默认模式
            var defaultModeSection = _configuration.GetSection("GlobalStateRules:DefaultSubmitModifyRuleMode");
            if (defaultModeSection.Exists() && Enum.TryParse(defaultModeSection.Value, out SubmitModifyRuleMode defaultMode))
            {
                _rulesManager.SetDefaultSubmitModifyRuleMode(defaultMode);
                LogHelper.Logger.Info($"已从配置文件加载默认提交后修改规则模式: {defaultMode}");
            }
            
            // 从配置文件读取特定实体类型的模式
            var entityModesSection = _configuration.GetSection("GlobalStateRules:EntitySubmitModifyRuleModes");
            if (entityModesSection.Exists())
            {
                foreach (var childSection in entityModesSection.GetChildren())
                {
                    // 尝试获取实体类型
                    Type entityType = Type.GetType(childSection.Key);
                    if (entityType != null && Enum.TryParse(childSection.Value, out SubmitModifyRuleMode mode))
                    {
                        _rulesManager.SetEntitySubmitModifyRuleMode(entityType, mode);
                        LogHelper.Logger.Info($"已从配置文件加载实体类型 {entityType.Name} 的提交后修改规则模式: {mode}");
                    }
                    else
                    {
                        LogHelper.Logger.Warn($"无法从配置文件加载实体类型 {childSection.Key} 的提交后修改规则模式");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            LogHelper.Logger.Error("从配置文件加载提交后修改规则模式时发生错误", ex);
        }
    }
    
    /// <summary>
    /// 保存提交后修改规则模式到配置文件
    /// <summary>
    /// <param name="configFilePath">配置文件路径</param>
    public void SaveToConfiguration(string configFilePath)
    {
        // 实现保存配置到文件的逻辑
        // ...
    }
    
    /// <summary>
    /// 动态更新提交后修改规则模式（不需要重启应用程序）
    /// <summary>
    /// <param name="defaultMode">默认规则模式（可为空）</param>
    /// <param name="entityModes">实体类型规则模式映射（可为空）</param>
    public void UpdateRuleModes(SubmitModifyRuleMode? defaultMode = null, Dictionary<Type, SubmitModifyRuleMode> entityModes = null)
    {
        // 更新默认模式
        if (defaultMode.HasValue)
        {
            _rulesManager.SetDefaultSubmitModifyRuleMode(defaultMode.Value);
        }
        
        // 更新实体类型特定模式
        if (entityModes != null && entityModes.Count > 0)
        {
            _rulesManager.SetBatchEntitySubmitModifyRuleModes(entityModes);
        }
        
        // 记录配置更新日志
        LogHelper.Logger.Info("已动态更新提交后修改规则模式配置");
    }
}

/// <summary>
/// 提交后修改规则模式配置服务接口
/// <summary>
public interface ISubmitModifyRuleModeConfigService
{
    /// <summary>
    /// 从配置文件加载提交后修改规则模式
    /// <summary>
    void LoadFromConfiguration();
    
    /// <summary>
    /// 保存提交后修改规则模式到配置文件
    /// <summary>
    /// <param name="configFilePath">配置文件路径</param>
    void SaveToConfiguration(string configFilePath);
    
    /// <summary>
    /// 动态更新提交后修改规则模式
    /// <summary>
    /// <param name="defaultMode">默认规则模式（可为空）</param>
    /// <param name="entityModes">实体类型规则模式映射（可为空）</param>
    void UpdateRuleModes(SubmitModifyRuleMode? defaultMode = null, Dictionary<Type, SubmitModifyRuleMode> entityModes = null);
}
```

### 5.4 配置使用示例

```csharp
// 在应用程序启动时配置提交后修改规则模式
public void ConfigureServices(IServiceCollection services)
{
    // 方式1：通过扩展方法配置
    services.InitializeGlobalRules(config =>
    {
        // 设置默认模式为严格模式
        config.WithDefaultMode(SubmitModifyRuleMode.Strict)
              // 为特定实体类型设置灵活模式
              .WithEntityMode(typeof(SalesOrder), SubmitModifyRuleMode.Flexible)
              .WithEntityMode(typeof(PurchaseOrder), SubmitModifyRuleMode.Flexible);
    });
    
    // 注册配置服务
    services.AddSingleton<ISubmitModifyRuleModeConfigService, SubmitModifyRuleModeConfigService>();
}

public void Configure(IApplicationBuilder app, IWebHostEnvironment env, ISubmitModifyRuleModeConfigService configService)
{
    // 从配置文件加载规则模式
    configService.LoadFromConfiguration();
    
    // 其他配置...
}

// 配置文件示例 (appsettings.json)
/*
{
  "GlobalStateRules": {
    "DefaultSubmitModifyRuleMode": "Strict",
    "EntitySubmitModifyRuleModes": {
      "RUINORERP.Model.Sales.SalesOrder": "Flexible",
      "RUINORERP.Model.Purchase.PurchaseOrder": "Flexible"
    }
  }
}
*/
```

## 6. 架构流程图与交互说明

### 6.1 状态管理架构整体流程

```
┌───────────────────┐     ┌───────────────────┐     ┌───────────────────┐
│                   │     │                   │     │                   │
│   业务操作层      │────▶│  统一状态管理器   │────▶│ 全局规则管理器    │
│  (UI/API调用)     │◀────│ (UnifiedStateMgr) │◀────│ (GlobalStateRules)│
│                   │     │                   │     │                   │
└────────┬──────────┘     └────────┬──────────┘     └────────┬──────────┘
         │                         │                         │
         │                         │                         │
         ▼                         ▼                         ▼
┌───────────────────┐     ┌───────────────────┐     ┌───────────────────┐
│                   │     │                   │     │                   │
│    实体对象层     │◀────│   状态缓存层      │◀────│ 配置持久化层      │
│    (BaseEntity)   │     │ (StatusCacheMgr)  │     │ (ConfigService)   │
│                   │     │                   │     │                   │
└───────────────────┘     └───────────────────┘     └───────────────────┘
```

### 6.2 提交后修改规则判断流程

```
                      ┌─────────────────────┐
                      │      状态操作       │
                      │      (修改/提交)     │
                      └──────────┬──────────┘
                                 │
                                 ▼
                      ┌─────────────────────┐
                      │  实体当前是否处于    │
                      │     "提交"状态？    │
                      └──────────┬──────────┘
                                 │
            ┌────────────────────┴────────────────────┐
            │                                         │
            ▼                                         ▼
┌─────────────────────┐                   ┌─────────────────────┐
│       否 →          │                   │        是 →         │
│  执行常规权限检查   │                   │ 获取实体类型提交后   │
│                     │                   │    修改规则模式     │
└─────────────────────┘                   └──────────┬──────────┘
                                                    │
                              ┌────────────────────┴────────────────────┐
                              │                                         │
                              ▼                                         ▼
                     ┌─────────────────────┐                   ┌─────────────────────┐
                     │      Strict模式     │                   │     Flexible模式    │
                     │  → 检查是否有权限   │                   │ → 检查是否已审核    │
                     │     撤回提交        │                   │                     │
                     └──────────┬──────────┘                   └──────────┬──────────┘
                                │                                         │
                                ▼                                         ▼
                     ┌─────────────────────┐                   ┌─────────────────────┐
                     │       不允许修改     │                   │ 未审核：允许修改    │
                     │                     │                   │ 已审核：不允许修改  │
                     └─────────────────────┘                   └─────────────────────┘
```

## 7. 实现步骤与迁移指南

### 7.1 实现步骤

1. **添加枚举和基础结构**
   - 创建`SubmitModifyRuleMode`枚举
   - 实现`SubmitModifyRuleHelper`工具类

2. **扩展GlobalStateRulesManager**
   - 添加提交后修改规则模式相关属性和方法
   - 实现配置初始化和加载机制

3. **增强UnifiedStateManager**
   - 添加基于规则模式的权限检查方法
   - 实现差异化的状态转换验证

4. **扩展BaseEntity**
   - 添加规则模式属性和权限检查方法
   - 集成状态变更事件处理

5. **添加配置服务**
   - 实现`ISubmitModifyRuleModeConfigService`和对应实现类
   - 配置持久化与动态加载功能

### 7.2 迁移指南

1. **现有系统迁移**
   - 默认情况下，所有实体将使用严格模式，保持与原有行为一致
   - 可以通过配置文件或代码设置特定实体类型使用灵活模式

2. **API兼容性**
   - 原有API保持向后兼容
   - 新增API支持更细粒度的权限控制

3. **数据库变更**
   - 本设计方案不需要数据库结构变更
   - 规则模式配置存储在应用配置中或内存中

## 8. 总结与最佳实践

### 8.1 设计亮点

1. **灵活性与可配置性**：支持全局默认配置和实体类型特定配置，可通过配置文件或代码动态调整

2. **无缝集成**：与现有状态管理架构无缝集成，保持API兼容性

3. **完善的权限控制**：提供细粒度的权限检查机制，支持不同业务场景需求

4. **可扩展性**：设计考虑了未来可能的扩展需求，如支持更多规则模式或自定义规则

### 8.2 最佳实践

1. **合理选择规则模式**
   - 对财务、合规性要求高的单据使用严格模式
   - 对业务灵活性要求高的单据使用灵活模式

2. **配置管理建议**
   - 生产环境中建议通过配置文件管理规则模式，便于部署和维护
   - 开发环境中可通过代码直接配置，提高开发效率

3. **性能优化**
   - 规则模式判断结果可以考虑缓存，减少重复计算
   - 对于频繁访问的实体类型，建议预加载其规则配置

4. **日志记录**
   - 记录关键状态变更和权限检查结果，便于审计和问题排查
   - 记录规则配置变更，确保配置可追溯

本设计方案为统一单据业务状态管理提供了完整的解决方案，既满足了严格的业务控制需求，又兼顾了业务灵活性，可根据实际业务场景灵活配置和使用。
```
```