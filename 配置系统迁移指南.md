# RUINORERP 配置系统迁移指南

## 1. 概述

本指南详细说明如何将现有项目中的旧配置管理代码迁移到新的统一配置管理系统。迁移过程包括识别旧代码、标记过时、替换实现和验证功能四个主要步骤。

## 2. 旧配置代码识别

### 2.1 主要问题点

旧配置系统存在以下主要问题：

- **硬编码配置目录**：多处使用 `"SysConfigFiles"` 硬编码目录
- **路径解析不一致**：不同模块使用不同的路径解析方式
- **代码重复**：配置读写逻辑在多个地方重复实现
- **难以扩展**：缺乏统一的接口和抽象

### 2.2 需要迁移的文件

根据代码搜索，以下文件包含需要迁移的配置管理代码：

| 文件路径 | 硬编码路径 | 行号 |
|---------|-----------|------|
| RUINORERP.Business\Config\ConfigManagerService.cs | `_configDirectory = Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles");` | 35 |
| RUINORERP.Business\Config\ConfigVersionService.cs | `_versionPath = Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles", "Versions");` | 43 |
| RUINORERP.Business\Config\ConfigVersionService.cs | `string configFilePath = Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles", $"{configType}.json");` | 207 |
| RUINORERP.Global\GlobalConstants.cs | `public const string DynamicConfigFileDirectory = "SysConfigFiles";` | 18 |
| RUINORERP.Server\Controls\GlobalConfigControl.cs | `private readonly string basePath = System.IO.Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles");` | 60 |
| RUINORERP.Server\Startup.cs | `string configDirectory = Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles");` | 376 |
| RUINORERP.Server\Startup.cs | `.SetBasePath(System.IO.Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles"))` | 393 |
| RUINORERP.UI\Program.cs | `string configDirectory = Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles");` | 69 |
| RUINORERP.UI\Startup.cs | `.SetBasePath(Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles"))` | 246 |
| RUINORERP.UI\Startup.cs | `string configDirectory = Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles");` | 270 |
| RUINORERP.UI\Startup.cs | `string configDirectory = Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles");` | 1045 |
| RUINORERP.UI\Startup.cs | `.SetBasePath(System.IO.Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles"))` | 1072 |

## 3. 迁移步骤

### 3.1 准备工作

1. **添加新配置系统引用**：
   - 在需要使用配置的项目中添加对 `RUINORERP.Common` 的引用
   - 确保已安装必要的依赖包：Newtonsoft.Json

2. **注册配置服务**：
   - 在应用程序启动时配置依赖注入
   - 注册所有需要的配置类型

### 3.2 标记旧代码为过时

使用 `[Obsolete]` 属性标记旧的配置管理类和方法，提供迁移指引。

**示例**：

```csharp
// 在 RUINORERP.Business.Config.ConfigManagerService.cs 中
[Obsolete("请使用新的 IConfigurationManager<TConfig> 接口代替", true)]
public class ConfigManagerService
{
    // 旧代码...
}

// 在 RUINORERP.Global.GlobalConstants.cs 中
[Obsolete("请使用 IConfigPathResolver 获取配置路径", true)]
public const string DynamicConfigFileDirectory = "SysConfigFiles";
```

### 3.3 实现迁移替换

#### 3.3.1 配置路径迁移

将所有硬编码的配置路径替换为使用 `IConfigPathResolver`：

**旧代码**：
```csharp
string configDirectory = Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles");
string configFilePath = Path.Combine(configDirectory, "AppSettings.json");
```

**新代码**：
```csharp
// 注入 IConfigPathResolver
private readonly IConfigPathResolver _pathResolver;

// 使用解析器获取路径
string configFilePath = _pathResolver.GetFilePath(ConfigPathType.Server, "AppSettings.json");
// 确保目录存在
_pathResolver.EnsureDirectoryExists(ConfigPathType.Server);
```

#### 3.3.2 配置管理迁移

将配置读写逻辑迁移到 `IConfigurationManager<TConfig>`：

**旧代码**：
```csharp
// 读取配置
public T ReadConfig<T>(string configType)
{
    string filePath = Path.Combine(_configDirectory, $"{configType}.json");
    if (File.Exists(filePath))
    {
        string json = File.ReadAllText(filePath);
        return JsonConvert.DeserializeObject<T>(json);
    }
    return default;
}

// 保存配置
public void SaveConfig<T>(string configType, T config)
{
    string filePath = Path.Combine(_configDirectory, $"{configType}.json");
    string json = JsonConvert.SerializeObject(config, Formatting.Indented);
    File.WriteAllText(filePath, json);
}
```

**新代码**：
```csharp
// 注入泛型配置管理器
private readonly IConfigurationManager<AppSettingsConfig> _appSettingsManager;

// 读取配置
public AppSettingsConfig ReadAppSettings()
{
    _appSettingsManager.Load(ConfigPathType.Server);
    return _appSettingsManager.CurrentConfig;
}

// 保存配置
public void SaveAppSettings(AppSettingsConfig config)
{
    _appSettingsManager.Save(config, ConfigPathType.Server);
}
```

#### 3.3.3 配置类型注册

在应用启动时注册所有配置类型：

```csharp
// 在 Startup.cs 中
public void ConfigureServices(IServiceCollection services)
{
    // 添加配置管理器
    services.AddConfigManager(options =>
    {
        // 注册配置类型
        options.RegisterConfigType<AppSettingsConfig>();
        options.RegisterConfigType<DatabaseConfig>();
        options.RegisterConfigType<SecurityConfig>();
    });
    
    // 其他服务配置...
}
```

### 3.4 迁移验证

迁移完成后，执行以下验证步骤：

1. **编译检查**：确保项目能够成功编译
2. **配置读写测试**：验证配置能够正确读写
3. **路径检查**：确认配置文件存储在正确的位置
4. **功能测试**：验证依赖配置的功能正常工作

## 4. 详细迁移示例

### 4.1 ConfigManagerService 迁移示例

**旧代码**：
```csharp
// RUINORERP.Business.Config.ConfigManagerService.cs
public class ConfigManagerService
{
    private readonly string _configDirectory;
    
    public ConfigManagerService()
    {
        _configDirectory = Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles");
    }
    
    // 配置读写方法...
}
```

**新实现**：
```csharp
// 1. 标记旧类为过时
[Obsolete("请使用新的 IConfigurationManager<TConfig> 接口代替", true)]
public class ConfigManagerService
{
    // 旧实现...
}

// 2. 创建新的服务实现
public class NewConfigManagerService
{
    private readonly IConfigPathResolver _pathResolver;
    private readonly ConfigurationManagerFactory _configManagerFactory;
    
    public NewConfigManagerService(IConfigPathResolver pathResolver, ConfigurationManagerFactory configManagerFactory)
    {
        _pathResolver = pathResolver;
        _configManagerFactory = configManagerFactory;
    }
    
    public T GetConfig<T>(string configName)
    {
        var configManager = _configManagerFactory.GetConfigurationManager<T>();
        configManager.Load(ConfigPathType.Server);
        return configManager.CurrentConfig;
    }
    
    public void SaveConfig<T>(string configName, T config)
    {
        var configManager = _configManagerFactory.GetConfigurationManager<T>();
        configManager.Save(config, ConfigPathType.Server);
    }
}
```

### 4.2 Startup.cs 迁移示例

**旧代码**：
```csharp
// 在 Startup.cs 中
public void ConfigureServices(IServiceCollection services)
{
    string configDirectory = Path.Combine(Directory.GetCurrentDirectory(), "SysConfigFiles");
    
    // 使用配置目录...
    builder.SetBasePath(configDirectory);
}
```

**新代码**：
```csharp
// 在 Startup.cs 中
public void ConfigureServices(IServiceCollection services)
{
    // 添加配置管理器服务
    services.AddConfigManager(options =>
    {
        // 注册应用需要的所有配置类型
        options.RegisterConfigType<AppSettings>();
        options.RegisterConfigType<LoggingConfig>();
        options.RegisterConfigType<DatabaseConfig>();
    });
    
    // 添加配置同步服务（如果需要）
    services.AddConfigSyncService();
    
    // 其他服务配置...
}

public void Configure(IApplicationBuilder app, IWebHostEnvironment env, IConfigPathResolver pathResolver)
{
    // 确保配置目录存在
    pathResolver.EnsureDirectoryExists(ConfigPathType.Server);
    pathResolver.EnsureDirectoryExists(ConfigPathType.Version);
    
    // 其他配置...
}
```

## 5. 代码清理计划

### 5.1 分阶段清理策略

| 阶段 | 操作 | 时间 |
|------|------|------|
| 1 | 添加新配置系统，标记旧代码为过时 | 立即 |
| 2 | 在开发分支中替换所有旧代码使用 | 1-2 周 |
| 3 | 全面测试新配置系统 | 1 周 |
| 4 | 生产环境部署 | 2 周 |
| 5 | 移除标记为过时的旧代码 | 生产环境稳定后 1 个月 |

### 5.2 旧代码移除注意事项

- **备份**：在移除前确保代码已备份
- **搜索引用**：确保所有引用都已替换
- **日志记录**：保留关键配置操作的日志
- **兼容性**：确保向后兼容性（如果需要）

## 6. 常见问题和解决方案

### 6.1 配置文件路径变更

**问题**：新系统使用不同的配置文件路径

**解决方案**：
- 使用 `IConfigPathResolver` 的自定义实现保留旧路径
- 或者实现配置文件迁移工具，将旧路径的配置复制到新路径

### 6.2 配置格式不兼容

**问题**：旧配置格式与新配置格式不兼容

**解决方案**：
- 实现配置迁移转换器
- 在加载配置时进行格式检查和转换

### 6.3 依赖注入问题

**问题**：某些类无法使用依赖注入

**解决方案**：
- 使用 `ConfigManagerStaticAccessor` 进行静态访问
- 重构类以支持依赖注入

## 7. 结论

通过本指南的步骤，您可以系统性地将旧配置管理代码迁移到新的统一配置系统。迁移后，系统将获得更好的可维护性、可扩展性和一致性。

请在迁移过程中严格遵循测试步骤，确保系统功能不受影响。如有任何问题，请参考示例代码或联系开发团队。