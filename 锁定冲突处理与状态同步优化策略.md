# 锁定冲突处理与状态同步优化策略

## 1. 锁定冲突处理优化

### 1.1 冲突检测增强

#### 1.1.1 多级别冲突检测

为了更精确地检测锁定冲突，我们实现多级别冲突检测机制：

1. **资源级检测**：检测特定单据或数据记录是否被锁定。
2. **操作级检测**：检测正在执行的操作类型与现有锁定的兼容性。
3. **时间级检测**：考虑锁定时长和预计操作时间，进行智能冲突预测。

```csharp
public class EnhancedLockConflictDetector : ILockConflictDetector
{
    private readonly ILockManagerService _lockManagerService;
    private readonly ILogger<EnhancedLockConflictDetector> _logger;
    
    public EnhancedLockConflictDetector(ILockManagerService lockManagerService, ILogger<EnhancedLockConflictDetector> logger)
    {
        _lockManagerService = lockManagerService;
        _logger = logger;
    }
    
    public async Task<LockConflictInfo> DetectConflictAsync(LockRequest request)
    {
        // 1. 资源级检测
        var lockStatus = await _lockManagerService.CheckLockStatusAsync(request.ResourceId, request.ResourceType);
        
        if (!lockStatus.IsLocked)
        {
            return null; // 无冲突
        }
        
        // 2. 操作级检测
        bool operationCompatible = await IsOperationCompatibleAsync(
            lockStatus.CurrentLockInfo,
            request.OperationType,
            request.UserId);
            
        if (operationCompatible)
        {
            return null; // 操作兼容，无冲突
        }
        
        // 3. 时间级检测
        LockConflictType conflictType = await DetermineConflictTypeAsync(
            lockStatus.CurrentLockInfo,
            request);
        
        return new LockConflictInfo
        {
            ConflictType = conflictType,
            CurrentLockInfo = lockStatus.CurrentLockInfo,
            Request = request
        };
    }
    
    private async Task<bool> IsOperationCompatibleAsync(LockInfo currentLock, OperationType requestedOperation, string userId)
    {
        // 如果是同一用户，则操作兼容
        if (currentLock.UserId == userId)
        {
            return true;
        }
        
        // 根据锁定类型和请求的操作类型判断兼容性
        switch (currentLock.LockType)
        {
            case LockType.ReadOnly:
                // 只读锁与只读操作兼容
                return requestedOperation == OperationType.Read;
            
            case LockType.Single:
            case LockType.MasterDetail:
            case LockType.Temporary:
                // 排他锁与任何其他操作都不兼容
                return false;
                
            default:
                return false;
        }
    }
    
    private async Task<LockConflictType> DetermineConflictTypeAsync(LockInfo currentLock, LockRequest request)
    {
        // 如果锁定即将过期，标记为可等待冲突
        TimeSpan timeUntilExpiry = currentLock.ExpiryTime - DateTime.Now;
        if (timeUntilExpiry.TotalMinutes < 2) // 锁定将在2分钟内过期
        {
            return LockConflictType.ShortDuration;
        }
        
        // 如果是同一用户在不同会话尝试锁定，标记为会话冲突
        if (currentLock.UserId == request.UserId && currentLock.SessionId != request.SessionId)
        {
            return LockConflictType.SameUserDifferentSession;
        }
        
        // 常规冲突
        return LockConflictType.Normal;
    }
}
```

### 1.2 智能冲突解决策略

#### 1.2.1 冲突解决策略

针对不同类型的锁定冲突，我们提供以下解决策略：

1. **等待策略**：对于短期冲突，可以等待锁释放后再尝试获取。
2. **协商策略**：对于长时间锁定，可以向锁定用户发送请求，询问是否可以提前释放。
3. **强制策略**：对于异常锁定（如用户已离线但锁定未释放），管理员可以强制解锁。

```csharp
public class AdaptiveLockConflictResolver : ILockConflictResolver
{
    private readonly ILockManagerService _lockManagerService;
    private readonly IUserNotificationService _notificationService;
    private readonly ISessionService _sessionService;
    private readonly ILogger<AdaptiveLockConflictResolver> _logger;
    
    public AdaptiveLockConflictResolver(
        ILockManagerService lockManagerService,
        IUserNotificationService notificationService,
        ISessionService sessionService,
        ILogger<AdaptiveLockConflictResolver> logger)
    {
        _lockManagerService = lockManagerService;
        _notificationService = notificationService;
        _sessionService = sessionService;
        _logger = logger;
    }
    
    public async Task<LockResolutionResult> ResolveConflictAsync(LockConflictInfo conflictInfo)
    {
        switch (conflictInfo.ConflictType)
        {
            case LockConflictType.ShortDuration:
                // 短期冲突，采用等待策略
                return await HandleShortDurationConflictAsync(conflictInfo);
                
            case LockConflictType.SameUserDifferentSession:
                // 同一用户不同会话，询问用户是否要接管锁定
                return await HandleSameUserConflictAsync(conflictInfo);
                
            case LockConflictType.Normal:
                // 检查锁定用户是否在线
                bool isUserOnline = await _sessionService.IsUserOnlineAsync(conflictInfo.CurrentLockInfo.UserId);
                
                if (!isUserOnline)
                {
                    // 用户不在线，可能是异常锁定
                    return await HandleAbandonedLockAsync(conflictInfo);
                }
                else
                {
                    // 用户在线，采用协商策略
                    return await HandleActiveUserConflictAsync(conflictInfo);
                }
                
            default:
                return new LockResolutionResult { Success = false, Message = "无法解决的冲突类型" };
        }
    }
    
    private async Task<LockResolutionResult> HandleShortDurationConflictAsync(LockConflictInfo conflictInfo)
    {
        // 计算需要等待的时间
        TimeSpan waitTime = conflictInfo.CurrentLockInfo.ExpiryTime - DateTime.Now;
        if (waitTime.TotalSeconds < 0) waitTime = TimeSpan.Zero;
        
        // 额外增加一点缓冲时间
        waitTime = waitTime.Add(TimeSpan.FromSeconds(1));
        
        _logger.LogInformation($"等待短期锁定释放: 资源={conflictInfo.Request.ResourceType}:{conflictInfo.Request.ResourceId}, 等待时间={waitTime.TotalSeconds}秒");
        
        // 等待锁定释放
        await Task.Delay(waitTime);
        
        // 尝试再次获取锁定
        var result = await _lockManagerService.TryLockDocumentAsync(conflictInfo.Request);
        
        if (result.Success)
        {
            return new LockResolutionResult
            {
                Success = true,
                Message = "锁定已获取",
                LockId = result.LockId
            };
        }
        else
        {
            // 如果仍然无法获取锁定，可能锁定被续期或其他用户获取
            return new LockResolutionResult
            {
                Success = false,
                Message = "等待后仍无法获取锁定，建议稍后再试",
                CurrentLockInfo = result.CurrentLockInfo
            };
        }
    }
    
    private async Task<LockResolutionResult> HandleSameUserConflictAsync(LockConflictInfo conflictInfo)
    {
        // 向用户发送通知，询问是否接管锁定
        var notificationResult = await _notificationService.SendLockTakeoverRequestAsync(
            conflictInfo.Request.UserId,
            conflictInfo.Request.SessionId,
            new LockTakeoverInfo
            {
                ResourceId = conflictInfo.Request.ResourceId,
                ResourceType = conflictInfo.Request.ResourceType,
                CurrentSessionId = conflictInfo.CurrentLockInfo.SessionId,
                CurrentLockTime = conflictInfo.CurrentLockInfo.AcquireTime
            });
        
        if (notificationResult.Accepted)
        {
            // 用户接受接管，释放旧锁定并创建新锁定
            await _lockManagerService.UnlockDocumentAsync(
                conflictInfo.CurrentLockInfo.LockValue,
                conflictInfo.Request.ResourceId,
                conflictInfo.Request.ResourceType);
            
            var newLockResult = await _lockManagerService.TryLockDocumentAsync(conflictInfo.Request);
            
            return new LockResolutionResult
            {
                Success = newLockResult.Success,
                Message = newLockResult.Success ? "已接管锁定" : "接管失败",
                LockId = newLockResult.LockId
            };
        }
        else
        {
            return new LockResolutionResult
            {
                Success = false,
                Message = "用户拒绝接管锁定",
                CurrentLockInfo = conflictInfo.CurrentLockInfo
            };
        }
    }
    
    private async Task<LockResolutionResult> HandleActiveUserConflictAsync(LockConflictInfo conflictInfo)
    {
        // 向锁定用户发送请求，询问是否可以提前释放
        var notificationResult = await _notificationService.SendLockReleaseRequestAsync(
            conflictInfo.CurrentLockInfo.UserId,
            new LockReleaseRequest
            {
                RequestingUserId = conflictInfo.Request.UserId,
                RequestingUserName = conflictInfo.Request.UserName,
                ResourceId = conflictInfo.Request.ResourceId,
                ResourceType = conflictInfo.Request.ResourceType,
                Reason = conflictInfo.Request.Reason
            });
        
        if (notificationResult.Released)
        {
            // 锁定用户释放了锁定，尝试获取锁定
            var lockResult = await _lockManagerService.TryLockDocumentAsync(conflictInfo.Request);
            
            return new LockResolutionResult
            {
                Success = lockResult.Success,
                Message = lockResult.Success ? "锁定已获取" : "锁定被其他用户抢先获取",
                LockId = lockResult.LockId
            };
        }
        else if (notificationResult.WillReleaseSoon)
        {
            // 用户表示很快会释放，可以尝试等待
            return await HandleShortDurationConflictAsync(conflictInfo);
        }
        else
        {
            return new LockResolutionResult
            {
                Success = false,
                Message = "锁定用户拒绝释放锁定",
                CurrentLockInfo = conflictInfo.CurrentLockInfo
            };
        }
    }
    
    private async Task<LockResolutionResult> HandleAbandonedLockAsync(LockConflictInfo conflictInfo)
    {
        // 检查锁定是否是异常锁定
        bool isAbandoned = await IsAbandonedLockAsync(conflictInfo.CurrentLockInfo);
        
        if (isAbandoned)
        {
            // 对于异常锁定，如果用户具有强制解锁权限，可以强制解锁
            if (conflictInfo.Request.CanForceUnlock)
            {
                await _lockManagerService.ForceUnlockDocumentAsync(
                    conflictInfo.Request.ResourceId,
                    conflictInfo.Request.ResourceType,
                    conflictInfo.Request.UserId);
                
                // 尝试获取锁定
                var lockResult = await _lockManagerService.TryLockDocumentAsync(conflictInfo.Request);
                
                return new LockResolutionResult
                {
                    Success = lockResult.Success,
                    Message = lockResult.Success ? "已强制解锁并获取锁定" : "强制解锁后无法获取锁定",
                    LockId = lockResult.LockId
                };
            }
            else
            {
                return new LockResolutionResult
                {
                    Success = false,
                    Message = "检测到可能的异常锁定，但您没有强制解锁权限",
                    CurrentLockInfo = conflictInfo.CurrentLockInfo,
                    Recommendation = LockResolutionRecommendation.RequestAdminUnlock
                };
            }
        }
        else
        {
            // 虽然用户会话不活跃，但锁定可能是有效的
            return new LockResolutionResult
            {
                Success = false,
                Message = "单据已被锁定",
                CurrentLockInfo = conflictInfo.CurrentLockInfo
            };
        }
    }
    
    private async Task<bool> IsAbandonedLockAsync(LockInfo lockInfo)
    {
        // 检查会话是否仍然有效
        bool sessionValid = await _sessionService.ValidateSessionAsync(lockInfo.SessionId);
        if (sessionValid) return false;
        
        // 检查锁定时间，如果超过一定阈值，可以认为是异常锁定
        TimeSpan lockDuration = DateTime.Now - lockInfo.AcquireTime;
        if (lockDuration.TotalHours > 2) // 锁定超过2小时
        {
            return true;
        }
        
        return false;
    }
}
```

#### 1.2.2 锁定续期机制

为解决长时间编辑场景下的锁定过期问题，我们实现智能锁续期机制：

1. **定时续期**：在锁定过期前自动续期。
2. **活动感知**：基于用户活动自动调整续期策略。
3. **手动续期**：提供手动续期选项。

```csharp
public class SmartLockRenewer : ILockRenewer
{
    private readonly IDistributedLock _distributedLock;
    private readonly ILockManagerService _lockManagerService;
    private readonly ILogger<SmartLockRenewer> _logger;
    private readonly ConcurrentDictionary<string, LockRenewalInfo> _activeRenewals;
    private readonly Timer _renewalTimer;
    
    public SmartLockRenewer(IDistributedLock distributedLock, ILockManagerService lockManagerService, ILogger<SmartLockRenewer> logger)
    {
        _distributedLock = distributedLock;
        _lockManagerService = lockManagerService;
        _logger = logger;
        _activeRenewals = new ConcurrentDictionary<string, LockRenewalInfo>();
        
        // 初始化续期定时器，每30秒检查一次需要续期的锁定
        _renewalTimer = new Timer(CheckAndRenewLocks, null, TimeSpan.Zero, TimeSpan.FromSeconds(30));
    }
    
    public void RegisterLockForRenewal(string lockId, string resourceId, string resourceType, string userId, string sessionId, TimeSpan expiry)
    {
        var renewalInfo = new LockRenewalInfo
        {
            LockId = lockId,
            ResourceId = resourceId,
            ResourceType = resourceType,
            UserId = userId,
            SessionId = sessionId,
            ExpiryTime = DateTime.Now.Add(expiry),
            LastActivityTime = DateTime.Now,
            RenewalInterval = TimeSpan.FromMinutes(10), // 默认每10分钟续期一次
            IsUserActive = true
        };
        
        _activeRenewals[lockId] = renewalInfo;
        _logger.LogInformation($"已注册锁定续期: 资源={resourceType}:{resourceId}, 用户={userId}");
    }
    
    public void UnregisterLockForRenewal(string lockId)
    {
        if (_activeRenewals.TryRemove(lockId, out var removed))
        {
            _logger.LogInformation($"已取消锁定续期: 资源={removed.ResourceType}:{removed.ResourceId}, 用户={removed.UserId}");
        }
    }
    
    public void UpdateUserActivity(string lockId)
    {
        if (_activeRenewals.TryGetValue(lockId, out var renewalInfo))
        {
            renewalInfo.LastActivityTime = DateTime.Now;
            renewalInfo.IsUserActive = true;
        }
    }
    
    public void MarkUserInactive(string lockId)
    {
        if (_activeRenewals.TryGetValue(lockId, out var renewalInfo))
        {
            renewalInfo.IsUserActive = false;
        }
    }
    
    private async void CheckAndRenewLocks(object state)
    {
        try
        {
            var now = DateTime.Now;
            var locksToRenew = _activeRenewals.Values
                .Where(info => ShouldRenewLock(info, now))
                .ToList();
            
            foreach (var lockInfo in locksToRenew)
            {
                await TryRenewLockAsync(lockInfo);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "检查和续期锁定时发生异常");
        }
    }
    
    private bool ShouldRenewLock(LockRenewalInfo lockInfo, DateTime now)
    {
        // 如果锁定即将过期（剩余时间小于续期间隔的一半）
        TimeSpan timeUntilExpiry = lockInfo.ExpiryTime - now;
        if (timeUntilExpiry.TotalMinutes < lockInfo.RenewalInterval.TotalMinutes / 2)
        {
            // 检查用户活动状态
            TimeSpan timeSinceLastActivity = now - lockInfo.LastActivityTime;
            
            // 如果用户活跃，或者虽然不活跃但锁定时间不长
            if (lockInfo.IsUserActive || timeSinceLastActivity.TotalMinutes < 15)
            {
                return true;
            }
        }
        
        return false;
    }
    
    private async Task TryRenewLockAsync(LockRenewalInfo lockInfo)
    {
        try
        {
            // 计算新的过期时间
            TimeSpan newExpiry = TimeSpan.FromMinutes(30); // 续期30分钟
            
            // 尝试续期锁定
            bool renewed = await _distributedLock.ExtendLockAsync(
                $"{lockInfo.ResourceType}:{lockInfo.ResourceId}",
                lockInfo.LockId,
                newExpiry);
            
            if (renewed)
            {
                // 更新锁定信息
                lockInfo.ExpiryTime = DateTime.Now.Add(newExpiry);
                
                // 同步更新Redis中的锁定信息
                await _lockManagerService.UpdateLockExpiryAsync(
                    lockInfo.LockId,
                    lockInfo.ResourceId,
                    lockInfo.ResourceType,
                    lockInfo.ExpiryTime);
                
                _logger.LogInformation($"锁定续期成功: 资源={lockInfo.ResourceType}:{lockInfo.ResourceId}, 新过期时间={lockInfo.ExpiryTime}");
            }
            else
            {
                // 续期失败，可能锁定已被释放
                _logger.LogWarning($"锁定续期失败: 资源={lockInfo.ResourceType}:{lockInfo.ResourceId}");
                
                // 从活动续期列表中移除
                UnregisterLockForRenewal(lockInfo.LockId);
                
                // 通知客户端锁定已丢失
                await NotifyLockLostAsync(lockInfo);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"尝试续期锁定时发生异常: 资源={lockInfo.ResourceType}:{lockInfo.ResourceId}");
        }
    }
    
    private async Task NotifyLockLostAsync(LockRenewalInfo lockInfo)
    {
        try
        {
            // 实现通知客户端锁定已丢失的逻辑
            // 例如通过WebSocket发送通知
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"通知锁定丢失时发生异常: 资源={lockInfo.ResourceType}:{lockInfo.ResourceId}");
        }
    }
    
    public async Task<RenewalStatus> ManualRenewLockAsync(string lockId, string userId, string sessionId)
    {
        if (!_activeRenewals.TryGetValue(lockId, out var lockInfo))
        {
            return new RenewalStatus { Success = false, Message = "未找到待续期的锁定" };
        }
        
        // 验证用户权限
        if (lockInfo.UserId != userId || lockInfo.SessionId != sessionId)
        {
            return new RenewalStatus { Success = false, Message = "无权续期此锁定" };
        }
        
        // 手动续期
        await TryRenewLockAsync(lockInfo);
        
        return new RenewalStatus
        {
            Success = true,
            Message = "锁定已成功续期",
            NewExpiryTime = lockInfo.ExpiryTime
        };
    }
}
```

## 2. 状态同步策略优化

### 2.1 实时状态同步架构

#### 2.1.1 分层状态同步模型

我们设计了一个分层状态同步模型，确保系统在各种网络条件下都能保持状态一致性：

1. **核心状态层**：包含关键业务状态，如单据锁定状态、审批状态等。
2. **扩展状态层**：包含次要业务状态，如编辑进度、修改字段等。
3. **UI状态层**：包含用户界面相关状态，如选中项、展开状态等。

```csharp
public class HierarchicalStateSynchronizer : IStateSynchronizer
{
    private readonly IConnectionMultiplexer _redis;
    private readonly ILogger<HierarchicalStateSynchronizer> _logger;
    private readonly ISocketManager _socketManager;
    private readonly ConcurrentDictionary<string, List<StateSubscription>> _subscriptions;
    
    public HierarchicalStateSynchronizer(
        IConnectionMultiplexer redis,
        ILogger<HierarchicalStateSynchronizer> logger,
        ISocketManager socketManager)
    {
        _redis = redis;
        _logger = logger;
        _socketManager = socketManager;
        _subscriptions = new ConcurrentDictionary<string, List<StateSubscription>>();
        
        // 订阅Redis中的状态变更事件
        var subscriber = _redis.GetSubscriber();
        subscriber.Subscribe("state:change:*", async (channel, message) =>
        {
            string stateType = channel.ToString().Split(':')[2]; // 从channel中提取状态类型
            await HandleStateChangeAsync(stateType, message);
        });
    }
    
    public void Subscribe(string userId, string sessionId, StateType stateType, string resourceFilter, Action<StateUpdate> callback)
    {
        string key = $"{userId}:{sessionId}";
        
        var subscription = new StateSubscription
        {
            UserId = userId,
            SessionId = sessionId,
            StateType = stateType,
            ResourceFilter = resourceFilter,
            Callback = callback
        };
        
        _subscriptions.AddOrUpdate(key, 
            _ => new List<StateSubscription> { subscription }, 
            (_, list) => { list.Add(subscription); return list; });
        
        _logger.LogInformation($"用户 {userId} 已订阅 {stateType} 类型的状态变更");
    }
    
    public void Unsubscribe(string userId, string sessionId, StateType stateType = StateType.All)
    {
        string key = $"{userId}:{sessionId}";
        
        if (_subscriptions.TryGetValue(key, out var subscriptions))
        {
            if (stateType == StateType.All)
            {
                _subscriptions.TryRemove(key, out _);
            }
            else
            {
                subscriptions.RemoveAll(s => s.StateType == stateType);
                
                if (subscriptions.Count == 0)
                {
                    _subscriptions.TryRemove(key, out _);
                }
            }
            
            _logger.LogInformation($"用户 {userId} 已取消订阅 {stateType} 类型的状态变更");
        }
    }
    
    public async Task PublishStateUpdateAsync(StateUpdate update)
    {
        // 根据状态类型确定优先级和处理方式
        int priority = GetStatePriority(update.StateType);
        bool reliableDelivery = priority <= 2; // 核心和扩展状态需要可靠传递
        
        // 发布到Redis
        string channel = $"state:change:{update.StateType}";
        string message = JsonSerializer.Serialize(update);
        await _redis.GetSubscriber().PublishAsync(channel, message);
        
        // 如果是重要状态更新，保存到数据库以便离线同步
        if (reliableDelivery)
        {
            await SaveStateUpdateForOfflineSyncAsync(update);
        }
        
        _logger.LogInformation($"已发布状态更新: 类型={update.StateType}, 资源={update.ResourceType}:{update.ResourceId}");
    }
    
    private async Task HandleStateChangeAsync(string stateType, RedisValue message)
    {
        try
        {
            var update = JsonSerializer.Deserialize<StateUpdate>(message);
            if (update == null) return;
            
            // 确定需要接收此更新的用户
            var targetSubscriptions = FindRelevantSubscriptions(update);
            
            foreach (var subscription in targetSubscriptions)
            {
                try
                {
                    // 调用回调函数
                    subscription.Callback(update);
                    
                    // 对于重要状态更新，确保消息送达客户端
                    if (GetStatePriority(update.StateType) <= 2)
                    {
                        await _socketManager.SendReliableMessageAsync(
                            subscription.UserId,
                            subscription.SessionId,
                            new SocketMessage { Type = MessageType.StateUpdate, Data = update });
                    }
                    else
                    {
                        // 非重要状态更新使用普通消息
                        await _socketManager.SendMessageAsync(
                            subscription.UserId,
                            subscription.SessionId,
                            new SocketMessage { Type = MessageType.StateUpdate, Data = update });
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, $"向用户 {subscription.UserId} 发送状态更新时发生异常");
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"处理 {stateType} 状态变更时发生异常");
        }
    }
    
    private List<StateSubscription> FindRelevantSubscriptions(StateUpdate update)
    {
        var relevantSubscriptions = new List<StateSubscription>();
        
        foreach (var subscriptionList in _subscriptions.Values)
        {
            foreach (var subscription in subscriptionList)
            {
                // 检查状态类型是否匹配
                if (subscription.StateType != update.StateType && subscription.StateType != StateType.All)
                {
                    continue;
                }
                
                // 检查资源过滤器是否匹配
                if (!string.IsNullOrEmpty(subscription.ResourceFilter) &&
                    !MatchesResourceFilter(update, subscription.ResourceFilter))
                {
                    continue;
                }
                
                relevantSubscriptions.Add(subscription);
            }
        }
        
        return relevantSubscriptions;
    }
    
    private bool MatchesResourceFilter(StateUpdate update, string filter)
    {
        // 实现资源过滤器匹配逻辑
        // 例如支持通配符、正则表达式等
        if (filter == "*") return true;
        
        // 简单实现：支持按资源类型过滤
        if (filter.StartsWith("type:"))
        {
            string expectedType = filter.Substring(5);
            return update.ResourceType == expectedType;
        }
        
        return false;
    }
    
    private int GetStatePriority(StateType stateType)
    {
        // 定义状态优先级：1=最高，3=最低
        switch (stateType)
        {
            case StateType.Lock: // 锁定状态 - 核心状态
            case StateType.Approval: // 审批状态 - 核心状态
                return 1;
                
            case StateType.EditProgress: // 编辑进度 - 扩展状态
            case StateType.ModifiedFields: // 修改字段 - 扩展状态
                return 2;
                
            case StateType.UI: // UI状态 - UI状态层
                return 3;
                
            default:
                return 2;
        }
    }
    
    private async Task SaveStateUpdateForOfflineSyncAsync(StateUpdate update)
    {
        try
        {
            // 保存状态更新到数据库，以便离线用户重新连接时同步
            // 实现略
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "保存状态更新到离线同步表时发生异常");
        }
    }
    
    public async Task SyncOfflineUpdatesAsync(string userId, string sessionId, DateTime lastSyncTime)
    {
        try
        {
            // 获取用户上次同步后错过的所有重要状态更新
            var missedUpdates = await GetMissedStateUpdatesAsync(userId, lastSyncTime);
            
            // 按时间顺序发送给客户端
            foreach (var update in missedUpdates.OrderBy(u => u.Timestamp))
            {
                await _socketManager.SendReliableMessageAsync(
                    userId,
                    sessionId,
                    new SocketMessage { Type = MessageType.StateUpdate, Data = update });
            }
            
            _logger.LogInformation($"已同步 {missedUpdates.Count} 条离线状态更新给用户 {userId}");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"同步离线状态更新给用户 {userId} 时发生异常");
        }
    }
    
    private async Task<List<StateUpdate>> GetMissedStateUpdatesAsync(string userId, DateTime lastSyncTime)
    {
        // 从数据库获取用户错过的状态更新
        // 实现略
        return new List<StateUpdate>();
    }
}
```

### 2.2 增量状态同步

为提高状态同步效率，我们实现增量状态同步机制：

1. **变更数据捕获**：只同步发生变更的数据部分。
2. **差异计算**：计算新旧状态之间的差异，只传输变更部分。
3. **批量同步**：将多个小的状态变更合并为批次进行同步。

```csharp
public class IncrementalStateSyncManager : IIncrementalStateSyncManager
{
    private readonly ILogger<IncrementalStateSyncManager> _logger;
    private readonly ConcurrentDictionary<string, StateSnapshot> _lastStateSnapshots;
    private readonly ConcurrentDictionary<string, Queue<MiniStateUpdate>> _pendingUpdates;
    private readonly Timer _batchTimer;
    
    public IncrementalStateSyncManager(ILogger<IncrementalStateSyncManager> logger)
    {
        _logger = logger;
        _lastStateSnapshots = new ConcurrentDictionary<string, StateSnapshot>();
        _pendingUpdates = new ConcurrentDictionary<string, Queue<MiniStateUpdate>>();
        
        // 初始化批处理定时器，每500毫秒处理一次批量更新
        _batchTimer = new Timer(ProcessPendingUpdates, null, TimeSpan.FromMilliseconds(500), TimeSpan.FromMilliseconds(500));
    }
    
    public StateUpdate CalculateIncrementalUpdate(string resourceId, string resourceType, object newState)
    {
        string key = $"{resourceType}:{resourceId}";
        
        // 获取当前状态的快照
        var newSnapshot = CreateStateSnapshot(newState);
        
        // 如果没有之前的快照，返回完整更新
        if (!_lastStateSnapshots.TryGetValue(key, out var oldSnapshot))
        {
            _lastStateSnapshots[key] = newSnapshot;
            
            return new StateUpdate
            {
                ResourceId = resourceId,
                ResourceType = resourceType,
                StateType = StateType.Full,
                Timestamp = DateTime.Now,
                Data = newState,
                IsFullUpdate = true
            };
        }
        
        // 计算增量更新
        var delta = CalculateStateDelta(oldSnapshot, newSnapshot);
        
        // 更新快照
        _lastStateSnapshots[key] = newSnapshot;
        
        // 如果没有变化，返回空更新
        if (delta.Count == 0)
        {
            return null;
        }
        
        return new StateUpdate
        {
            ResourceId = resourceId,
            ResourceType = resourceType,
            StateType = StateType.Incremental,
            Timestamp = DateTime.Now,
            Data = delta,
            IsFullUpdate = false
        };
    }
    
    public object ApplyIncrementalUpdate(object currentState, StateUpdate update)
    {
        if (update.IsFullUpdate)
        {
            // 完整更新直接替换
            return update.Data;
        }
        
        // 应用增量更新
        return ApplyDeltaToState(currentState, (Dictionary<string, object>)update.Data);
    }
    
    public void QueueMiniUpdate(string resourceId, string resourceType, string fieldName, object fieldValue, UpdatePriority priority = UpdatePriority.Normal)
    {
        string key = $"{resourceType}:{resourceId}";
        
        var update = new MiniStateUpdate
        {
            ResourceId = resourceId,
            ResourceType = resourceType,
            FieldName = fieldName,
            FieldValue = fieldValue,
            Priority = priority,
            Timestamp = DateTime.Now
        };
        
        var queue = _pendingUpdates.GetOrAdd(key, _ => new Queue<MiniStateUpdate>());
        
        lock (queue)
        {
            queue.Enqueue(update);
        }
        
        // 对于高优先级更新，立即处理
        if (priority == UpdatePriority.High)
        {
            ProcessUpdatesForResource(key);
        }
    }
    
    private void ProcessPendingUpdates(object state)
    {
        try
        {
            // 处理所有待处理的更新队列
            foreach (var key in _pendingUpdates.Keys.ToList())
            {
                ProcessUpdatesForResource(key);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "处理待处理的状态更新时发生异常");
        }
    }
    
    private void ProcessUpdatesForResource(string key)
    {
        if (!_pendingUpdates.TryGetValue(key, out var queue)) return;
        
        List<MiniStateUpdate> updatesToProcess;
        
        lock (queue)
        {
            if (queue.Count == 0) return;
            
            updatesToProcess = queue.ToList();
            queue.Clear();
        }
        
        // 合并相同字段的更新，只保留最新的
        var mergedUpdates = MergeMiniUpdates(updatesToProcess);
        
        if (mergedUpdates.Count > 0)
        {
            // 创建批量更新
            var batchUpdate = new StateUpdate
            {
                ResourceId = mergedUpdates.First().ResourceId,
                ResourceType = mergedUpdates.First().ResourceType,
                StateType = StateType.Batch,
                Timestamp = DateTime.Now,
                Data = mergedUpdates.ToDictionary(u => u.FieldName, u => u.FieldValue),
                IsFullUpdate = false
            };
            
            // 发布批量更新
            // 这里应该调用状态同步器发布更新
            // await _stateSynchronizer.PublishStateUpdateAsync(batchUpdate);
            
            _logger.LogInformation($"已处理 {mergedUpdates.Count} 个微型状态更新，合并为一个批量更新: {key}");
        }
    }
    
    private List<MiniStateUpdate> MergeMiniUpdates(List<MiniStateUpdate> updates)
    {
        // 按字段名分组，并选择每个字段的最新更新
        return updates
            .GroupBy(u => u.FieldName)
            .Select(g => g.OrderByDescending(u => u.Timestamp).First())
            .ToList();
    }
    
    private StateSnapshot CreateStateSnapshot(object state)
    {
        // 创建状态快照，用于后续比较
        var snapshot = new StateSnapshot();
        
        if (state == null) return snapshot;
        
        // 使用反射获取对象的所有公共属性
        var properties = state.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance);
        
        foreach (var property in properties)
        {
            // 跳过索引器和方法属性
            if (property.GetIndexParameters().Length > 0) continue;
            
            try
            {
                // 获取属性值
                object value = property.GetValue(state);
                
                // 对于简单类型，直接存储；对于复杂类型，递归处理
                if (IsSimpleType(property.PropertyType))
                {
                    snapshot.Fields[property.Name] = value;
                }
                else
                {
                    // 对于复杂类型，可以使用JSON序列化/反序列化来创建深度副本
                    string json = JsonSerializer.Serialize(value);
                    snapshot.Fields[property.Name] = json;
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, $"获取属性值时发生异常: {property.Name}");
            }
        }
        
        return snapshot;
    }
    
    private Dictionary<string, object> CalculateStateDelta(StateSnapshot oldSnapshot, StateSnapshot newSnapshot)
    {
        var delta = new Dictionary<string, object>();
        
        // 查找新增或修改的字段
        foreach (var kvp in newSnapshot.Fields)
        {
            if (!oldSnapshot.Fields.TryGetValue(kvp.Key, out var oldValue))
            {
                // 新增字段
                delta[kvp.Key] = kvp.Value;
            }
            else if (!Equals(oldValue, kvp.Value))
            {
                // 修改字段
                delta[kvp.Key] = kvp.Value;
            }
        }
        
        // 查找删除的字段
        foreach (var key in oldSnapshot.Fields.Keys)
        {
            if (!newSnapshot.Fields.ContainsKey(key))
            {
                // 删除字段，使用特殊标记
                delta[key] = StateDeltaMarkers.Deleted;
            }
        }
        
        return delta;
    }
    
    private object ApplyDeltaToState(object currentState, Dictionary<string, object> delta)
    {
        if (currentState == null || delta.Count == 0) return currentState;
        
        var stateType = currentState.GetType();
        
        // 应用增量更新到当前状态
        foreach (var kvp in delta)
        {
            var property = stateType.GetProperty(kvp.Key, BindingFlags.Public | BindingFlags.Instance);
            if (property == null) continue;
            
            // 检查是否可写
            if (!property.CanWrite) continue;
            
            try
            {
                // 检查是否是删除标记
                if (ReferenceEquals(kvp.Value, StateDeltaMarkers.Deleted))
                {
                    // 设置为默认值
                    property.SetValue(currentState, GetDefaultValue(property.PropertyType));
                }
                else
                {
                    // 对于复杂类型，可能需要反序列化
                    object valueToSet = kvp.Value;
                    if (!property.PropertyType.IsInstanceOfType(kvp.Value) && kvp.Value is string jsonString)
                    {
                        try
                        {
                            valueToSet = JsonSerializer.Deserialize(jsonString, property.PropertyType);
                        }
                        catch
                        {
                            // 如果反序列化失败，使用原始值
                        }
                    }
                    
                    property.SetValue(currentState, valueToSet);
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, $"设置属性值时发生异常: {kvp.Key}");
            }
        }
        
        return currentState;
    }
    
    private bool IsSimpleType(Type type)
    {
        // 判断是否是简单类型（值类型、字符串、枚举等）
        return type.IsPrimitive || 
               type.IsEnum || 
               type == typeof(string) || 
               type == typeof(decimal) || 
               type == typeof(DateTime) || 
               type == typeof(DateTimeOffset) || 
               type == typeof(TimeSpan) || 
               type == typeof(Guid) ||
               (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>) && IsSimpleType(type.GetGenericArguments()[0]));
    }
    
    private object GetDefaultValue(Type type)
    {
        if (type.IsValueType)
        {
            return Activator.CreateInstance(type);
        }
        return null;
    }
}

// 辅助类
public class StateSnapshot
{
    public Dictionary<string, object> Fields { get; } = new Dictionary<string, object>();
}

public class MiniStateUpdate
{
    public string ResourceId { get; set; }
    public string ResourceType { get; set; }
    public string FieldName { get; set; }
    public object FieldValue { get; set; }
    public UpdatePriority Priority { get; set; }
    public DateTime Timestamp { get; set; }
}

public enum UpdatePriority
{
    Low,
    Normal,
    High,
    Critical
}

public static class StateDeltaMarkers
{
    public static readonly object Deleted = new object();
}
```

### 2.3 网络自适应同步

为了适应不同的网络环境，我们实现网络自适应同步机制：

1. **网络质量检测**：定期检测网络质量，根据网络状况调整同步策略。
2. **动态压缩**：根据网络带宽动态调整消息压缩级别。
3. **失败重试**：智能重试机制，避免网络波动导致状态不同步。

```csharp
public class NetworkAdaptiveSyncManager : INetworkAdaptiveSyncManager
{
    private readonly IStateSynchronizer _stateSynchronizer;
    private readonly ISocketManager _socketManager;
    private readonly ICompressionService _compressionService;
    private readonly ILogger<NetworkAdaptiveSyncManager> _logger;
    
    private NetworkQuality _currentNetworkQuality = NetworkQuality.Good;
    private CompressionLevel _currentCompressionLevel = CompressionLevel.Optimal;
    private int _messageBatchSize = 10;
    private int _retryAttempts = 3;
    private readonly ConcurrentDictionary<string, List<QueuedSyncMessage>> _pendingMessages;
    private readonly Timer _networkQualityTimer;
    private readonly Timer _pendingMessageTimer;
    
    public NetworkAdaptiveSyncManager(
        IStateSynchronizer stateSynchronizer,
        ISocketManager socketManager,
        ICompressionService compressionService,
        ILogger<NetworkAdaptiveSyncManager> logger)
    {
        _stateSynchronizer = stateSynchronizer;
        _socketManager = socketManager;
        _compressionService = compressionService;
        _logger = logger;
        _pendingMessages = new ConcurrentDictionary<string, List<QueuedSyncMessage>>();
        
        // 初始化网络质量检测定时器，每10秒检查一次
        _networkQualityTimer = new Timer(CheckNetworkQuality, null, TimeSpan.Zero, TimeSpan.FromSeconds(10));
        
        // 初始化待处理消息处理定时器，每1秒处理一次
        _pendingMessageTimer = new Timer(ProcessPendingMessages, null, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));
        
        // 注册网络事件监听
        _socketManager.OnConnectionQualityChanged += OnConnectionQualityChanged;
        _socketManager.OnMessageSent += OnMessageSent;
        _socketManager.OnMessageFailed += OnMessageFailed;
    }
    
    public async Task SendStateUpdateAsync(string userId, string sessionId, StateUpdate update)
    {
        // 根据网络质量调整发送策略
        switch (_currentNetworkQuality)
        {
            case NetworkQuality.Excellent:
            case NetworkQuality.Good:
                // 网络良好，直接发送
                await SendMessageDirectlyAsync(userId, sessionId, update);
                break;
                
            case NetworkQuality.Fair:
                // 网络一般，进行压缩后发送
                await SendCompressedMessageAsync(userId, sessionId, update);
                break;
                
            case NetworkQuality.Poor:
            case NetworkQuality.VeryPoor:
                // 网络较差，将消息加入队列等待批量发送
                QueueMessageForBatchSend(userId, sessionId, update);
                break;
        }
    }
    
    private async Task SendMessageDirectlyAsync(string userId, string sessionId, StateUpdate update)
    {
        var message = new SocketMessage { Type = MessageType.StateUpdate, Data = update };
        
        // 对于重要消息，使用可靠发送
        bool isImportantMessage = update.StateType == StateType.Lock || update.StateType == StateType.Approval;
        
        if (isImportantMessage)
        {
            await _socketManager.SendReliableMessageAsync(userId, sessionId, message, _retryAttempts);
        }
        else
        {
            await _socketManager.SendMessageAsync(userId, sessionId, message);
        }
    }
    
    private async Task SendCompressedMessageAsync(string userId, string sessionId, StateUpdate update)
    {
        var message = new SocketMessage { Type = MessageType.StateUpdate, Data = update };
        
        // 序列化消息
        string serializedMessage = JsonSerializer.Serialize(message);
        
        // 压缩消息
        byte[] compressedData = await _compressionService.CompressAsync(
            Encoding.UTF8.GetBytes(serializedMessage), 
            _currentCompressionLevel);
        
        // 创建压缩消息
        var compressedMessage = new SocketMessage
        {
            Type = MessageType.CompressedStateUpdate,
            Data = compressedData
        };
        
        // 发送压缩消息
        await _socketManager.SendReliableMessageAsync(userId, sessionId, compressedMessage, _retryAttempts);
    }
    
    private void QueueMessageForBatchSend(string userId, string sessionId, StateUpdate update)
    {
        string key = $"{userId}:{sessionId}";
        
        var queuedMessage = new QueuedSyncMessage
        {
            UserId = userId,
            SessionId = sessionId,
            Update = update,
            QueueTime = DateTime.Now,
            RetryCount = 0
        };
        
        var messageList = _pendingMessages.GetOrAdd(key, _ => new List<QueuedSyncMessage>());
        
        lock (messageList)
        {
            messageList.Add(queuedMessage);
        }
        
        // 如果队列达到一定大小，立即处理
        if (messageList.Count >= _messageBatchSize)
        {
            ProcessPendingMessagesForUser(userId, sessionId);
        }
    }
    
    private void ProcessPendingMessages(object state)
    {
        try
        {
            foreach (var key in _pendingMessages.Keys.ToList())
            {
                string[] parts = key.Split(':');
                if (parts.Length == 2)
                {
                    ProcessPendingMessagesForUser(parts[0], parts[1]);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "处理待发送消息时发生异常");
        }
    }
    
    private void ProcessPendingMessagesForUser(string userId, string sessionId)
    {
        string key = $"{userId}:{sessionId}";
        
        if (!_pendingMessages.TryGetValue(key, out var messageList)) return;
        
        List<QueuedSyncMessage> messagesToProcess;
        
        lock (messageList)
        {
            if (messageList.Count == 0) return;
            
            // 获取要处理的消息（最多_messageBatchSize条）
            messagesToProcess = messageList.Take(_messageBatchSize).ToList();
            
            // 从队列中移除已处理的消息
            foreach (var msg in messagesToProcess)
            {
                messageList.Remove(msg);
            }
            
            // 如果队列为空，移除键
            if (messageList.Count == 0)
            {
                _pendingMessages.TryRemove(key, out _);
            }
        }
        
        // 创建批量更新消息
        if (messagesToProcess.Count > 0)
        {
            // 合并相同资源的更新
            var groupedUpdates = GroupAndMergeUpdates(messagesToProcess);
            
            // 异步发送合并后的消息
            _ = SendBatchUpdateAsync(userId, sessionId, groupedUpdates);
        }
    }
    
    private List<StateUpdate> GroupAndMergeUpdates(List<QueuedSyncMessage> messages)
    {
        // 按资源类型和资源ID分组
        var grouped = messages.GroupBy(m => $"{m.Update.ResourceType}:{m.Update.ResourceId}");
        var mergedUpdates = new List<StateUpdate>();
        
        foreach (var group in grouped)
        {
            // 获取最新的更新
            var latestUpdate = group.OrderByDescending(m => m.Update.Timestamp).First().Update;
            mergedUpdates.Add(latestUpdate);
        }
        
        return mergedUpdates;
    }
    
    private async Task SendBatchUpdateAsync(string userId, string sessionId, List<StateUpdate> updates)
    {
        try
        {
            var batchMessage = new SocketMessage
            {
                Type = MessageType.BatchStateUpdate,
                Data = updates
            };
            
            // 压缩批量消息
            string serializedMessage = JsonSerializer.Serialize(batchMessage);
            byte[] compressedData = await _compressionService.CompressAsync(
                Encoding.UTF8.GetBytes(serializedMessage), 
                _currentCompressionLevel);
            
            var compressedBatchMessage = new SocketMessage
            {
                Type = MessageType.CompressedBatchStateUpdate,
                Data = compressedData
            };
            
            // 发送压缩后的批量消息
            await _socketManager.SendReliableMessageAsync(userId, sessionId, compressedBatchMessage, _retryAttempts);
            
            _logger.LogInformation($"已发送批量状态更新: 用户={userId}, 消息数={updates.Count}");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, $"发送批量状态更新时发生异常: 用户={userId}");
            
            // 将消息重新加入队列
            foreach (var update in updates)
            {
                QueueMessageForBatchSend(userId, sessionId, update);
            }
        }
    }
    
    private void CheckNetworkQuality(object state)
    {
        try
        {
            // 执行网络质量检测
            var quality = _socketManager.GetCurrentNetworkQuality();
            
            // 更新网络质量和同步策略
            UpdateSyncStrategy(quality);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "检查网络质量时发生异常");
        }
    }
    
    private void OnConnectionQualityChanged(object sender, ConnectionQualityChangedEventArgs e)
    {
        UpdateSyncStrategy(e.NewQuality);
    }
    
    private void UpdateSyncStrategy(NetworkQuality quality)
    {
        _currentNetworkQuality = quality;
        
        // 根据网络质量调整策略参数
        switch (quality)
        {
            case NetworkQuality.Excellent:
                _currentCompressionLevel = CompressionLevel.NoCompression;
                _messageBatchSize = 20;
                _retryAttempts = 2;
                break;
                
            case NetworkQuality.Good:
                _currentCompressionLevel = CompressionLevel.Fastest;
                _messageBatchSize = 15;
                _retryAttempts = 2;
                break;
                
            case NetworkQuality.Fair:
                _currentCompressionLevel = CompressionLevel.Optimal;
                _messageBatchSize = 10;
                _retryAttempts = 3;
                break;
                
            case NetworkQuality.Poor:
                _currentCompressionLevel = CompressionLevel.SmallestSize;
                _messageBatchSize = 5;
                _retryAttempts = 5;
                break;
                
            case NetworkQuality.VeryPoor:
                _currentCompressionLevel = CompressionLevel.SmallestSize;
                _messageBatchSize = 3;
                _retryAttempts = 10;
                // 减少同步频率
                _networkQualityTimer.Change(TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30));
                break;
        }
        
        _logger.LogInformation($"网络质量更新为: {quality}, 调整后的压缩级别: {_currentCompressionLevel}, 批量大小: {_messageBatchSize}, 重试次数: {_retryAttempts}");
    }
    
    private void OnMessageSent(object sender, MessageSentEventArgs e)
    {
        // 记录消息发送成功
        _logger.LogDebug($"消息发送成功: 用户={e.UserId}, 类型={e.MessageType}");
    }
    
    private void OnMessageFailed(object sender, MessageFailedEventArgs e)
    {
        // 记录消息发送失败
        _logger.LogWarning($"消息发送失败: 用户={e.UserId}, 类型={e.MessageType}, 错误={e.ErrorMessage}");
        
        // 如果是重要消息且重试次数未达上限，重新发送
        if (e.IsImportant && e.RetryCount < _retryAttempts)
        {
            // 实现指数退避重试
            int backoffMs = (int)Math.Pow(2, e.RetryCount) * 100;
            _logger.LogInformation($"将在 {backoffMs}ms 后重试发送消息: 用户={e.UserId}");
            
            Task.Delay(backoffMs).ContinueWith(_ =>
            {
                // 重新发送逻辑
                // 实现略
            });
        }
    }
}
```

## 3. 前端锁定与状态同步实现

### 3.1 客户端锁定管理

在客户端实现锁定管理，处理锁定状态显示、锁定申请和释放等操作：

```csharp
public class ClientLockManager : IClientLockManager
{
    private readonly ISocketClient _socketClient;
    private readonly ILogger<ClientLockManager> _logger;
    private readonly ConcurrentDictionary<string, ClientLockInfo> _activeLocks;
    private readonly Timer _lockExpiryCheckTimer;
    private readonly ILockRenewer _lockRenewer;
    
    public event EventHandler<LockStatusChangedEventArgs> LockStatusChanged;
    public event EventHandler<LockExpiringEventArgs> LockExpiring;
    public event EventHandler<LockLostEventArgs> LockLost;
    
    public ClientLockManager(ISocketClient socketClient, ILogger<ClientLockManager> logger, ILockRenewer lockRenewer)
    {
        _socketClient = socketClient;
        _logger = logger;
        _activeLocks = new ConcurrentDictionary<string, ClientLockInfo>();
        _lockRenewer = lockRenewer;
        
        // 注册Socket事件处理
        _socketClient.OnLockStatusChanged += OnRemoteLockStatusChanged;
        _socketClient.OnLockLostNotification += OnLockLostNotification;
        
        // 初始化锁定过期检查定时器，每60秒检查一次
        _lockExpiryCheckTimer = new Timer(CheckLockExpiry, null, TimeSpan.FromSeconds(60), TimeSpan.FromSeconds(60));
    }
    
    public async Task<LockResponse> RequestLockAsync(LockRequest request)
    {
        // 生成锁定请求ID
        request.RequestId = Guid.NewGuid().ToString();
        
        // 发送锁定请求
        var response = await _socketClient.SendRequestAsync<LockRequest, LockResponse>(
            MessageType.RequestLock, request);
        
        if (response.Success)
        {
            // 记录活跃锁定
            var lockInfo = new ClientLockInfo
            {
                LockId = response.LockId,
                ResourceId = request.ResourceId,
                ResourceType = request.ResourceType,
                UserId = request.UserId,
                UserName = request.UserName,
                SessionId = request.SessionId,
                AcquireTime = DateTime.Now,
                ExpiryTime = response.ExpiryTime,
                LockType = request.LockType
            };
            
            string key = $"{request.ResourceType}:{request.ResourceId}";
            _activeLocks[key] = lockInfo;
            
            // 注册锁定续期
            _lockRenewer.RegisterLockForRenewal(
                response.LockId,
                request.ResourceId,
                request.ResourceType,
                request.UserId,
                request.SessionId,
                response.ExpiryTime - DateTime.Now);
            
            // 触发锁定状态变更事件
            OnLockStatusChanged(new LockStatusChangedEventArgs
            {
                ResourceId = request.ResourceId,
                ResourceType = request.ResourceType,
                IsLocked = true,
                LockInfo = lockInfo
            });
            
            _logger.LogInformation($"成功获取锁定: 资源={request.ResourceType}:{request.ResourceId}");
        }
        else if (response.CurrentLockInfo != null)
        {
            _logger.LogInformation($"锁定请求被拒绝: 资源={request.ResourceType}:{request.ResourceId}, 当前锁定用户={response.CurrentLockInfo.UserName}");
        }
        
        return response;
    }
    
    public async Task<LockResponse> ReleaseLockAsync(string resourceId, string resourceType)
    {
        string key = $"{resourceType}:{resourceId}";
        
        if (!_activeLocks.TryGetValue(key, out var lockInfo))
        {
            return new LockResponse
            {
                Success = false,
                Message = "未找到活跃的锁定"
            };
        }
        
        // 发送解锁请求
        var response = await _socketClient.SendRequestAsync<UnlockRequest, LockResponse>(
            MessageType.ReleaseLock,
            new UnlockRequest
            {
                ResourceId = resourceId,
                ResourceType = resourceType,
                LockId = lockInfo.LockId,
                UserId = lockInfo.UserId,
                SessionId = lockInfo.SessionId
            });
        
        if (response.Success)
        {
            // 移除活跃锁定记录
            _activeLocks.TryRemove(key, out _);
            
            // 取消锁定续期
            _lockRenewer.UnregisterLockForRenewal(lockInfo.LockId);
            
            // 触发锁定状态变更事件
            OnLockStatusChanged(new LockStatusChangedEventArgs
            {
                ResourceId = resourceId,
                ResourceType = resourceType,
                IsLocked = false,
                LockInfo = null
            });
            
            _logger.LogInformation($"成功释放锁定: 资源={resourceType}:{resourceId}");
        }
        
        return response;
    }
    
    public async Task<LockStatus> CheckLockStatusAsync(string resourceId, string resourceType)
    {
        // 发送锁定状态检查请求
        var response = await _socketClient.SendRequestAsync<LockStatusRequest, LockStatusResponse>(
            MessageType.CheckLockStatus,
            new LockStatusRequest
            {
                ResourceId = resourceId,
                ResourceType = resourceType
            });
        
        if (response != null)
        {
            return new LockStatus
            {
                IsLocked = response.IsLocked,
                CurrentLockInfo = response.CurrentLockInfo,
                ResourceId = resourceId,
                ResourceType = resourceType
            };
        }
        
        return new LockStatus
        {
            IsLocked = false,
            ResourceId = resourceId,
            ResourceType = resourceType
        };
    }
    
    public ClientLockInfo GetActiveLock(string resourceId, string resourceType)
    {
        string key = $"{resourceType}:{resourceId}";
        _activeLocks.TryGetValue(key, out var lockInfo);
        return lockInfo;
    }
    
    public bool IsResourceLockedByCurrentUser(string resourceId, string resourceType)
    {
        string key = $"{resourceType}:{resourceId}";
        return _activeLocks.ContainsKey(key);
    }
    
    public void UpdateUserActivity(string resourceId, string resourceType)
    {
        string key = $"{resourceType}:{resourceId}";
        if (_activeLocks.TryGetValue(key, out var lockInfo))
        {
            _lockRenewer.UpdateUserActivity(lockInfo.LockId);
        }
    }
    
    private void CheckLockExpiry(object state)
    {
        try
        {
            var now = DateTime.Now;
            
            foreach (var lockInfo in _activeLocks.Values)
            {
                // 检查锁定是否即将过期（剩余时间小于5分钟）
                TimeSpan timeUntilExpiry = lockInfo.ExpiryTime - now;
                
                if (timeUntilExpiry.TotalMinutes < 5 && timeUntilExpiry.TotalMinutes > 0)
                {
                    // 触发锁定即将过期事件
                    OnLockExpiring(new LockExpiringEventArgs
                    {
                        ResourceId = lockInfo.ResourceId,
                        ResourceType = lockInfo.ResourceType,
                        TimeUntilExpiry = timeUntilExpiry,
                        LockInfo = lockInfo
                    });
                }
                else if (timeUntilExpiry.TotalSeconds < 0)
                {
                    // 锁定已过期
                    OnLockLost(new LockLostEventArgs
                    {
                        ResourceId = lockInfo.ResourceId,
                        ResourceType = lockInfo.ResourceType,
                        Reason = "锁定已过期",
                        LockInfo = lockInfo
                    });
                    
                    // 移除过期的锁定
                    string key = $"{lockInfo.ResourceType}:{lockInfo.ResourceId}";
                    _activeLocks.TryRemove(key, out _);
                    _lockRenewer.UnregisterLockForRenewal(lockInfo.LockId);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "检查锁定过期状态时发生异常");
        }
    }
    
    private void OnRemoteLockStatusChanged(object sender, LockStatusChangedEventArgs e)
    {
        // 处理远程锁定状态变更
        // 例如，如果其他用户锁定了当前正在编辑的资源，通知用户
        string key = $"{e.ResourceType}:{e.ResourceId}";
        
        if (e.IsLocked && !_activeLocks.ContainsKey(key))
        {
            // 资源被其他用户锁定
            _logger.LogInformation($"资源被远程锁定: 资源={e.ResourceType}:{e.ResourceId}, 用户={e.LockInfo.UserName}");
            
            // 触发锁定状态变更事件
            OnLockStatusChanged(e);
        }
        else if (!e.IsLocked && _activeLocks.ContainsKey(key))
        {
            // 锁定被释放，但本地仍记录为锁定状态，可能是锁定丢失
            var lockInfo = _activeLocks[key];
            
            OnLockLost(new LockLostEventArgs
            {
                ResourceId = e.ResourceId,
                ResourceType = e.ResourceType,
                Reason = "锁定被远程释放",
                LockInfo = lockInfo
            });
            
            // 移除锁定记录
            _activeLocks.TryRemove(key, out _);
            _lockRenewer.UnregisterLockForRenewal(lockInfo.LockId);
        }
    }
    
    private void OnLockLostNotification(object sender, LockLostNotificationEventArgs e)
    {
        // 处理锁定丢失通知
        string key = $"{e.ResourceType}:{e.ResourceId}";
        
        if (_activeLocks.TryGetValue(key, out var lockInfo))
        {
            OnLockLost(new LockLostEventArgs
            {
                ResourceId = e.ResourceId,
                ResourceType = e.ResourceType,
                Reason = e.Reason,
                LockInfo = lockInfo
            });
            
            // 移除锁定记录
            _activeLocks.TryRemove(key, out _);
            _lockRenewer.UnregisterLockForRenewal(lockInfo.LockId);
        }
    }
    
    protected virtual void OnLockStatusChanged(LockStatusChangedEventArgs e)
    {
        LockStatusChanged?.Invoke(this, e);
    }
    
    protected virtual void OnLockExpiring(LockExpiringEventArgs e)
    {
        LockExpiring?.Invoke(this, e);
    }
    
    protected virtual void OnLockLost(LockLostEventArgs e)
    {
        LockLost?.Invoke(this, e);
        _logger.LogWarning($"锁定丢失: 资源={e.ResourceType}:{e.ResourceId}, 原因={e.Reason}");
    }
    
    public async Task<RenewalStatus> RenewLockAsync(string resourceId, string resourceType)
    {
        string key = $"{resourceType}:{resourceId}";
        
        if (!_activeLocks.TryGetValue(key, out var lockInfo))
        {
            return new RenewalStatus { Success = false, Message = "未找到活跃的锁定" };
        }
        
        // 调用锁定续期服务
        var result = await _lockRenewer.ManualRenewLockAsync(
            lockInfo.LockId,
            lockInfo.UserId,
            lockInfo.SessionId);
        
        if (result.Success)
        {
            // 更新本地锁定信息
            lockInfo.ExpiryTime = result.NewExpiryTime;
            _activeLocks[key] = lockInfo;
            
            _logger.LogInformation($"锁定续期成功: 资源={resourceType}:{resourceId}, 新过期时间={result.NewExpiryTime}");
        }
        
        return result;
    }
}
```

### 3.2 前端状态同步组件

实现前端状态同步组件，处理状态订阅、更新和UI刷新等操作：

```csharp
public class StateSyncComponent : ComponentBase
{
    [Inject] private IClientLockManager LockManager { get; set; }
    [Inject] private IStateSynchronizer StateSynchronizer { get; set; }
    [Inject] private ILogger<StateSyncComponent> Logger { get; set; }
    
    [Parameter] public string ResourceId { get; set; }
    [Parameter] public string ResourceType { get; set; }
    [Parameter] public bool AutoLockOnEdit { get; set; } = true;
    [Parameter] public bool ShowLockStatus { get; set; } = true;
    [Parameter] public RenderFragment ChildContent { get; set; }
    [Parameter] public EventCallback<LockStatusChangedEventArgs> OnLockStatusChanged { get; set; }
    [Parameter] public EventCallback<StateUpdate> OnStateUpdated { get; set; }
    [Parameter] public EventCallback<LockLostEventArgs> OnLockLost { get; set; }
    
    protected bool IsLockedByCurrentUser { get; private set; }
    protected LockInfo CurrentLockInfo { get; private set; }
    protected bool IsEditMode { get; set; }
    protected bool IsLocking { get; private set; }
    protected bool IsSubscriptionActive { get; private set; }
    protected CancellationTokenSource _renewalTokenSource;
    protected CancellationToken _renewalCancellationToken;
    
    protected override async Task OnInitializedAsync()
    {
        // 订阅锁定状态变更事件
        LockManager.LockStatusChanged += HandleLockStatusChanged;
        LockManager.LockLost += HandleLockLost;
        
        // 订阅状态同步事件
        StateSynchronizer.OnStateUpdate += HandleStateUpdate;
        
        // 初始化锁定状态检查
        await CheckInitialLockStatus();
        
        // 订阅资源状态变更
        await SubscribeToResourceState();
        
        Logger.LogInformation($"状态同步组件初始化: 资源={ResourceType}:{ResourceId}");
        
        await base.OnInitializedAsync();
    }
    
    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        
        // 确保ResourceId和ResourceType不为空
        if (string.IsNullOrEmpty(ResourceId) || string.IsNullOrEmpty(ResourceType))
        {
            throw new ArgumentNullException("ResourceId和ResourceType不能为空");
        }
    }
    
    protected async Task EnterEditModeAsync()
    {
        if (IsEditMode)
            return;
        
        try
        {
            IsLocking = true;
            
            // 如果启用自动锁定，则尝试获取锁定
            if (AutoLockOnEdit)
            {
                var lockRequest = new LockRequest
                {
                    ResourceId = ResourceId,
                    ResourceType = ResourceType,
                    UserId = await GetCurrentUserId(),
                    UserName = await GetCurrentUserName(),
                    SessionId = await GetCurrentSessionId(),
                    LockType = LockType.Edit
                };
                
                var response = await LockManager.RequestLockAsync(lockRequest);
                
                if (!response.Success)
                {
                    // 锁定失败，显示冲突信息
                    await ShowLockConflictNotification(response.CurrentLockInfo);
                    return;
                }
            }
            
            // 进入编辑模式
            IsEditMode = true;
            
            // 初始化锁定续期令牌
            _renewalTokenSource = new CancellationTokenSource();
            _renewalCancellationToken = _renewalTokenSource.Token;
            
            // 启动后台续期任务
            _ = StartAutoRenewalAsync();
            
            Logger.LogInformation($"进入编辑模式: 资源={ResourceType}:{ResourceId}");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"进入编辑模式失败: 资源={ResourceType}:{ResourceId}");
            throw;
        }
        finally
        {
            IsLocking = false;
        }
    }
    
    protected async Task ExitEditModeAsync(bool saveChanges = false)
    {
        if (!IsEditMode)
            return;
        
        try
        {
            // 取消续期任务
            if (_renewalTokenSource != null)
            {
                _renewalTokenSource.Cancel();
                _renewalTokenSource.Dispose();
                _renewalTokenSource = null;
            }
            
            // 释放锁定
            if (IsLockedByCurrentUser && AutoLockOnEdit)
            {
                await LockManager.ReleaseLockAsync(ResourceId, ResourceType);
            }
            
            // 退出编辑模式
            IsEditMode = false;
            IsLockedByCurrentUser = false;
            CurrentLockInfo = null;
            
            Logger.LogInformation($"退出编辑模式: 资源={ResourceType}:{ResourceId}, 保存更改={saveChanges}");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"退出编辑模式失败: 资源={ResourceType}:{ResourceId}");
            throw;
        }
    }
    
    protected async Task HandleLockStatusChanged(object sender, LockStatusChangedEventArgs e)
    {
        if (e.ResourceId == ResourceId && e.ResourceType == ResourceType)
        {
            IsLockedByCurrentUser = LockManager.IsResourceLockedByCurrentUser(ResourceId, ResourceType);
            CurrentLockInfo = e.LockInfo;
            
            await OnLockStatusChanged.InvokeAsync(e);
            StateHasChanged();
        }
    }
    
    protected async Task HandleLockLost(object sender, LockLostEventArgs e)
    {
        if (e.ResourceId == ResourceId && e.ResourceType == ResourceType && IsEditMode)
        {
            // 锁定丢失，退出编辑模式
            IsEditMode = false;
            IsLockedByCurrentUser = false;
            CurrentLockInfo = null;
            
            await OnLockLost.InvokeAsync(e);
            await ShowLockLostNotification(e.Reason);
            StateHasChanged();
        }
    }
    
    protected async Task HandleStateUpdate(StateUpdate update)
    {
        if (update.ResourceId == ResourceId && update.ResourceType == ResourceType)
        {
            await OnStateUpdated.InvokeAsync(update);
            StateHasChanged();
        }
    }
    
    protected async Task CheckInitialLockStatus()
    {
        var lockStatus = await LockManager.CheckLockStatusAsync(ResourceId, ResourceType);
        IsLockedByCurrentUser = LockManager.IsResourceLockedByCurrentUser(ResourceId, ResourceType);
        CurrentLockInfo = lockStatus.CurrentLockInfo;
    }
    
    protected async Task SubscribeToResourceState()
    {
        try
        {
            await StateSynchronizer.SubscribeAsync(ResourceId, ResourceType);
            IsSubscriptionActive = true;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"订阅资源状态失败: 资源={ResourceType}:{ResourceId}");
            IsSubscriptionActive = false;
        }
    }
    
    protected async Task UnsubscribeFromResourceState()
    {
        if (IsSubscriptionActive)
        {
            try
            {
                await StateSynchronizer.UnsubscribeAsync(ResourceId, ResourceType);
                IsSubscriptionActive = false;
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, $"取消订阅资源状态失败: 资源={ResourceType}:{ResourceId}");
            }
        }
    }
    
    protected async Task StartAutoRenewalAsync()
    {
        try
        {
            while (!_renewalCancellationToken.IsCancellationRequested)
            {
                // 等待锁定过期前一半时间再续期（例如锁定时间为10分钟，则在5分钟后续期）
                await Task.Delay(TimeSpan.FromMinutes(5), _renewalCancellationToken);
                
                if (!_renewalCancellationToken.IsCancellationRequested && IsEditMode && IsLockedByCurrentUser)
                {
                    await LockManager.RenewLockAsync(ResourceId, ResourceType);
                }
            }
        }
        catch (TaskCanceledException)
        {
            // 任务被取消，正常退出
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, $"自动锁定续期失败: 资源={ResourceType}:{ResourceId}");
        }
    }
    
    protected async Task ShowLockConflictNotification(LockInfo currentLockInfo)
    {
        // 显示锁定冲突通知，提示用户资源已被其他用户锁定
        // 实现略
    }
    
    protected async Task ShowLockLostNotification(string reason)
    {
        // 显示锁定丢失通知，提示用户锁定已丢失
        // 实现略
    }
    
    protected async Task<string> GetCurrentUserId()
    {
        // 获取当前用户ID
        // 实现略
        return "current_user_id";
    }
    
    protected async Task<string> GetCurrentUserName()
    {
        // 获取当前用户名称
        // 实现略
        return "当前用户";
    }
    
    protected async Task<string> GetCurrentSessionId()
    {
        // 获取当前会话ID
        // 实现略
        return "current_session_id";
    }
    
    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            // 取消订阅事件
            LockManager.LockStatusChanged -= HandleLockStatusChanged;
            LockManager.LockLost -= HandleLockLost;
            StateSynchronizer.OnStateUpdate -= HandleStateUpdate;
            
            // 释放资源
            if (_renewalTokenSource != null)
            {
                _renewalTokenSource.Cancel();
                _renewalTokenSource.Dispose();
            }
            
            // 取消订阅状态更新
            _ = UnsubscribeFromResourceState();
            
            // 如果仍处于编辑模式且拥有锁定，则释放锁定
            if (IsEditMode && IsLockedByCurrentUser && AutoLockOnEdit)
            {
                _ = LockManager.ReleaseLockAsync(ResourceId, ResourceType);
            }
        }
    }
    
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Logger.LogInformation($"状态同步组件渲染完成: 资源={ResourceType}:{ResourceId}");
        }
        
        await base.OnAfterRenderAsync(firstRender);
    }

## 4. 实时状态同步优化总结

通过以上优化策略，我们实现了一个健壮的分布式锁定机制与高效的状态同步系统，具有以下特点：

1. **多级别冲突检测**：通过EnhancedLockConflictDetector实现了对不同类型资源的精细冲突检测，支持单表和主子表结构。

2. **智能冲突解决策略**：AdaptiveLockConflictResolver根据资源类型、用户权限和系统负载自动选择最优的冲突解决策略。

3. **智能锁定续期**：SmartLockRenewer实现了基于用户活动感知的智能锁定续期，确保资源在用户实际编辑时不会被释放，同时在用户长时间不活动时自动释放资源。

4. **分层状态同步**：采用HierarchicalStateSynchronizer实现了核心状态、扩展状态和UI状态的分层管理，减少了不必要的数据传输。

5. **增量状态同步**：通过IncrementalStateSyncManager实现了基于差异计算的增量同步，显著减少了网络流量。

6. **网络自适应同步**：NetworkAdaptiveSyncManager能够根据网络质量动态调整同步策略，包括压缩、重试和批量处理，提高了同步的可靠性。

7. **前端锁定管理**：ClientLockManager提供了完整的客户端锁定生命周期管理，包括锁定申请、释放、状态检查和事件通知。

8. **前端状态同步组件**：StateSyncComponent封装了锁定状态管理、状态订阅和UI更新逻辑，提供了完整的生命周期管理和资源释放机制。

这些优化策略共同构成了一个高效、可靠的分布式锁定与状态同步系统，能够在多用户并发编辑的场景下确保数据一致性，同时提供良好的用户体验。

## 5. 集成与测试建议

1. **分阶段集成**：先在非核心业务模块部署，验证效果后再推广到核心业务模块。

2. **性能测试**：模拟多用户并发编辑场景，测试系统在高负载下的性能和稳定性。

3. **故障恢复测试**：模拟网络断开、服务器重启等故障场景，测试系统的自动恢复能力。

4. **监控告警**：部署监控系统，监控锁定状态、冲突事件和同步延迟等关键指标，设置适当的告警阈值。

5. **用户培训**：针对锁定机制和状态同步功能，为终端用户提供培训，确保他们了解系统行为和最佳实践。