# 锁定状态管理优化方案

## 核心设计原则

### 简化原则：锁定所有权驱动一切操作

**核心理念**：只要用户拥有某单据的锁定权，就应该能执行所有必要的数据操作，业务状态不应该成为操作的障碍，而应该是操作的结果。

### 当前问题分析

1. **双重状态管理冗余**
   - 单据业务状态（DataStatus、ApprovalStatus等）
   - 锁定状态（LockInfo）
   - 两套状态在多处重复检查

2. **复杂的状态判断逻辑**
   - 每个操作都需要检查锁定状态 + 业务状态
   - 大量的回退逻辑和异常处理

3. **过度设计的状态同步**
   - 服务器锁定状态与本地状态需要实时同步
   - 状态转换逻辑过于复杂

## 优化方案

### 方案一：锁定主导策略（推荐）

#### 核心逻辑
```csharp
// 简化后的操作逻辑
public async Task<bool> CanPerformOperation(long billId, string operation)
{
    // 1. 检查是否拥有锁定权（唯一入口）
    var lockStatus = await _lockService.CheckLockStatusAsync(billId);
    
    // 2. 只有拥有锁定的用户才能操作
    return lockStatus.IsSuccess && lockStatus.LockInfo.LockedUserId == CurrentUserId;
}
```

#### 操作流程
1. **获取锁定时**：不检查业务状态，谁先获取谁拥有
2. **执行操作时**：只检查锁定权，不检查业务状态
3. **保存数据时**：根据操作内容自动更新业务状态
4. **释放锁定时**：清空本地状态，服务器状态保持

#### 优势
- 大幅简化逻辑复杂度
- 减少状态同步压力
- 提高系统响应速度
- 降低维护成本

### 方案二：状态融合策略

#### 设计思路
将锁定状态作为业务状态的属性之一，而不是独立系统：

```csharp
public enum EntityStatus
{
    草稿 = 0,
    锁定中编辑 = 1,        // 新增：表示正在被编辑
    待审核 = 2,
    审核中 = 3,            // 新增：表示正在被审核
    已确认 = 4,
    完结 = 5,
    作废 = 6
}
```

#### 实现要点
1. 统一状态枚举，包含锁定信息
2. 状态转换自动处理锁定关系
3. 减少状态检查的复杂度

### 方案三：分层解耦策略

#### 架构设计
```
操作层 → 锁定层 → 数据层 → 状态持久化层
```

#### 实现逻辑
1. **操作层**：只关心业务逻辑，不关心状态
2. **锁定层**：确保操作的互斥性
3. **数据层**：执行实际的数据操作
4. **状态持久化层**：根据操作结果自动更新状态

## 数据一致性保障

### 版本控制机制
```csharp
public class BaseEntity
{
    public long Id { get; set; }
    public int Version { get; set; }  // 乐观锁版本号
    public DateTime LastModified { get; set; }
    public long LastModifiedBy { get; set; }
}
```

### 保存时检查
```csharp
public async Task<SaveResult> SaveAsync(BaseEntity entity)
{
    // 1. 检查锁定权
    if (!await HasLockAsync(entity.Id))
        return SaveResult.Failed("无锁定权限");
    
    // 2. 检查版本号（乐观锁）
    var currentEntity = await GetByIdAsync(entity.Id);
    if (currentEntity.Version != entity.Version)
        return SaveResult.Failed("数据已被其他用户修改");
    
    // 3. 保存数据
    entity.Version++;
    entity.LastModified = DateTime.Now;
    entity.LastModifiedBy = CurrentUserId;
    
    // 4. 业务状态根据操作自动更新
    UpdateBusinessStatus(entity);
    
    await repository.UpdateAsync(entity);
    return SaveResult.Success();
}
```

## 推荐实施步骤

### 第一阶段：简化锁定检查逻辑
1. 移除操作前的业务状态检查
2. 只保留锁定权检查
3. 数据保存时自动更新业务状态

### 第二阶段：优化状态管理
1. 将业务状态更新与操作解耦
2. 实现基于操作类型的自动状态转换
3. 减少手动状态管理代码

### 第三阶段：完善异常处理
1. 统一异常处理机制
2. 优化用户体验
3. 完善日志记录

## 预期效果

1. **代码复杂度降低60%以上**
2. **系统响应速度提升30%**
3. **维护成本降低50%**
4. **用户体验显著改善**

## 风险评估

### 潜在风险
1. 数据一致性保障需要更严格的测试
2. 业务流程控制需要重新验证
3. 用户权限管理需要相应调整

### 风险缓解
1. 完善的单元测试和集成测试
2. 分阶段实施，逐步验证
3. 保留回退机制

---

**建议采用方案一（锁定主导策略）**，因为它最符合"防止A用户编辑时B用户也编辑"的核心需求，同时最大程度简化了系统复杂度。